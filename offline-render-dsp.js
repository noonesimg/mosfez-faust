'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var offlineRenderDspInnerStringified = "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar FaustModule = function() {\n  var _scriptDir = typeof document !== \"undefined\" && document.currentScript ? document.currentScript.src : void 0;\n  if (typeof __filename !== \"undefined\")\n    _scriptDir = _scriptDir || __filename;\n  return function(FaustModule2) {\n    FaustModule2 = FaustModule2 || {};\n    var Module = typeof FaustModule2 !== \"undefined\" ? FaustModule2 : {};\n    if (!Module.expectedDataFileDownloads) {\n      Module.expectedDataFileDownloads = 0;\n      Module.finishedDataFileDownloads = 0;\n    }\n    Module.expectedDataFileDownloads++;\n    (function() {\n      var loadPackage = function(metadata) {\n        if (typeof window === \"object\") {\n          window[\"encodeURIComponent\"](window.location.pathname.toString().substring(0, window.location.pathname.toString().lastIndexOf(\"/\")) + \"/\");\n        } else if (typeof location !== \"undefined\") {\n          encodeURIComponent(location.pathname.toString().substring(0, location.pathname.toString().lastIndexOf(\"/\")) + \"/\");\n        } else {\n          throw \"using preloaded data can only be done on a web page or in a web worker\";\n        }\n        var PACKAGE_NAME = \"../../lib/libfaust-wasm.data\";\n        var REMOTE_PACKAGE_BASE = \"libfaust-wasm.data\";\n        if (typeof Module[\"locateFilePackage\"] === \"function\" && !Module[\"locateFile\"]) {\n          Module[\"locateFile\"] = Module[\"locateFilePackage\"];\n          err(\"warning: you defined Module.locateFilePackage, that has been renamed to Module.locateFile (using your locateFilePackage for now)\");\n        }\n        var REMOTE_PACKAGE_NAME = Module[\"locateFile\"] ? Module[\"locateFile\"](REMOTE_PACKAGE_BASE, \"\") : REMOTE_PACKAGE_BASE;\n        var REMOTE_PACKAGE_SIZE = metadata[\"remote_package_size\"];\n        metadata[\"package_uuid\"];\n        function fetchRemotePackage(packageName, packageSize, callback2, errback) {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"GET\", packageName, true);\n          xhr.responseType = \"arraybuffer\";\n          xhr.onprogress = function(event) {\n            var url = packageName;\n            var size = packageSize;\n            if (event.total)\n              size = event.total;\n            if (event.loaded) {\n              if (!xhr.addedTotal) {\n                xhr.addedTotal = true;\n                if (!Module.dataFileDownloads)\n                  Module.dataFileDownloads = {};\n                Module.dataFileDownloads[url] = {\n                  loaded: event.loaded,\n                  total: size\n                };\n              } else {\n                Module.dataFileDownloads[url].loaded = event.loaded;\n              }\n              var total = 0;\n              var loaded = 0;\n              var num = 0;\n              for (var download in Module.dataFileDownloads) {\n                var data = Module.dataFileDownloads[download];\n                total += data.total;\n                loaded += data.loaded;\n                num++;\n              }\n              total = Math.ceil(total * Module.expectedDataFileDownloads / num);\n              if (Module[\"setStatus\"])\n                Module[\"setStatus\"](\"Downloading data... (\" + loaded + \"/\" + total + \")\");\n            } else if (!Module.dataFileDownloads) {\n              if (Module[\"setStatus\"])\n                Module[\"setStatus\"](\"Downloading data...\");\n            }\n          };\n          xhr.onerror = function(event) {\n            throw new Error(\"NetworkError for: \" + packageName);\n          };\n          xhr.onload = function(event) {\n            if (xhr.status == 200 || xhr.status == 304 || xhr.status == 206 || xhr.status == 0 && xhr.response) {\n              var packageData = xhr.response;\n              callback2(packageData);\n            } else {\n              throw new Error(xhr.statusText + \" : \" + xhr.responseURL);\n            }\n          };\n          xhr.send(null);\n        }\n        var fetchedCallback = null;\n        var fetched = Module[\"getPreloadedPackage\"] ? Module[\"getPreloadedPackage\"](REMOTE_PACKAGE_NAME, REMOTE_PACKAGE_SIZE) : null;\n        if (!fetched)\n          fetchRemotePackage(REMOTE_PACKAGE_NAME, REMOTE_PACKAGE_SIZE, function(data) {\n            if (fetchedCallback) {\n              fetchedCallback(data);\n              fetchedCallback = null;\n            } else {\n              fetched = data;\n            }\n          });\n        function runWithFS() {\n          function assert2(check, msg) {\n            if (!check)\n              throw msg + new Error().stack;\n          }\n          Module[\"FS_createPath\"](\"/\", \"libraries\", true, true);\n          function DataRequest(start, end, audio) {\n            this.start = start;\n            this.end = end;\n            this.audio = audio;\n          }\n          DataRequest.prototype = {\n            requests: {},\n            open: function(mode, name) {\n              this.name = name;\n              this.requests[name] = this;\n              Module[\"addRunDependency\"](\"fp \" + this.name);\n            },\n            send: function() {\n            },\n            onload: function() {\n              var byteArray = this.byteArray.subarray(this.start, this.end);\n              this.finish(byteArray);\n            },\n            finish: function(byteArray) {\n              var that = this;\n              Module[\"FS_createDataFile\"](this.name, null, byteArray, true, true, true);\n              Module[\"removeRunDependency\"](\"fp \" + that.name);\n              this.requests[this.name] = null;\n            }\n          };\n          var files = metadata[\"files\"];\n          for (var i = 0; i < files.length; ++i) {\n            new DataRequest(files[i][\"start\"], files[i][\"end\"], files[i][\"audio\"]).open(\"GET\", files[i][\"filename\"]);\n          }\n          function processPackageData(arrayBuffer) {\n            Module.finishedDataFileDownloads++;\n            assert2(arrayBuffer, \"Loading data file failed.\");\n            assert2(arrayBuffer instanceof ArrayBuffer, \"bad input to processPackageData\");\n            var byteArray = new Uint8Array(arrayBuffer);\n            DataRequest.prototype.byteArray = byteArray;\n            var files2 = metadata[\"files\"];\n            for (var i2 = 0; i2 < files2.length; ++i2) {\n              DataRequest.prototype.requests[files2[i2].filename].onload();\n            }\n            Module[\"removeRunDependency\"](\"datafile_../../lib/libfaust-wasm.data\");\n          }\n          Module[\"addRunDependency\"](\"datafile_../../lib/libfaust-wasm.data\");\n          if (!Module.preloadResults)\n            Module.preloadResults = {};\n          Module.preloadResults[PACKAGE_NAME] = { fromCache: false };\n          if (fetched) {\n            processPackageData(fetched);\n            fetched = null;\n          } else {\n            fetchedCallback = processPackageData;\n          }\n        }\n        if (Module[\"calledRun\"]) {\n          runWithFS();\n        } else {\n          if (!Module[\"preRun\"])\n            Module[\"preRun\"] = [];\n          Module[\"preRun\"].push(runWithFS);\n        }\n      };\n      loadPackage({\n        files: [\n          { filename: \"/libraries/hoa.lib\", start: 0, end: 13105, audio: 0 },\n          {\n            filename: \"/libraries/compressors.lib\",\n            start: 13105,\n            end: 58859,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/basics.lib\",\n            start: 58859,\n            end: 110385,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/dx7.lib\",\n            start: 110385,\n            end: 179488,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/analyzers.lib\",\n            start: 179488,\n            end: 212357,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/spats.lib\",\n            start: 212357,\n            end: 217531,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/envelopes.lib\",\n            start: 217531,\n            end: 228127,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/oscillators.lib\",\n            start: 228127,\n            end: 275738,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/mi.lib\",\n            start: 275738,\n            end: 293026,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/misceffects.lib\",\n            start: 293026,\n            end: 314755,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/version.lib\",\n            start: 314755,\n            end: 315662,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/webaudio.lib\",\n            start: 315662,\n            end: 327785,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/math.lib\",\n            start: 327785,\n            end: 349263,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/stdfaust.lib\",\n            start: 349263,\n            end: 350533,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/filter.lib\",\n            start: 350533,\n            end: 415919,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/delays.lib\",\n            start: 415919,\n            end: 430403,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/routes.lib\",\n            start: 430403,\n            end: 437029,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/soundfiles.lib\",\n            start: 437029,\n            end: 446390,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/tonestacks.lib\",\n            start: 446390,\n            end: 458744,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/aanl.lib\",\n            start: 458744,\n            end: 484841,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/wdmodels.lib\",\n            start: 484841,\n            end: 574662,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/all.lib\",\n            start: 574662,\n            end: 575678,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/music.lib\",\n            start: 575678,\n            end: 594112,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/tubes.lib\",\n            start: 594112,\n            end: 943901,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/effect.lib\",\n            start: 943901,\n            end: 1012931,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/vaeffects.lib\",\n            start: 1012931,\n            end: 1048800,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/maxmsp.lib\",\n            start: 1048800,\n            end: 1056659,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/platform.lib\",\n            start: 1056659,\n            end: 1059739,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/synths.lib\",\n            start: 1059739,\n            end: 1070990,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/sf.lib\",\n            start: 1070990,\n            end: 1072056,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/fds.lib\",\n            start: 1072056,\n            end: 1092602,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/reducemaps.lib\",\n            start: 1092602,\n            end: 1097438,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/phaflangers.lib\",\n            start: 1097438,\n            end: 1107359,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/filters.lib\",\n            start: 1107359,\n            end: 1212987,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/signals.lib\",\n            start: 1212987,\n            end: 1224932,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/instruments.lib\",\n            start: 1224932,\n            end: 1234327,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/quantizers.lib\",\n            start: 1234327,\n            end: 1244180,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/noises.lib\",\n            start: 1244180,\n            end: 1258842,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/oscillator.lib\",\n            start: 1258842,\n            end: 1278693,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/interpolators.lib\",\n            start: 1278693,\n            end: 1301737,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/demos.lib\",\n            start: 1301737,\n            end: 1364872,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/reverbs.lib\",\n            start: 1364872,\n            end: 1402697,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/physmodels.lib\",\n            start: 1402697,\n            end: 1573680,\n            audio: 0\n          },\n          {\n            filename: \"/libraries/maths.lib\",\n            start: 1573680,\n            end: 1595081,\n            audio: 0\n          }\n        ],\n        remote_package_size: 1595081,\n        package_uuid: \"04ea3dc2-3649-4af3-b126-173b06afc41a\"\n      });\n    })();\n    var moduleOverrides = {};\n    var key;\n    for (key in Module) {\n      if (Module.hasOwnProperty(key)) {\n        moduleOverrides[key] = Module[key];\n      }\n    }\n    var thisProgram = \"./this.program\";\n    var ENVIRONMENT_IS_WEB = false;\n    var ENVIRONMENT_IS_WORKER = false;\n    var ENVIRONMENT_IS_NODE = false;\n    var ENVIRONMENT_IS_SHELL = false;\n    ENVIRONMENT_IS_WEB = typeof window === \"object\";\n    ENVIRONMENT_IS_WORKER = typeof importScripts === \"function\";\n    ENVIRONMENT_IS_NODE = typeof process === \"object\" && typeof process.versions === \"object\" && typeof process.versions.node === \"string\";\n    ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n    if (Module[\"ENVIRONMENT\"]) {\n      throw new Error(\"Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)\");\n    }\n    var scriptDirectory = \"\";\n    function locateFile(path) {\n      if (Module[\"locateFile\"]) {\n        return Module[\"locateFile\"](path, scriptDirectory);\n      }\n      return scriptDirectory + path;\n    }\n    var read_, readBinary;\n    var nodeFS;\n    var nodePath;\n    if (ENVIRONMENT_IS_NODE) {\n      if (ENVIRONMENT_IS_WORKER) {\n        scriptDirectory = require(\"path\").dirname(scriptDirectory) + \"/\";\n      } else {\n        scriptDirectory = __dirname + \"/\";\n      }\n      read_ = function shell_read(filename, binary) {\n        if (!nodeFS)\n          nodeFS = require(\"fs\");\n        if (!nodePath)\n          nodePath = require(\"path\");\n        filename = nodePath[\"normalize\"](filename);\n        return nodeFS[\"readFileSync\"](filename, binary ? null : \"utf8\");\n      };\n      readBinary = function readBinary2(filename) {\n        var ret = read_(filename, true);\n        if (!ret.buffer) {\n          ret = new Uint8Array(ret);\n        }\n        assert(ret.buffer);\n        return ret;\n      };\n      if (process[\"argv\"].length > 1) {\n        thisProgram = process[\"argv\"][1].replace(/\\\\/g, \"/\");\n      }\n      process[\"argv\"].slice(2);\n      process[\"on\"](\"uncaughtException\", function(ex) {\n        if (!(ex instanceof ExitStatus)) {\n          throw ex;\n        }\n      });\n      process[\"on\"](\"unhandledRejection\", abort);\n      Module[\"inspect\"] = function() {\n        return \"[Emscripten Module object]\";\n      };\n    } else if (ENVIRONMENT_IS_SHELL) {\n      if (typeof read != \"undefined\") {\n        read_ = function shell_read(f) {\n          return read(f);\n        };\n      }\n      readBinary = function readBinary2(f) {\n        var data;\n        if (typeof readbuffer === \"function\") {\n          return new Uint8Array(readbuffer(f));\n        }\n        data = read(f, \"binary\");\n        assert(typeof data === \"object\");\n        return data;\n      };\n      if (typeof scriptArgs != \"undefined\") {\n        scriptArgs;\n      }\n      if (typeof print !== \"undefined\") {\n        if (typeof console === \"undefined\")\n          console = {};\n        console.log = print;\n        console.warn = console.error = typeof printErr !== \"undefined\" ? printErr : print;\n      }\n    } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n      if (ENVIRONMENT_IS_WORKER) {\n        scriptDirectory = self.location.href;\n      } else if (document.currentScript) {\n        scriptDirectory = document.currentScript.src;\n      }\n      if (_scriptDir) {\n        scriptDirectory = _scriptDir;\n      }\n      if (scriptDirectory.indexOf(\"blob:\") !== 0) {\n        scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf(\"/\") + 1);\n      } else {\n        scriptDirectory = \"\";\n      }\n      {\n        read_ = function shell_read(url) {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"GET\", url, false);\n          xhr.send(null);\n          return xhr.responseText;\n        };\n        if (ENVIRONMENT_IS_WORKER) {\n          readBinary = function readBinary2(url) {\n            var xhr = new XMLHttpRequest();\n            xhr.open(\"GET\", url, false);\n            xhr.responseType = \"arraybuffer\";\n            xhr.send(null);\n            return new Uint8Array(xhr.response);\n          };\n        }\n      }\n    } else {\n      throw new Error(\"environment detection error\");\n    }\n    var out = Module[\"print\"] || console.log.bind(console);\n    var err = Module[\"printErr\"] || console.warn.bind(console);\n    for (key in moduleOverrides) {\n      if (moduleOverrides.hasOwnProperty(key)) {\n        Module[key] = moduleOverrides[key];\n      }\n    }\n    moduleOverrides = null;\n    if (Module[\"arguments\"])\n      Module[\"arguments\"];\n    if (!Object.getOwnPropertyDescriptor(Module, \"arguments\"))\n      Object.defineProperty(Module, \"arguments\", {\n        configurable: true,\n        get: function() {\n          abort(\"Module.arguments has been replaced with plain arguments_\");\n        }\n      });\n    if (Module[\"thisProgram\"])\n      thisProgram = Module[\"thisProgram\"];\n    if (!Object.getOwnPropertyDescriptor(Module, \"thisProgram\"))\n      Object.defineProperty(Module, \"thisProgram\", {\n        configurable: true,\n        get: function() {\n          abort(\"Module.thisProgram has been replaced with plain thisProgram\");\n        }\n      });\n    if (Module[\"quit\"])\n      Module[\"quit\"];\n    if (!Object.getOwnPropertyDescriptor(Module, \"quit\"))\n      Object.defineProperty(Module, \"quit\", {\n        configurable: true,\n        get: function() {\n          abort(\"Module.quit has been replaced with plain quit_\");\n        }\n      });\n    assert(typeof Module[\"memoryInitializerPrefixURL\"] === \"undefined\", \"Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead\");\n    assert(typeof Module[\"pthreadMainPrefixURL\"] === \"undefined\", \"Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead\");\n    assert(typeof Module[\"cdInitializerPrefixURL\"] === \"undefined\", \"Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead\");\n    assert(typeof Module[\"filePackagePrefixURL\"] === \"undefined\", \"Module.filePackagePrefixURL option was removed, use Module.locateFile instead\");\n    assert(typeof Module[\"read\"] === \"undefined\", \"Module.read option was removed (modify read_ in JS)\");\n    assert(typeof Module[\"readAsync\"] === \"undefined\", \"Module.readAsync option was removed (modify readAsync in JS)\");\n    assert(typeof Module[\"readBinary\"] === \"undefined\", \"Module.readBinary option was removed (modify readBinary in JS)\");\n    assert(typeof Module[\"setWindowTitle\"] === \"undefined\", \"Module.setWindowTitle option was removed (modify setWindowTitle in JS)\");\n    assert(typeof Module[\"TOTAL_MEMORY\"] === \"undefined\", \"Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY\");\n    if (!Object.getOwnPropertyDescriptor(Module, \"read\"))\n      Object.defineProperty(Module, \"read\", {\n        configurable: true,\n        get: function() {\n          abort(\"Module.read has been replaced with plain read_\");\n        }\n      });\n    if (!Object.getOwnPropertyDescriptor(Module, \"readAsync\"))\n      Object.defineProperty(Module, \"readAsync\", {\n        configurable: true,\n        get: function() {\n          abort(\"Module.readAsync has been replaced with plain readAsync\");\n        }\n      });\n    if (!Object.getOwnPropertyDescriptor(Module, \"readBinary\"))\n      Object.defineProperty(Module, \"readBinary\", {\n        configurable: true,\n        get: function() {\n          abort(\"Module.readBinary has been replaced with plain readBinary\");\n        }\n      });\n    var stackSave;\n    var stackRestore;\n    var stackAlloc;\n    stackSave = stackRestore = stackAlloc = function() {\n      abort(\"cannot use the stack before compiled code is ready to run, and has provided stack access\");\n    };\n    function dynamicAlloc(size) {\n      assert(DYNAMICTOP_PTR);\n      var ret = HEAP32[DYNAMICTOP_PTR >> 2];\n      var end = ret + size + 15 & -16;\n      assert(end <= HEAP8.length, \"failure to dynamicAlloc - memory growth etc. is not supported there, call malloc/sbrk directly\");\n      HEAP32[DYNAMICTOP_PTR >> 2] = end;\n      return ret;\n    }\n    function getNativeTypeSize(type) {\n      switch (type) {\n        case \"i1\":\n        case \"i8\":\n          return 1;\n        case \"i16\":\n          return 2;\n        case \"i32\":\n          return 4;\n        case \"i64\":\n          return 8;\n        case \"float\":\n          return 4;\n        case \"double\":\n          return 8;\n        default: {\n          if (type[type.length - 1] === \"*\") {\n            return 4;\n          } else if (type[0] === \"i\") {\n            var bits = Number(type.substr(1));\n            assert(bits % 8 === 0, \"getNativeTypeSize invalid bits \" + bits + \", type \" + type);\n            return bits / 8;\n          } else {\n            return 0;\n          }\n        }\n      }\n    }\n    function warnOnce(text) {\n      if (!warnOnce.shown)\n        warnOnce.shown = {};\n      if (!warnOnce.shown[text]) {\n        warnOnce.shown[text] = 1;\n        err(text);\n      }\n    }\n    var wasmBinary;\n    if (Module[\"wasmBinary\"])\n      wasmBinary = Module[\"wasmBinary\"];\n    if (!Object.getOwnPropertyDescriptor(Module, \"wasmBinary\"))\n      Object.defineProperty(Module, \"wasmBinary\", {\n        configurable: true,\n        get: function() {\n          abort(\"Module.wasmBinary has been replaced with plain wasmBinary\");\n        }\n      });\n    if (Module[\"noExitRuntime\"])\n      Module[\"noExitRuntime\"];\n    if (!Object.getOwnPropertyDescriptor(Module, \"noExitRuntime\"))\n      Object.defineProperty(Module, \"noExitRuntime\", {\n        configurable: true,\n        get: function() {\n          abort(\"Module.noExitRuntime has been replaced with plain noExitRuntime\");\n        }\n      });\n    if (typeof WebAssembly !== \"object\") {\n      abort(\"No WebAssembly support found. Build with -s WASM=0 to target JavaScript instead.\");\n    }\n    function setValue(ptr, value, type, noSafe) {\n      type = type || \"i8\";\n      if (type.charAt(type.length - 1) === \"*\")\n        type = \"i32\";\n      switch (type) {\n        case \"i1\":\n          HEAP8[ptr >> 0] = value;\n          break;\n        case \"i8\":\n          HEAP8[ptr >> 0] = value;\n          break;\n        case \"i16\":\n          HEAP16[ptr >> 1] = value;\n          break;\n        case \"i32\":\n          HEAP32[ptr >> 2] = value;\n          break;\n        case \"i64\":\n          tempI64 = [\n            value >>> 0,\n            (tempDouble = value, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n          ], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];\n          break;\n        case \"float\":\n          HEAPF32[ptr >> 2] = value;\n          break;\n        case \"double\":\n          HEAPF64[ptr >> 3] = value;\n          break;\n        default:\n          abort(\"invalid type for setValue: \" + type);\n      }\n    }\n    var wasmMemory;\n    var wasmTable = new WebAssembly.Table({\n      initial: 2176,\n      maximum: 2176 + 0,\n      element: \"anyfunc\"\n    });\n    var ABORT = false;\n    function assert(condition, text) {\n      if (!condition) {\n        abort(\"Assertion failed: \" + text);\n      }\n    }\n    function getCFunc(ident) {\n      var func = Module[\"_\" + ident];\n      assert(func, \"Cannot call unknown function \" + ident + \", make sure it is exported\");\n      return func;\n    }\n    function ccall(ident, returnType, argTypes, args, opts) {\n      var toC = {\n        string: function(str) {\n          var ret2 = 0;\n          if (str !== null && str !== void 0 && str !== 0) {\n            var len = (str.length << 2) + 1;\n            ret2 = stackAlloc(len);\n            stringToUTF8(str, ret2, len);\n          }\n          return ret2;\n        },\n        array: function(arr) {\n          var ret2 = stackAlloc(arr.length);\n          writeArrayToMemory(arr, ret2);\n          return ret2;\n        }\n      };\n      function convertReturnValue(ret2) {\n        if (returnType === \"string\")\n          return UTF8ToString(ret2);\n        if (returnType === \"boolean\")\n          return Boolean(ret2);\n        return ret2;\n      }\n      var func = getCFunc(ident);\n      var cArgs = [];\n      var stack = 0;\n      assert(returnType !== \"array\", 'Return type should not be \"array\".');\n      if (args) {\n        for (var i = 0; i < args.length; i++) {\n          var converter = toC[argTypes[i]];\n          if (converter) {\n            if (stack === 0)\n              stack = stackSave();\n            cArgs[i] = converter(args[i]);\n          } else {\n            cArgs[i] = args[i];\n          }\n        }\n      }\n      var ret = func.apply(null, cArgs);\n      ret = convertReturnValue(ret);\n      if (stack !== 0)\n        stackRestore(stack);\n      return ret;\n    }\n    function cwrap(ident, returnType, argTypes, opts) {\n      return function() {\n        return ccall(ident, returnType, argTypes, arguments);\n      };\n    }\n    var ALLOC_STACK = 1;\n    var ALLOC_NONE = 3;\n    function allocate(slab, types, allocator, ptr) {\n      var zeroinit, size;\n      if (typeof slab === \"number\") {\n        zeroinit = true;\n        size = slab;\n      } else {\n        zeroinit = false;\n        size = slab.length;\n      }\n      var singleType = typeof types === \"string\" ? types : null;\n      var ret;\n      if (allocator == ALLOC_NONE) {\n        ret = ptr;\n      } else {\n        ret = [_malloc, stackAlloc, dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length));\n      }\n      if (zeroinit) {\n        var stop;\n        ptr = ret;\n        assert((ret & 3) == 0);\n        stop = ret + (size & ~3);\n        for (; ptr < stop; ptr += 4) {\n          HEAP32[ptr >> 2] = 0;\n        }\n        stop = ret + size;\n        while (ptr < stop) {\n          HEAP8[ptr++ >> 0] = 0;\n        }\n        return ret;\n      }\n      if (singleType === \"i8\") {\n        if (slab.subarray || slab.slice) {\n          HEAPU8.set(slab, ret);\n        } else {\n          HEAPU8.set(new Uint8Array(slab), ret);\n        }\n        return ret;\n      }\n      var i = 0, type, typeSize, previousType;\n      while (i < size) {\n        var curr = slab[i];\n        type = singleType || types[i];\n        if (type === 0) {\n          i++;\n          continue;\n        }\n        assert(type, \"Must know what type to store in allocate!\");\n        if (type == \"i64\")\n          type = \"i32\";\n        setValue(ret + i, curr, type);\n        if (previousType !== type) {\n          typeSize = getNativeTypeSize(type);\n          previousType = type;\n        }\n        i += typeSize;\n      }\n      return ret;\n    }\n    function getMemory(size) {\n      if (!runtimeInitialized)\n        return dynamicAlloc(size);\n      return _malloc(size);\n    }\n    var UTF8Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf8\") : void 0;\n    function UTF8ArrayToString(u8Array, idx, maxBytesToRead) {\n      var endIdx = idx + maxBytesToRead;\n      var endPtr = idx;\n      while (u8Array[endPtr] && !(endPtr >= endIdx))\n        ++endPtr;\n      if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {\n        return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));\n      } else {\n        var str = \"\";\n        while (idx < endPtr) {\n          var u0 = u8Array[idx++];\n          if (!(u0 & 128)) {\n            str += String.fromCharCode(u0);\n            continue;\n          }\n          var u1 = u8Array[idx++] & 63;\n          if ((u0 & 224) == 192) {\n            str += String.fromCharCode((u0 & 31) << 6 | u1);\n            continue;\n          }\n          var u2 = u8Array[idx++] & 63;\n          if ((u0 & 240) == 224) {\n            u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n          } else {\n            if ((u0 & 248) != 240)\n              warnOnce(\"Invalid UTF-8 leading byte 0x\" + u0.toString(16) + \" encountered when deserializing a UTF-8 string on the asm.js/wasm heap to a JS string!\");\n            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u8Array[idx++] & 63;\n          }\n          if (u0 < 65536) {\n            str += String.fromCharCode(u0);\n          } else {\n            var ch = u0 - 65536;\n            str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n          }\n        }\n      }\n      return str;\n    }\n    function UTF8ToString(ptr, maxBytesToRead) {\n      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\";\n    }\n    function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {\n      if (!(maxBytesToWrite > 0))\n        return 0;\n      var startIdx = outIdx;\n      var endIdx = outIdx + maxBytesToWrite - 1;\n      for (var i = 0; i < str.length; ++i) {\n        var u = str.charCodeAt(i);\n        if (u >= 55296 && u <= 57343) {\n          var u1 = str.charCodeAt(++i);\n          u = 65536 + ((u & 1023) << 10) | u1 & 1023;\n        }\n        if (u <= 127) {\n          if (outIdx >= endIdx)\n            break;\n          outU8Array[outIdx++] = u;\n        } else if (u <= 2047) {\n          if (outIdx + 1 >= endIdx)\n            break;\n          outU8Array[outIdx++] = 192 | u >> 6;\n          outU8Array[outIdx++] = 128 | u & 63;\n        } else if (u <= 65535) {\n          if (outIdx + 2 >= endIdx)\n            break;\n          outU8Array[outIdx++] = 224 | u >> 12;\n          outU8Array[outIdx++] = 128 | u >> 6 & 63;\n          outU8Array[outIdx++] = 128 | u & 63;\n        } else {\n          if (outIdx + 3 >= endIdx)\n            break;\n          if (u >= 2097152)\n            warnOnce(\"Invalid Unicode code point 0x\" + u.toString(16) + \" encountered when serializing a JS string to an UTF-8 string on the asm.js/wasm heap! (Valid unicode code points should be in range 0-0x1FFFFF).\");\n          outU8Array[outIdx++] = 240 | u >> 18;\n          outU8Array[outIdx++] = 128 | u >> 12 & 63;\n          outU8Array[outIdx++] = 128 | u >> 6 & 63;\n          outU8Array[outIdx++] = 128 | u & 63;\n        }\n      }\n      outU8Array[outIdx] = 0;\n      return outIdx - startIdx;\n    }\n    function stringToUTF8(str, outPtr, maxBytesToWrite) {\n      assert(typeof maxBytesToWrite == \"number\", \"stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\");\n      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n    }\n    function lengthBytesUTF8(str) {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        var u = str.charCodeAt(i);\n        if (u >= 55296 && u <= 57343)\n          u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;\n        if (u <= 127)\n          ++len;\n        else if (u <= 2047)\n          len += 2;\n        else if (u <= 65535)\n          len += 3;\n        else\n          len += 4;\n      }\n      return len;\n    }\n    var UTF16Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf-16le\") : void 0;\n    function UTF16ToString(ptr) {\n      assert(ptr % 2 == 0, \"Pointer passed to UTF16ToString must be aligned to two bytes!\");\n      var endPtr = ptr;\n      var idx = endPtr >> 1;\n      while (HEAP16[idx])\n        ++idx;\n      endPtr = idx << 1;\n      if (endPtr - ptr > 32 && UTF16Decoder) {\n        return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n      } else {\n        var i = 0;\n        var str = \"\";\n        while (1) {\n          var codeUnit = HEAP16[ptr + i * 2 >> 1];\n          if (codeUnit == 0)\n            return str;\n          ++i;\n          str += String.fromCharCode(codeUnit);\n        }\n      }\n    }\n    function stringToUTF16(str, outPtr, maxBytesToWrite) {\n      assert(outPtr % 2 == 0, \"Pointer passed to stringToUTF16 must be aligned to two bytes!\");\n      assert(typeof maxBytesToWrite == \"number\", \"stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\");\n      if (maxBytesToWrite === void 0) {\n        maxBytesToWrite = 2147483647;\n      }\n      if (maxBytesToWrite < 2)\n        return 0;\n      maxBytesToWrite -= 2;\n      var startPtr = outPtr;\n      var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n      for (var i = 0; i < numCharsToWrite; ++i) {\n        var codeUnit = str.charCodeAt(i);\n        HEAP16[outPtr >> 1] = codeUnit;\n        outPtr += 2;\n      }\n      HEAP16[outPtr >> 1] = 0;\n      return outPtr - startPtr;\n    }\n    function lengthBytesUTF16(str) {\n      return str.length * 2;\n    }\n    function UTF32ToString(ptr) {\n      assert(ptr % 4 == 0, \"Pointer passed to UTF32ToString must be aligned to four bytes!\");\n      var i = 0;\n      var str = \"\";\n      while (1) {\n        var utf32 = HEAP32[ptr + i * 4 >> 2];\n        if (utf32 == 0)\n          return str;\n        ++i;\n        if (utf32 >= 65536) {\n          var ch = utf32 - 65536;\n          str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n        } else {\n          str += String.fromCharCode(utf32);\n        }\n      }\n    }\n    function stringToUTF32(str, outPtr, maxBytesToWrite) {\n      assert(outPtr % 4 == 0, \"Pointer passed to stringToUTF32 must be aligned to four bytes!\");\n      assert(typeof maxBytesToWrite == \"number\", \"stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\");\n      if (maxBytesToWrite === void 0) {\n        maxBytesToWrite = 2147483647;\n      }\n      if (maxBytesToWrite < 4)\n        return 0;\n      var startPtr = outPtr;\n      var endPtr = startPtr + maxBytesToWrite - 4;\n      for (var i = 0; i < str.length; ++i) {\n        var codeUnit = str.charCodeAt(i);\n        if (codeUnit >= 55296 && codeUnit <= 57343) {\n          var trailSurrogate = str.charCodeAt(++i);\n          codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;\n        }\n        HEAP32[outPtr >> 2] = codeUnit;\n        outPtr += 4;\n        if (outPtr + 4 > endPtr)\n          break;\n      }\n      HEAP32[outPtr >> 2] = 0;\n      return outPtr - startPtr;\n    }\n    function lengthBytesUTF32(str) {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        var codeUnit = str.charCodeAt(i);\n        if (codeUnit >= 55296 && codeUnit <= 57343)\n          ++i;\n        len += 4;\n      }\n      return len;\n    }\n    function allocateUTF8(str) {\n      var size = lengthBytesUTF8(str) + 1;\n      var ret = _malloc(size);\n      if (ret)\n        stringToUTF8Array(str, HEAP8, ret, size);\n      return ret;\n    }\n    function writeArrayToMemory(array, buffer2) {\n      assert(array.length >= 0, \"writeArrayToMemory array must have a length (should be an array or typed array)\");\n      HEAP8.set(array, buffer2);\n    }\n    function writeAsciiToMemory(str, buffer2, dontAddNull) {\n      for (var i = 0; i < str.length; ++i) {\n        assert(str.charCodeAt(i) === str.charCodeAt(i) & 255);\n        HEAP8[buffer2++ >> 0] = str.charCodeAt(i);\n      }\n      if (!dontAddNull)\n        HEAP8[buffer2 >> 0] = 0;\n    }\n    var WASM_PAGE_SIZE = 65536;\n    function alignUp(x, multiple) {\n      if (x % multiple > 0) {\n        x += multiple - x % multiple;\n      }\n      return x;\n    }\n    var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n    function updateGlobalBufferAndViews(buf) {\n      buffer = buf;\n      Module[\"HEAP8\"] = HEAP8 = new Int8Array(buf);\n      Module[\"HEAP16\"] = HEAP16 = new Int16Array(buf);\n      Module[\"HEAP32\"] = HEAP32 = new Int32Array(buf);\n      Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(buf);\n      Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(buf);\n      Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(buf);\n      Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(buf);\n      Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(buf);\n    }\n    var STACK_BASE = 7643408, STACK_MAX = 2400528, DYNAMIC_BASE = 7643408, DYNAMICTOP_PTR = 2400368;\n    assert(STACK_BASE % 16 === 0, \"stack must start aligned\");\n    assert(DYNAMIC_BASE % 16 === 0, \"heap must start aligned\");\n    var TOTAL_STACK = 5242880;\n    if (Module[\"TOTAL_STACK\"])\n      assert(TOTAL_STACK === Module[\"TOTAL_STACK\"], \"the stack size can no longer be determined at runtime\");\n    var INITIAL_INITIAL_MEMORY = Module[\"INITIAL_MEMORY\"] || 16777216;\n    if (!Object.getOwnPropertyDescriptor(Module, \"INITIAL_MEMORY\"))\n      Object.defineProperty(Module, \"INITIAL_MEMORY\", {\n        configurable: true,\n        get: function() {\n          abort(\"Module.INITIAL_MEMORY has been replaced with plain INITIAL_INITIAL_MEMORY\");\n        }\n      });\n    assert(INITIAL_INITIAL_MEMORY >= TOTAL_STACK, \"INITIAL_MEMORY should be larger than TOTAL_STACK, was \" + INITIAL_INITIAL_MEMORY + \"! (TOTAL_STACK=\" + TOTAL_STACK + \")\");\n    assert(typeof Int32Array !== \"undefined\" && typeof Float64Array !== \"undefined\" && Int32Array.prototype.subarray !== void 0 && Int32Array.prototype.set !== void 0, \"JS engine does not provide full typed array support\");\n    if (Module[\"wasmMemory\"]) {\n      wasmMemory = Module[\"wasmMemory\"];\n    } else {\n      wasmMemory = new WebAssembly.Memory({\n        initial: INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE\n      });\n    }\n    if (wasmMemory) {\n      buffer = wasmMemory.buffer;\n    }\n    INITIAL_INITIAL_MEMORY = buffer.byteLength;\n    assert(INITIAL_INITIAL_MEMORY % WASM_PAGE_SIZE === 0);\n    updateGlobalBufferAndViews(buffer);\n    HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;\n    function writeStackCookie() {\n      assert((STACK_MAX & 3) == 0);\n      HEAPU32[(STACK_MAX >> 2) + 1] = 34821223;\n      HEAPU32[(STACK_MAX >> 2) + 2] = 2310721022;\n      HEAP32[0] = 1668509029;\n    }\n    function checkStackCookie() {\n      var cookie1 = HEAPU32[(STACK_MAX >> 2) + 1];\n      var cookie2 = HEAPU32[(STACK_MAX >> 2) + 2];\n      if (cookie1 != 34821223 || cookie2 != 2310721022) {\n        abort(\"Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x2135467, but received 0x\" + cookie2.toString(16) + \" \" + cookie1.toString(16));\n      }\n      if (HEAP32[0] !== 1668509029)\n        abort(\"Runtime error: The application has corrupted its heap memory area (address zero)!\");\n    }\n    function abortStackOverflow(allocSize) {\n      abort(\"Stack overflow! Attempted to allocate \" + allocSize + \" bytes on the stack, but stack has only \" + (STACK_MAX - stackSave() + allocSize) + \" bytes available!\");\n    }\n    (function() {\n      var h16 = new Int16Array(1);\n      var h8 = new Int8Array(h16.buffer);\n      h16[0] = 25459;\n      if (h8[0] !== 115 || h8[1] !== 99)\n        throw \"Runtime error: expected the system to be little-endian!\";\n    })();\n    function callRuntimeCallbacks(callbacks) {\n      while (callbacks.length > 0) {\n        var callback2 = callbacks.shift();\n        if (typeof callback2 == \"function\") {\n          callback2();\n          continue;\n        }\n        var func = callback2.func;\n        if (typeof func === \"number\") {\n          if (callback2.arg === void 0) {\n            Module[\"dynCall_v\"](func);\n          } else {\n            Module[\"dynCall_vi\"](func, callback2.arg);\n          }\n        } else {\n          func(callback2.arg === void 0 ? null : callback2.arg);\n        }\n      }\n    }\n    var __ATPRERUN__ = [];\n    var __ATINIT__ = [];\n    var __ATMAIN__ = [];\n    var __ATPOSTRUN__ = [];\n    var runtimeInitialized = false;\n    var runtimeExited = false;\n    function preRun() {\n      if (Module[\"preRun\"]) {\n        if (typeof Module[\"preRun\"] == \"function\")\n          Module[\"preRun\"] = [Module[\"preRun\"]];\n        while (Module[\"preRun\"].length) {\n          addOnPreRun(Module[\"preRun\"].shift());\n        }\n      }\n      callRuntimeCallbacks(__ATPRERUN__);\n    }\n    function initRuntime() {\n      checkStackCookie();\n      assert(!runtimeInitialized);\n      runtimeInitialized = true;\n      SOCKFS.root = FS.mount(SOCKFS, {}, null);\n      if (!Module[\"noFSInit\"] && !FS.init.initialized)\n        FS.init();\n      callRuntimeCallbacks(__ATINIT__);\n    }\n    function preMain() {\n      checkStackCookie();\n      FS.ignorePermissions = false;\n      callRuntimeCallbacks(__ATMAIN__);\n    }\n    function postRun() {\n      checkStackCookie();\n      if (Module[\"postRun\"]) {\n        if (typeof Module[\"postRun\"] == \"function\")\n          Module[\"postRun\"] = [Module[\"postRun\"]];\n        while (Module[\"postRun\"].length) {\n          addOnPostRun(Module[\"postRun\"].shift());\n        }\n      }\n      callRuntimeCallbacks(__ATPOSTRUN__);\n    }\n    function addOnPreRun(cb) {\n      __ATPRERUN__.unshift(cb);\n    }\n    function addOnPostRun(cb) {\n      __ATPOSTRUN__.unshift(cb);\n    }\n    assert(Math.imul, \"This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\n    assert(Math.fround, \"This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\n    assert(Math.clz32, \"This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\n    assert(Math.trunc, \"This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\n    var Math_abs = Math.abs;\n    var Math_ceil = Math.ceil;\n    var Math_floor = Math.floor;\n    var Math_min = Math.min;\n    var runDependencies = 0;\n    var runDependencyWatcher = null;\n    var dependenciesFulfilled = null;\n    var runDependencyTracking = {};\n    function getUniqueRunDependency(id) {\n      var orig = id;\n      while (1) {\n        if (!runDependencyTracking[id])\n          return id;\n        id = orig + Math.random();\n      }\n    }\n    function addRunDependency(id) {\n      runDependencies++;\n      if (Module[\"monitorRunDependencies\"]) {\n        Module[\"monitorRunDependencies\"](runDependencies);\n      }\n      if (id) {\n        assert(!runDependencyTracking[id]);\n        runDependencyTracking[id] = 1;\n        if (runDependencyWatcher === null && typeof setInterval !== \"undefined\") {\n          runDependencyWatcher = setInterval(function() {\n            if (ABORT) {\n              clearInterval(runDependencyWatcher);\n              runDependencyWatcher = null;\n              return;\n            }\n            var shown = false;\n            for (var dep in runDependencyTracking) {\n              if (!shown) {\n                shown = true;\n                err(\"still waiting on run dependencies:\");\n              }\n              err(\"dependency: \" + dep);\n            }\n            if (shown) {\n              err(\"(end of list)\");\n            }\n          }, 1e4);\n        }\n      } else {\n        err(\"warning: run dependency added without ID\");\n      }\n    }\n    function removeRunDependency(id) {\n      runDependencies--;\n      if (Module[\"monitorRunDependencies\"]) {\n        Module[\"monitorRunDependencies\"](runDependencies);\n      }\n      if (id) {\n        assert(runDependencyTracking[id]);\n        delete runDependencyTracking[id];\n      } else {\n        err(\"warning: run dependency removed without ID\");\n      }\n      if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n        }\n        if (dependenciesFulfilled) {\n          var callback2 = dependenciesFulfilled;\n          dependenciesFulfilled = null;\n          callback2();\n        }\n      }\n    }\n    Module[\"preloadedImages\"] = {};\n    Module[\"preloadedAudios\"] = {};\n    function abort(what) {\n      if (Module[\"onAbort\"]) {\n        Module[\"onAbort\"](what);\n      }\n      what += \"\";\n      out(what);\n      err(what);\n      ABORT = true;\n      var output = \"abort(\" + what + \") at \" + stackTrace();\n      what = output;\n      throw new WebAssembly.RuntimeError(what);\n    }\n    var dataURIPrefix = \"data:application/octet-stream;base64,\";\n    function isDataURI(filename) {\n      return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0;\n    }\n    var wasmBinaryFile = \"libfaust-wasm.wasm\";\n    if (!isDataURI(wasmBinaryFile)) {\n      wasmBinaryFile = locateFile(wasmBinaryFile);\n    }\n    function getBinary() {\n      try {\n        if (wasmBinary) {\n          return new Uint8Array(wasmBinary);\n        }\n        if (readBinary) {\n          return readBinary(wasmBinaryFile);\n        } else {\n          throw \"both async and sync fetching of the wasm failed\";\n        }\n      } catch (err2) {\n        abort(err2);\n      }\n    }\n    function getBinaryPromise() {\n      if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === \"function\") {\n        return fetch(wasmBinaryFile, { credentials: \"same-origin\" }).then(function(response) {\n          if (!response[\"ok\"]) {\n            throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n          }\n          return response[\"arrayBuffer\"]();\n        }).catch(function() {\n          return getBinary();\n        });\n      }\n      return new Promise(function(resolve, reject) {\n        resolve(getBinary());\n      });\n    }\n    function createWasm() {\n      var info = { env: asmLibraryArg, wasi_snapshot_preview1: asmLibraryArg };\n      function receiveInstance(instance, module2) {\n        var exports22 = instance.exports;\n        Module[\"asm\"] = exports22;\n        removeRunDependency(\"wasm-instantiate\");\n      }\n      addRunDependency(\"wasm-instantiate\");\n      var trueModule = Module;\n      function receiveInstantiatedSource(output) {\n        assert(Module === trueModule, \"the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?\");\n        trueModule = null;\n        receiveInstance(output[\"instance\"]);\n      }\n      function instantiateArrayBuffer(receiver) {\n        return getBinaryPromise().then(function(binary) {\n          return WebAssembly.instantiate(binary, info);\n        }).then(receiver, function(reason) {\n          err(\"failed to asynchronously prepare wasm: \" + reason);\n          abort(reason);\n        });\n      }\n      function instantiateAsync() {\n        if (!wasmBinary && typeof WebAssembly.instantiateStreaming === \"function\" && !isDataURI(wasmBinaryFile) && typeof fetch === \"function\") {\n          fetch(wasmBinaryFile, { credentials: \"same-origin\" }).then(function(response) {\n            var result = WebAssembly.instantiateStreaming(response, info);\n            return result.then(receiveInstantiatedSource, function(reason) {\n              err(\"wasm streaming compile failed: \" + reason);\n              err(\"falling back to ArrayBuffer instantiation\");\n              instantiateArrayBuffer(receiveInstantiatedSource);\n            });\n          });\n        } else {\n          return instantiateArrayBuffer(receiveInstantiatedSource);\n        }\n      }\n      if (Module[\"instantiateWasm\"]) {\n        try {\n          var exports2 = Module[\"instantiateWasm\"](info, receiveInstance);\n          return exports2;\n        } catch (e) {\n          err(\"Module.instantiateWasm callback failed with error: \" + e);\n          return false;\n        }\n      }\n      instantiateAsync();\n      return {};\n    }\n    var tempDouble;\n    var tempI64;\n    var ASM_CONSTS = {\n      299792: function($0) {\n        var dsp_code = \"\";\n        try {\n          var xmlhttp = new XMLHttpRequest();\n          xmlhttp.open(\"GET\", Module.UTF8ToString($0), false);\n          xmlhttp.send();\n          if (xmlhttp.status == 200) {\n            dsp_code = xmlhttp.responseText;\n          }\n        } catch (e) {\n          console.log(e);\n        }\n        return allocate(intArrayFromString(dsp_code), \"i8\", ALLOC_STACK);\n      },\n      420260: function($0) {\n        faust_module.faust.wasm_instance[$0] = null;\n      },\n      420588: function($0) {\n        return faust_module._malloc($0);\n      },\n      420625: function($0) {\n        faust_module._free($0);\n      },\n      420653: function($0, $1) {\n        return faust_module.faust.wasm_instance[$0].exports.getNumInputs($1);\n      },\n      420730: function($0, $1) {\n        return faust_module.faust.wasm_instance[$0].exports.getNumOutputs($1);\n      },\n      420805: function($0, $1) {\n        return faust_module.faust.wasm_instance[$0].exports.getSampleRate($1);\n      },\n      420880: function($0, $1, $2) {\n        faust_module.faust.wasm_instance[$0].exports.init($1, $2);\n      },\n      420947: function($0, $1, $2) {\n        faust_module.faust.wasm_instance[$0].exports.instanceInit($1, $2);\n      },\n      421018: function($0, $1, $2) {\n        faust_module.faust.wasm_instance[$0].exports.instanceConstants($1, $2);\n      },\n      421094: function($0, $1) {\n        faust_module.faust.wasm_instance[$0].exports.instanceResetUserInterface($1);\n      },\n      421175: function($0, $1) {\n        faust_module.faust.wasm_instance[$0].exports.instanceClear($1);\n      },\n      421243: function($0, $1, $2, $3, $4) {\n        faust_module.faust.wasm_instance[$0].exports.compute($1, $2, $3, $4);\n      }\n    };\n    function _emscripten_asm_const_iii(code, sigPtr, argbuf) {\n      var args = readAsmConstArgs(sigPtr, argbuf);\n      return ASM_CONSTS[code].apply(null, args);\n    }\n    function connectMemory() {\n      faust_module.faust = faust_module.faust || {};\n      faust_module.faust.memory = faust_module.faust.memory || wasmMemory;\n    }\n    __ATINIT__.push({\n      func: function() {\n        ___wasm_call_ctors();\n      }\n    });\n    function demangle(func) {\n      warnOnce(\"warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling\");\n      return func;\n    }\n    function demangleAll(text) {\n      var regex = /\\b_Z[\\w\\d_]+/g;\n      return text.replace(regex, function(x) {\n        var y = demangle(x);\n        return x === y ? x : y + \" [\" + x + \"]\";\n      });\n    }\n    function jsStackTrace() {\n      var err2 = new Error();\n      if (!err2.stack) {\n        try {\n          throw new Error();\n        } catch (e) {\n          err2 = e;\n        }\n        if (!err2.stack) {\n          return \"(no stack trace available)\";\n        }\n      }\n      return err2.stack.toString();\n    }\n    function stackTrace() {\n      var js = jsStackTrace();\n      if (Module[\"extraStackTrace\"])\n        js += \"\\n\" + Module[\"extraStackTrace\"]();\n      return demangleAll(js);\n    }\n    function ___cxa_allocate_exception(size) {\n      return _malloc(size);\n    }\n    function __ZSt18uncaught_exceptionv() {\n      return __ZSt18uncaught_exceptionv.uncaught_exceptions > 0;\n    }\n    function ___cxa_throw(ptr, type, destructor) {\n      if (!(\"uncaught_exception\" in __ZSt18uncaught_exceptionv)) {\n        __ZSt18uncaught_exceptionv.uncaught_exceptions = 1;\n      } else {\n        __ZSt18uncaught_exceptionv.uncaught_exceptions++;\n      }\n      throw ptr + \" - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch.\";\n    }\n    function ___handle_stack_overflow() {\n      abort(\"stack overflow\");\n    }\n    function ___setErrNo(value) {\n      if (Module[\"___errno_location\"])\n        HEAP32[Module[\"___errno_location\"]() >> 2] = value;\n      else\n        err(\"failed to set errno from JS\");\n      return value;\n    }\n    function ___map_file(pathname, size) {\n      ___setErrNo(63);\n      return -1;\n    }\n    var PATH = {\n      splitPath: function(filename) {\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n        return splitPathRe.exec(filename).slice(1);\n      },\n      normalizeArray: function(parts, allowAboveRoot) {\n        var up = 0;\n        for (var i = parts.length - 1; i >= 0; i--) {\n          var last = parts[i];\n          if (last === \".\") {\n            parts.splice(i, 1);\n          } else if (last === \"..\") {\n            parts.splice(i, 1);\n            up++;\n          } else if (up) {\n            parts.splice(i, 1);\n            up--;\n          }\n        }\n        if (allowAboveRoot) {\n          for (; up; up--) {\n            parts.unshift(\"..\");\n          }\n        }\n        return parts;\n      },\n      normalize: function(path) {\n        var isAbsolute = path.charAt(0) === \"/\", trailingSlash = path.substr(-1) === \"/\";\n        path = PATH.normalizeArray(path.split(\"/\").filter(function(p) {\n          return !!p;\n        }), !isAbsolute).join(\"/\");\n        if (!path && !isAbsolute) {\n          path = \".\";\n        }\n        if (path && trailingSlash) {\n          path += \"/\";\n        }\n        return (isAbsolute ? \"/\" : \"\") + path;\n      },\n      dirname: function(path) {\n        var result = PATH.splitPath(path), root = result[0], dir = result[1];\n        if (!root && !dir) {\n          return \".\";\n        }\n        if (dir) {\n          dir = dir.substr(0, dir.length - 1);\n        }\n        return root + dir;\n      },\n      basename: function(path) {\n        if (path === \"/\")\n          return \"/\";\n        var lastSlash = path.lastIndexOf(\"/\");\n        if (lastSlash === -1)\n          return path;\n        return path.substr(lastSlash + 1);\n      },\n      extname: function(path) {\n        return PATH.splitPath(path)[3];\n      },\n      join: function() {\n        var paths = Array.prototype.slice.call(arguments, 0);\n        return PATH.normalize(paths.join(\"/\"));\n      },\n      join2: function(l, r) {\n        return PATH.normalize(l + \"/\" + r);\n      }\n    };\n    var PATH_FS = {\n      resolve: function() {\n        var resolvedPath = \"\", resolvedAbsolute = false;\n        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n          var path = i >= 0 ? arguments[i] : FS.cwd();\n          if (typeof path !== \"string\") {\n            throw new TypeError(\"Arguments to path.resolve must be strings\");\n          } else if (!path) {\n            return \"\";\n          }\n          resolvedPath = path + \"/\" + resolvedPath;\n          resolvedAbsolute = path.charAt(0) === \"/\";\n        }\n        resolvedPath = PATH.normalizeArray(resolvedPath.split(\"/\").filter(function(p) {\n          return !!p;\n        }), !resolvedAbsolute).join(\"/\");\n        return (resolvedAbsolute ? \"/\" : \"\") + resolvedPath || \".\";\n      },\n      relative: function(from, to) {\n        from = PATH_FS.resolve(from).substr(1);\n        to = PATH_FS.resolve(to).substr(1);\n        function trim(arr) {\n          var start = 0;\n          for (; start < arr.length; start++) {\n            if (arr[start] !== \"\")\n              break;\n          }\n          var end = arr.length - 1;\n          for (; end >= 0; end--) {\n            if (arr[end] !== \"\")\n              break;\n          }\n          if (start > end)\n            return [];\n          return arr.slice(start, end - start + 1);\n        }\n        var fromParts = trim(from.split(\"/\"));\n        var toParts = trim(to.split(\"/\"));\n        var length = Math.min(fromParts.length, toParts.length);\n        var samePartsLength = length;\n        for (var i = 0; i < length; i++) {\n          if (fromParts[i] !== toParts[i]) {\n            samePartsLength = i;\n            break;\n          }\n        }\n        var outputParts = [];\n        for (var i = samePartsLength; i < fromParts.length; i++) {\n          outputParts.push(\"..\");\n        }\n        outputParts = outputParts.concat(toParts.slice(samePartsLength));\n        return outputParts.join(\"/\");\n      }\n    };\n    var TTY = {\n      ttys: [],\n      init: function() {\n      },\n      shutdown: function() {\n      },\n      register: function(dev, ops) {\n        TTY.ttys[dev] = { input: [], output: [], ops };\n        FS.registerDevice(dev, TTY.stream_ops);\n      },\n      stream_ops: {\n        open: function(stream) {\n          var tty = TTY.ttys[stream.node.rdev];\n          if (!tty) {\n            throw new FS.ErrnoError(43);\n          }\n          stream.tty = tty;\n          stream.seekable = false;\n        },\n        close: function(stream) {\n          stream.tty.ops.flush(stream.tty);\n        },\n        flush: function(stream) {\n          stream.tty.ops.flush(stream.tty);\n        },\n        read: function(stream, buffer2, offset, length, pos) {\n          if (!stream.tty || !stream.tty.ops.get_char) {\n            throw new FS.ErrnoError(60);\n          }\n          var bytesRead = 0;\n          for (var i = 0; i < length; i++) {\n            var result;\n            try {\n              result = stream.tty.ops.get_char(stream.tty);\n            } catch (e) {\n              throw new FS.ErrnoError(29);\n            }\n            if (result === void 0 && bytesRead === 0) {\n              throw new FS.ErrnoError(6);\n            }\n            if (result === null || result === void 0)\n              break;\n            bytesRead++;\n            buffer2[offset + i] = result;\n          }\n          if (bytesRead) {\n            stream.node.timestamp = Date.now();\n          }\n          return bytesRead;\n        },\n        write: function(stream, buffer2, offset, length, pos) {\n          if (!stream.tty || !stream.tty.ops.put_char) {\n            throw new FS.ErrnoError(60);\n          }\n          try {\n            for (var i = 0; i < length; i++) {\n              stream.tty.ops.put_char(stream.tty, buffer2[offset + i]);\n            }\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n          if (length) {\n            stream.node.timestamp = Date.now();\n          }\n          return i;\n        }\n      },\n      default_tty_ops: {\n        get_char: function(tty) {\n          if (!tty.input.length) {\n            var result = null;\n            if (ENVIRONMENT_IS_NODE) {\n              var BUFSIZE = 256;\n              var buf = Buffer.alloc ? Buffer.alloc(BUFSIZE) : new Buffer(BUFSIZE);\n              var bytesRead = 0;\n              try {\n                bytesRead = nodeFS.readSync(process.stdin.fd, buf, 0, BUFSIZE, null);\n              } catch (e) {\n                if (e.toString().indexOf(\"EOF\") != -1)\n                  bytesRead = 0;\n                else\n                  throw e;\n              }\n              if (bytesRead > 0) {\n                result = buf.slice(0, bytesRead).toString(\"utf-8\");\n              } else {\n                result = null;\n              }\n            } else if (typeof window != \"undefined\" && typeof window.prompt == \"function\") {\n              result = window.prompt(\"Input: \");\n              if (result !== null) {\n                result += \"\\n\";\n              }\n            } else if (typeof readline == \"function\") {\n              result = readline();\n              if (result !== null) {\n                result += \"\\n\";\n              }\n            }\n            if (!result) {\n              return null;\n            }\n            tty.input = intArrayFromString(result, true);\n          }\n          return tty.input.shift();\n        },\n        put_char: function(tty, val) {\n          if (val === null || val === 10) {\n            out(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          } else {\n            if (val != 0)\n              tty.output.push(val);\n          }\n        },\n        flush: function(tty) {\n          if (tty.output && tty.output.length > 0) {\n            out(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          }\n        }\n      },\n      default_tty1_ops: {\n        put_char: function(tty, val) {\n          if (val === null || val === 10) {\n            err(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          } else {\n            if (val != 0)\n              tty.output.push(val);\n          }\n        },\n        flush: function(tty) {\n          if (tty.output && tty.output.length > 0) {\n            err(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          }\n        }\n      }\n    };\n    var MEMFS = {\n      ops_table: null,\n      mount: function(mount) {\n        return MEMFS.createNode(null, \"/\", 16384 | 511, 0);\n      },\n      createNode: function(parent, name, mode, dev) {\n        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n          throw new FS.ErrnoError(63);\n        }\n        if (!MEMFS.ops_table) {\n          MEMFS.ops_table = {\n            dir: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr,\n                lookup: MEMFS.node_ops.lookup,\n                mknod: MEMFS.node_ops.mknod,\n                rename: MEMFS.node_ops.rename,\n                unlink: MEMFS.node_ops.unlink,\n                rmdir: MEMFS.node_ops.rmdir,\n                readdir: MEMFS.node_ops.readdir,\n                symlink: MEMFS.node_ops.symlink\n              },\n              stream: { llseek: MEMFS.stream_ops.llseek }\n            },\n            file: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr\n              },\n              stream: {\n                llseek: MEMFS.stream_ops.llseek,\n                read: MEMFS.stream_ops.read,\n                write: MEMFS.stream_ops.write,\n                allocate: MEMFS.stream_ops.allocate,\n                mmap: MEMFS.stream_ops.mmap,\n                msync: MEMFS.stream_ops.msync\n              }\n            },\n            link: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr,\n                readlink: MEMFS.node_ops.readlink\n              },\n              stream: {}\n            },\n            chrdev: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr\n              },\n              stream: FS.chrdev_stream_ops\n            }\n          };\n        }\n        var node = FS.createNode(parent, name, mode, dev);\n        if (FS.isDir(node.mode)) {\n          node.node_ops = MEMFS.ops_table.dir.node;\n          node.stream_ops = MEMFS.ops_table.dir.stream;\n          node.contents = {};\n        } else if (FS.isFile(node.mode)) {\n          node.node_ops = MEMFS.ops_table.file.node;\n          node.stream_ops = MEMFS.ops_table.file.stream;\n          node.usedBytes = 0;\n          node.contents = null;\n        } else if (FS.isLink(node.mode)) {\n          node.node_ops = MEMFS.ops_table.link.node;\n          node.stream_ops = MEMFS.ops_table.link.stream;\n        } else if (FS.isChrdev(node.mode)) {\n          node.node_ops = MEMFS.ops_table.chrdev.node;\n          node.stream_ops = MEMFS.ops_table.chrdev.stream;\n        }\n        node.timestamp = Date.now();\n        if (parent) {\n          parent.contents[name] = node;\n        }\n        return node;\n      },\n      getFileDataAsRegularArray: function(node) {\n        if (node.contents && node.contents.subarray) {\n          var arr = [];\n          for (var i = 0; i < node.usedBytes; ++i)\n            arr.push(node.contents[i]);\n          return arr;\n        }\n        return node.contents;\n      },\n      getFileDataAsTypedArray: function(node) {\n        if (!node.contents)\n          return new Uint8Array(0);\n        if (node.contents.subarray)\n          return node.contents.subarray(0, node.usedBytes);\n        return new Uint8Array(node.contents);\n      },\n      expandFileStorage: function(node, newCapacity) {\n        var prevCapacity = node.contents ? node.contents.length : 0;\n        if (prevCapacity >= newCapacity)\n          return;\n        var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n        newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) | 0);\n        if (prevCapacity != 0)\n          newCapacity = Math.max(newCapacity, 256);\n        var oldContents = node.contents;\n        node.contents = new Uint8Array(newCapacity);\n        if (node.usedBytes > 0)\n          node.contents.set(oldContents.subarray(0, node.usedBytes), 0);\n        return;\n      },\n      resizeFileStorage: function(node, newSize) {\n        if (node.usedBytes == newSize)\n          return;\n        if (newSize == 0) {\n          node.contents = null;\n          node.usedBytes = 0;\n          return;\n        }\n        if (!node.contents || node.contents.subarray) {\n          var oldContents = node.contents;\n          node.contents = new Uint8Array(newSize);\n          if (oldContents) {\n            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));\n          }\n          node.usedBytes = newSize;\n          return;\n        }\n        if (!node.contents)\n          node.contents = [];\n        if (node.contents.length > newSize)\n          node.contents.length = newSize;\n        else\n          while (node.contents.length < newSize)\n            node.contents.push(0);\n        node.usedBytes = newSize;\n      },\n      node_ops: {\n        getattr: function(node) {\n          var attr = {};\n          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n          attr.ino = node.id;\n          attr.mode = node.mode;\n          attr.nlink = 1;\n          attr.uid = 0;\n          attr.gid = 0;\n          attr.rdev = node.rdev;\n          if (FS.isDir(node.mode)) {\n            attr.size = 4096;\n          } else if (FS.isFile(node.mode)) {\n            attr.size = node.usedBytes;\n          } else if (FS.isLink(node.mode)) {\n            attr.size = node.link.length;\n          } else {\n            attr.size = 0;\n          }\n          attr.atime = new Date(node.timestamp);\n          attr.mtime = new Date(node.timestamp);\n          attr.ctime = new Date(node.timestamp);\n          attr.blksize = 4096;\n          attr.blocks = Math.ceil(attr.size / attr.blksize);\n          return attr;\n        },\n        setattr: function(node, attr) {\n          if (attr.mode !== void 0) {\n            node.mode = attr.mode;\n          }\n          if (attr.timestamp !== void 0) {\n            node.timestamp = attr.timestamp;\n          }\n          if (attr.size !== void 0) {\n            MEMFS.resizeFileStorage(node, attr.size);\n          }\n        },\n        lookup: function(parent, name) {\n          throw FS.genericErrors[44];\n        },\n        mknod: function(parent, name, mode, dev) {\n          return MEMFS.createNode(parent, name, mode, dev);\n        },\n        rename: function(old_node, new_dir, new_name) {\n          if (FS.isDir(old_node.mode)) {\n            var new_node;\n            try {\n              new_node = FS.lookupNode(new_dir, new_name);\n            } catch (e) {\n            }\n            if (new_node) {\n              for (var i in new_node.contents) {\n                throw new FS.ErrnoError(55);\n              }\n            }\n          }\n          delete old_node.parent.contents[old_node.name];\n          old_node.name = new_name;\n          new_dir.contents[new_name] = old_node;\n          old_node.parent = new_dir;\n        },\n        unlink: function(parent, name) {\n          delete parent.contents[name];\n        },\n        rmdir: function(parent, name) {\n          var node = FS.lookupNode(parent, name);\n          for (var i in node.contents) {\n            throw new FS.ErrnoError(55);\n          }\n          delete parent.contents[name];\n        },\n        readdir: function(node) {\n          var entries = [\".\", \"..\"];\n          for (var key2 in node.contents) {\n            if (!node.contents.hasOwnProperty(key2)) {\n              continue;\n            }\n            entries.push(key2);\n          }\n          return entries;\n        },\n        symlink: function(parent, newname, oldpath) {\n          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);\n          node.link = oldpath;\n          return node;\n        },\n        readlink: function(node) {\n          if (!FS.isLink(node.mode)) {\n            throw new FS.ErrnoError(28);\n          }\n          return node.link;\n        }\n      },\n      stream_ops: {\n        read: function(stream, buffer2, offset, length, position) {\n          var contents = stream.node.contents;\n          if (position >= stream.node.usedBytes)\n            return 0;\n          var size = Math.min(stream.node.usedBytes - position, length);\n          assert(size >= 0);\n          if (size > 8 && contents.subarray) {\n            buffer2.set(contents.subarray(position, position + size), offset);\n          } else {\n            for (var i = 0; i < size; i++)\n              buffer2[offset + i] = contents[position + i];\n          }\n          return size;\n        },\n        write: function(stream, buffer2, offset, length, position, canOwn) {\n          assert(!(buffer2 instanceof ArrayBuffer));\n          if (buffer2.buffer === HEAP8.buffer) {\n            if (canOwn) {\n              warnOnce(\"file packager has copied file data into memory, but in memory growth we are forced to copy it again (see --no-heap-copy)\");\n            }\n            canOwn = false;\n          }\n          if (!length)\n            return 0;\n          var node = stream.node;\n          node.timestamp = Date.now();\n          if (buffer2.subarray && (!node.contents || node.contents.subarray)) {\n            if (canOwn) {\n              assert(position === 0, \"canOwn must imply no weird position inside the file\");\n              node.contents = buffer2.subarray(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (node.usedBytes === 0 && position === 0) {\n              node.contents = buffer2.slice(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (position + length <= node.usedBytes) {\n              node.contents.set(buffer2.subarray(offset, offset + length), position);\n              return length;\n            }\n          }\n          MEMFS.expandFileStorage(node, position + length);\n          if (node.contents.subarray && buffer2.subarray)\n            node.contents.set(buffer2.subarray(offset, offset + length), position);\n          else {\n            for (var i = 0; i < length; i++) {\n              node.contents[position + i] = buffer2[offset + i];\n            }\n          }\n          node.usedBytes = Math.max(node.usedBytes, position + length);\n          return length;\n        },\n        llseek: function(stream, offset, whence) {\n          var position = offset;\n          if (whence === 1) {\n            position += stream.position;\n          } else if (whence === 2) {\n            if (FS.isFile(stream.node.mode)) {\n              position += stream.node.usedBytes;\n            }\n          }\n          if (position < 0) {\n            throw new FS.ErrnoError(28);\n          }\n          return position;\n        },\n        allocate: function(stream, offset, length) {\n          MEMFS.expandFileStorage(stream.node, offset + length);\n          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\n        },\n        mmap: function(stream, buffer2, offset, length, position, prot, flags) {\n          assert(!(buffer2 instanceof ArrayBuffer));\n          if (!FS.isFile(stream.node.mode)) {\n            throw new FS.ErrnoError(43);\n          }\n          var ptr;\n          var allocated;\n          var contents = stream.node.contents;\n          if (!(flags & 2) && contents.buffer === buffer2.buffer) {\n            allocated = false;\n            ptr = contents.byteOffset;\n          } else {\n            if (position > 0 || position + length < contents.length) {\n              if (contents.subarray) {\n                contents = contents.subarray(position, position + length);\n              } else {\n                contents = Array.prototype.slice.call(contents, position, position + length);\n              }\n            }\n            allocated = true;\n            var fromHeap = buffer2.buffer == HEAP8.buffer;\n            ptr = _malloc(length);\n            if (!ptr) {\n              throw new FS.ErrnoError(48);\n            }\n            (fromHeap ? HEAP8 : buffer2).set(contents, ptr);\n          }\n          return { ptr, allocated };\n        },\n        msync: function(stream, buffer2, offset, length, mmapFlags) {\n          if (!FS.isFile(stream.node.mode)) {\n            throw new FS.ErrnoError(43);\n          }\n          if (mmapFlags & 2) {\n            return 0;\n          }\n          MEMFS.stream_ops.write(stream, buffer2, 0, length, offset, false);\n          return 0;\n        }\n      }\n    };\n    var ERRNO_MESSAGES = {\n      0: \"Success\",\n      1: \"Arg list too long\",\n      2: \"Permission denied\",\n      3: \"Address already in use\",\n      4: \"Address not available\",\n      5: \"Address family not supported by protocol family\",\n      6: \"No more processes\",\n      7: \"Socket already connected\",\n      8: \"Bad file number\",\n      9: \"Trying to read unreadable message\",\n      10: \"Mount device busy\",\n      11: \"Operation canceled\",\n      12: \"No children\",\n      13: \"Connection aborted\",\n      14: \"Connection refused\",\n      15: \"Connection reset by peer\",\n      16: \"File locking deadlock error\",\n      17: \"Destination address required\",\n      18: \"Math arg out of domain of func\",\n      19: \"Quota exceeded\",\n      20: \"File exists\",\n      21: \"Bad address\",\n      22: \"File too large\",\n      23: \"Host is unreachable\",\n      24: \"Identifier removed\",\n      25: \"Illegal byte sequence\",\n      26: \"Connection already in progress\",\n      27: \"Interrupted system call\",\n      28: \"Invalid argument\",\n      29: \"I/O error\",\n      30: \"Socket is already connected\",\n      31: \"Is a directory\",\n      32: \"Too many symbolic links\",\n      33: \"Too many open files\",\n      34: \"Too many links\",\n      35: \"Message too long\",\n      36: \"Multihop attempted\",\n      37: \"File or path name too long\",\n      38: \"Network interface is not configured\",\n      39: \"Connection reset by network\",\n      40: \"Network is unreachable\",\n      41: \"Too many open files in system\",\n      42: \"No buffer space available\",\n      43: \"No such device\",\n      44: \"No such file or directory\",\n      45: \"Exec format error\",\n      46: \"No record locks available\",\n      47: \"The link has been severed\",\n      48: \"Not enough core\",\n      49: \"No message of desired type\",\n      50: \"Protocol not available\",\n      51: \"No space left on device\",\n      52: \"Function not implemented\",\n      53: \"Socket is not connected\",\n      54: \"Not a directory\",\n      55: \"Directory not empty\",\n      56: \"State not recoverable\",\n      57: \"Socket operation on non-socket\",\n      59: \"Not a typewriter\",\n      60: \"No such device or address\",\n      61: \"Value too large for defined data type\",\n      62: \"Previous owner died\",\n      63: \"Not super-user\",\n      64: \"Broken pipe\",\n      65: \"Protocol error\",\n      66: \"Unknown protocol\",\n      67: \"Protocol wrong type for socket\",\n      68: \"Math result not representable\",\n      69: \"Read only file system\",\n      70: \"Illegal seek\",\n      71: \"No such process\",\n      72: \"Stale file handle\",\n      73: \"Connection timed out\",\n      74: \"Text file busy\",\n      75: \"Cross-device link\",\n      100: \"Device not a stream\",\n      101: \"Bad font file fmt\",\n      102: \"Invalid slot\",\n      103: \"Invalid request code\",\n      104: \"No anode\",\n      105: \"Block device required\",\n      106: \"Channel number out of range\",\n      107: \"Level 3 halted\",\n      108: \"Level 3 reset\",\n      109: \"Link number out of range\",\n      110: \"Protocol driver not attached\",\n      111: \"No CSI structure available\",\n      112: \"Level 2 halted\",\n      113: \"Invalid exchange\",\n      114: \"Invalid request descriptor\",\n      115: \"Exchange full\",\n      116: \"No data (for no delay io)\",\n      117: \"Timer expired\",\n      118: \"Out of streams resources\",\n      119: \"Machine is not on the network\",\n      120: \"Package not installed\",\n      121: \"The object is remote\",\n      122: \"Advertise error\",\n      123: \"Srmount error\",\n      124: \"Communication error on send\",\n      125: \"Cross mount point (not really error)\",\n      126: \"Given log. name not unique\",\n      127: \"f.d. invalid for this operation\",\n      128: \"Remote address changed\",\n      129: \"Can   access a needed shared lib\",\n      130: \"Accessing a corrupted shared lib\",\n      131: \".lib section in a.out corrupted\",\n      132: \"Attempting to link in too many libs\",\n      133: \"Attempting to exec a shared library\",\n      135: \"Streams pipe error\",\n      136: \"Too many users\",\n      137: \"Socket type not supported\",\n      138: \"Not supported\",\n      139: \"Protocol family not supported\",\n      140: \"Can't send after socket shutdown\",\n      141: \"Too many references\",\n      142: \"Host is down\",\n      148: \"No medium (in tape drive)\",\n      156: \"Level 2 not synchronized\"\n    };\n    var ERRNO_CODES = {\n      EPERM: 63,\n      ENOENT: 44,\n      ESRCH: 71,\n      EINTR: 27,\n      EIO: 29,\n      ENXIO: 60,\n      E2BIG: 1,\n      ENOEXEC: 45,\n      EBADF: 8,\n      ECHILD: 12,\n      EAGAIN: 6,\n      EWOULDBLOCK: 6,\n      ENOMEM: 48,\n      EACCES: 2,\n      EFAULT: 21,\n      ENOTBLK: 105,\n      EBUSY: 10,\n      EEXIST: 20,\n      EXDEV: 75,\n      ENODEV: 43,\n      ENOTDIR: 54,\n      EISDIR: 31,\n      EINVAL: 28,\n      ENFILE: 41,\n      EMFILE: 33,\n      ENOTTY: 59,\n      ETXTBSY: 74,\n      EFBIG: 22,\n      ENOSPC: 51,\n      ESPIPE: 70,\n      EROFS: 69,\n      EMLINK: 34,\n      EPIPE: 64,\n      EDOM: 18,\n      ERANGE: 68,\n      ENOMSG: 49,\n      EIDRM: 24,\n      ECHRNG: 106,\n      EL2NSYNC: 156,\n      EL3HLT: 107,\n      EL3RST: 108,\n      ELNRNG: 109,\n      EUNATCH: 110,\n      ENOCSI: 111,\n      EL2HLT: 112,\n      EDEADLK: 16,\n      ENOLCK: 46,\n      EBADE: 113,\n      EBADR: 114,\n      EXFULL: 115,\n      ENOANO: 104,\n      EBADRQC: 103,\n      EBADSLT: 102,\n      EDEADLOCK: 16,\n      EBFONT: 101,\n      ENOSTR: 100,\n      ENODATA: 116,\n      ETIME: 117,\n      ENOSR: 118,\n      ENONET: 119,\n      ENOPKG: 120,\n      EREMOTE: 121,\n      ENOLINK: 47,\n      EADV: 122,\n      ESRMNT: 123,\n      ECOMM: 124,\n      EPROTO: 65,\n      EMULTIHOP: 36,\n      EDOTDOT: 125,\n      EBADMSG: 9,\n      ENOTUNIQ: 126,\n      EBADFD: 127,\n      EREMCHG: 128,\n      ELIBACC: 129,\n      ELIBBAD: 130,\n      ELIBSCN: 131,\n      ELIBMAX: 132,\n      ELIBEXEC: 133,\n      ENOSYS: 52,\n      ENOTEMPTY: 55,\n      ENAMETOOLONG: 37,\n      ELOOP: 32,\n      EOPNOTSUPP: 138,\n      EPFNOSUPPORT: 139,\n      ECONNRESET: 15,\n      ENOBUFS: 42,\n      EAFNOSUPPORT: 5,\n      EPROTOTYPE: 67,\n      ENOTSOCK: 57,\n      ENOPROTOOPT: 50,\n      ESHUTDOWN: 140,\n      ECONNREFUSED: 14,\n      EADDRINUSE: 3,\n      ECONNABORTED: 13,\n      ENETUNREACH: 40,\n      ENETDOWN: 38,\n      ETIMEDOUT: 73,\n      EHOSTDOWN: 142,\n      EHOSTUNREACH: 23,\n      EINPROGRESS: 26,\n      EALREADY: 7,\n      EDESTADDRREQ: 17,\n      EMSGSIZE: 35,\n      EPROTONOSUPPORT: 66,\n      ESOCKTNOSUPPORT: 137,\n      EADDRNOTAVAIL: 4,\n      ENETRESET: 39,\n      EISCONN: 30,\n      ENOTCONN: 53,\n      ETOOMANYREFS: 141,\n      EUSERS: 136,\n      EDQUOT: 19,\n      ESTALE: 72,\n      ENOTSUP: 138,\n      ENOMEDIUM: 148,\n      EILSEQ: 25,\n      EOVERFLOW: 61,\n      ECANCELED: 11,\n      ENOTRECOVERABLE: 56,\n      EOWNERDEAD: 62,\n      ESTRPIPE: 135\n    };\n    var FS = {\n      root: null,\n      mounts: [],\n      devices: {},\n      streams: [],\n      nextInode: 1,\n      nameTable: null,\n      currentPath: \"/\",\n      initialized: false,\n      ignorePermissions: true,\n      trackingDelegate: {},\n      tracking: { openFlags: { READ: 1, WRITE: 2 } },\n      ErrnoError: null,\n      genericErrors: {},\n      filesystems: null,\n      syncFSRequests: 0,\n      handleFSError: function(e) {\n        if (!(e instanceof FS.ErrnoError))\n          throw e + \" : \" + stackTrace();\n        return ___setErrNo(e.errno);\n      },\n      lookupPath: function(path, opts) {\n        path = PATH_FS.resolve(FS.cwd(), path);\n        opts = opts || {};\n        if (!path)\n          return { path: \"\", node: null };\n        var defaults = { follow_mount: true, recurse_count: 0 };\n        for (var key2 in defaults) {\n          if (opts[key2] === void 0) {\n            opts[key2] = defaults[key2];\n          }\n        }\n        if (opts.recurse_count > 8) {\n          throw new FS.ErrnoError(32);\n        }\n        var parts = PATH.normalizeArray(path.split(\"/\").filter(function(p) {\n          return !!p;\n        }), false);\n        var current = FS.root;\n        var current_path = \"/\";\n        for (var i = 0; i < parts.length; i++) {\n          var islast = i === parts.length - 1;\n          if (islast && opts.parent) {\n            break;\n          }\n          current = FS.lookupNode(current, parts[i]);\n          current_path = PATH.join2(current_path, parts[i]);\n          if (FS.isMountpoint(current)) {\n            if (!islast || islast && opts.follow_mount) {\n              current = current.mounted.root;\n            }\n          }\n          if (!islast || opts.follow) {\n            var count = 0;\n            while (FS.isLink(current.mode)) {\n              var link = FS.readlink(current_path);\n              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\n              var lookup = FS.lookupPath(current_path, {\n                recurse_count: opts.recurse_count\n              });\n              current = lookup.node;\n              if (count++ > 40) {\n                throw new FS.ErrnoError(32);\n              }\n            }\n          }\n        }\n        return { path: current_path, node: current };\n      },\n      getPath: function(node) {\n        var path;\n        while (true) {\n          if (FS.isRoot(node)) {\n            var mount = node.mount.mountpoint;\n            if (!path)\n              return mount;\n            return mount[mount.length - 1] !== \"/\" ? mount + \"/\" + path : mount + path;\n          }\n          path = path ? node.name + \"/\" + path : node.name;\n          node = node.parent;\n        }\n      },\n      hashName: function(parentid, name) {\n        var hash = 0;\n        for (var i = 0; i < name.length; i++) {\n          hash = (hash << 5) - hash + name.charCodeAt(i) | 0;\n        }\n        return (parentid + hash >>> 0) % FS.nameTable.length;\n      },\n      hashAddNode: function(node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        node.name_next = FS.nameTable[hash];\n        FS.nameTable[hash] = node;\n      },\n      hashRemoveNode: function(node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        if (FS.nameTable[hash] === node) {\n          FS.nameTable[hash] = node.name_next;\n        } else {\n          var current = FS.nameTable[hash];\n          while (current) {\n            if (current.name_next === node) {\n              current.name_next = node.name_next;\n              break;\n            }\n            current = current.name_next;\n          }\n        }\n      },\n      lookupNode: function(parent, name) {\n        var errCode = FS.mayLookup(parent);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode, parent);\n        }\n        var hash = FS.hashName(parent.id, name);\n        for (var node = FS.nameTable[hash]; node; node = node.name_next) {\n          var nodeName = node.name;\n          if (node.parent.id === parent.id && nodeName === name) {\n            return node;\n          }\n        }\n        return FS.lookup(parent, name);\n      },\n      createNode: function(parent, name, mode, rdev) {\n        var node = new FS.FSNode(parent, name, mode, rdev);\n        FS.hashAddNode(node);\n        return node;\n      },\n      destroyNode: function(node) {\n        FS.hashRemoveNode(node);\n      },\n      isRoot: function(node) {\n        return node === node.parent;\n      },\n      isMountpoint: function(node) {\n        return !!node.mounted;\n      },\n      isFile: function(mode) {\n        return (mode & 61440) === 32768;\n      },\n      isDir: function(mode) {\n        return (mode & 61440) === 16384;\n      },\n      isLink: function(mode) {\n        return (mode & 61440) === 40960;\n      },\n      isChrdev: function(mode) {\n        return (mode & 61440) === 8192;\n      },\n      isBlkdev: function(mode) {\n        return (mode & 61440) === 24576;\n      },\n      isFIFO: function(mode) {\n        return (mode & 61440) === 4096;\n      },\n      isSocket: function(mode) {\n        return (mode & 49152) === 49152;\n      },\n      flagModes: {\n        r: 0,\n        rs: 1052672,\n        \"r+\": 2,\n        w: 577,\n        wx: 705,\n        xw: 705,\n        \"w+\": 578,\n        \"wx+\": 706,\n        \"xw+\": 706,\n        a: 1089,\n        ax: 1217,\n        xa: 1217,\n        \"a+\": 1090,\n        \"ax+\": 1218,\n        \"xa+\": 1218\n      },\n      modeStringToFlags: function(str) {\n        var flags = FS.flagModes[str];\n        if (typeof flags === \"undefined\") {\n          throw new Error(\"Unknown file open mode: \" + str);\n        }\n        return flags;\n      },\n      flagsToPermissionString: function(flag) {\n        var perms = [\"r\", \"w\", \"rw\"][flag & 3];\n        if (flag & 512) {\n          perms += \"w\";\n        }\n        return perms;\n      },\n      nodePermissions: function(node, perms) {\n        if (FS.ignorePermissions) {\n          return 0;\n        }\n        if (perms.indexOf(\"r\") !== -1 && !(node.mode & 292)) {\n          return 2;\n        } else if (perms.indexOf(\"w\") !== -1 && !(node.mode & 146)) {\n          return 2;\n        } else if (perms.indexOf(\"x\") !== -1 && !(node.mode & 73)) {\n          return 2;\n        }\n        return 0;\n      },\n      mayLookup: function(dir) {\n        var errCode = FS.nodePermissions(dir, \"x\");\n        if (errCode)\n          return errCode;\n        if (!dir.node_ops.lookup)\n          return 2;\n        return 0;\n      },\n      mayCreate: function(dir, name) {\n        try {\n          var node = FS.lookupNode(dir, name);\n          return 20;\n        } catch (e) {\n        }\n        return FS.nodePermissions(dir, \"wx\");\n      },\n      mayDelete: function(dir, name, isdir) {\n        var node;\n        try {\n          node = FS.lookupNode(dir, name);\n        } catch (e) {\n          return e.errno;\n        }\n        var errCode = FS.nodePermissions(dir, \"wx\");\n        if (errCode) {\n          return errCode;\n        }\n        if (isdir) {\n          if (!FS.isDir(node.mode)) {\n            return 54;\n          }\n          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n            return 10;\n          }\n        } else {\n          if (FS.isDir(node.mode)) {\n            return 31;\n          }\n        }\n        return 0;\n      },\n      mayOpen: function(node, flags) {\n        if (!node) {\n          return 44;\n        }\n        if (FS.isLink(node.mode)) {\n          return 32;\n        } else if (FS.isDir(node.mode)) {\n          if (FS.flagsToPermissionString(flags) !== \"r\" || flags & 512) {\n            return 31;\n          }\n        }\n        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n      },\n      MAX_OPEN_FDS: 4096,\n      nextfd: function(fd_start, fd_end) {\n        fd_start = fd_start || 0;\n        fd_end = fd_end || FS.MAX_OPEN_FDS;\n        for (var fd = fd_start; fd <= fd_end; fd++) {\n          if (!FS.streams[fd]) {\n            return fd;\n          }\n        }\n        throw new FS.ErrnoError(33);\n      },\n      getStream: function(fd) {\n        return FS.streams[fd];\n      },\n      createStream: function(stream, fd_start, fd_end) {\n        if (!FS.FSStream) {\n          FS.FSStream = function() {\n          };\n          FS.FSStream.prototype = {\n            object: {\n              get: function() {\n                return this.node;\n              },\n              set: function(val) {\n                this.node = val;\n              }\n            },\n            isRead: {\n              get: function() {\n                return (this.flags & 2097155) !== 1;\n              }\n            },\n            isWrite: {\n              get: function() {\n                return (this.flags & 2097155) !== 0;\n              }\n            },\n            isAppend: {\n              get: function() {\n                return this.flags & 1024;\n              }\n            }\n          };\n        }\n        var newStream = new FS.FSStream();\n        for (var p in stream) {\n          newStream[p] = stream[p];\n        }\n        stream = newStream;\n        var fd = FS.nextfd(fd_start, fd_end);\n        stream.fd = fd;\n        FS.streams[fd] = stream;\n        return stream;\n      },\n      closeStream: function(fd) {\n        FS.streams[fd] = null;\n      },\n      chrdev_stream_ops: {\n        open: function(stream) {\n          var device = FS.getDevice(stream.node.rdev);\n          stream.stream_ops = device.stream_ops;\n          if (stream.stream_ops.open) {\n            stream.stream_ops.open(stream);\n          }\n        },\n        llseek: function() {\n          throw new FS.ErrnoError(70);\n        }\n      },\n      major: function(dev) {\n        return dev >> 8;\n      },\n      minor: function(dev) {\n        return dev & 255;\n      },\n      makedev: function(ma, mi) {\n        return ma << 8 | mi;\n      },\n      registerDevice: function(dev, ops) {\n        FS.devices[dev] = { stream_ops: ops };\n      },\n      getDevice: function(dev) {\n        return FS.devices[dev];\n      },\n      getMounts: function(mount) {\n        var mounts = [];\n        var check = [mount];\n        while (check.length) {\n          var m = check.pop();\n          mounts.push(m);\n          check.push.apply(check, m.mounts);\n        }\n        return mounts;\n      },\n      syncfs: function(populate, callback2) {\n        if (typeof populate === \"function\") {\n          callback2 = populate;\n          populate = false;\n        }\n        FS.syncFSRequests++;\n        if (FS.syncFSRequests > 1) {\n          err(\"warning: \" + FS.syncFSRequests + \" FS.syncfs operations in flight at once, probably just doing extra work\");\n        }\n        var mounts = FS.getMounts(FS.root.mount);\n        var completed = 0;\n        function doCallback(errCode) {\n          assert(FS.syncFSRequests > 0);\n          FS.syncFSRequests--;\n          return callback2(errCode);\n        }\n        function done(errCode) {\n          if (errCode) {\n            if (!done.errored) {\n              done.errored = true;\n              return doCallback(errCode);\n            }\n            return;\n          }\n          if (++completed >= mounts.length) {\n            doCallback(null);\n          }\n        }\n        mounts.forEach(function(mount) {\n          if (!mount.type.syncfs) {\n            return done(null);\n          }\n          mount.type.syncfs(mount, populate, done);\n        });\n      },\n      mount: function(type, opts, mountpoint) {\n        if (typeof type === \"string\") {\n          throw type;\n        }\n        var root = mountpoint === \"/\";\n        var pseudo = !mountpoint;\n        var node;\n        if (root && FS.root) {\n          throw new FS.ErrnoError(10);\n        } else if (!root && !pseudo) {\n          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\n          mountpoint = lookup.path;\n          node = lookup.node;\n          if (FS.isMountpoint(node)) {\n            throw new FS.ErrnoError(10);\n          }\n          if (!FS.isDir(node.mode)) {\n            throw new FS.ErrnoError(54);\n          }\n        }\n        var mount = {\n          type,\n          opts,\n          mountpoint,\n          mounts: []\n        };\n        var mountRoot = type.mount(mount);\n        mountRoot.mount = mount;\n        mount.root = mountRoot;\n        if (root) {\n          FS.root = mountRoot;\n        } else if (node) {\n          node.mounted = mount;\n          if (node.mount) {\n            node.mount.mounts.push(mount);\n          }\n        }\n        return mountRoot;\n      },\n      unmount: function(mountpoint) {\n        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\n        if (!FS.isMountpoint(lookup.node)) {\n          throw new FS.ErrnoError(28);\n        }\n        var node = lookup.node;\n        var mount = node.mounted;\n        var mounts = FS.getMounts(mount);\n        Object.keys(FS.nameTable).forEach(function(hash) {\n          var current = FS.nameTable[hash];\n          while (current) {\n            var next = current.name_next;\n            if (mounts.indexOf(current.mount) !== -1) {\n              FS.destroyNode(current);\n            }\n            current = next;\n          }\n        });\n        node.mounted = null;\n        var idx = node.mount.mounts.indexOf(mount);\n        assert(idx !== -1);\n        node.mount.mounts.splice(idx, 1);\n      },\n      lookup: function(parent, name) {\n        return parent.node_ops.lookup(parent, name);\n      },\n      mknod: function(path, mode, dev) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        if (!name || name === \".\" || name === \"..\") {\n          throw new FS.ErrnoError(28);\n        }\n        var errCode = FS.mayCreate(parent, name);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.mknod) {\n          throw new FS.ErrnoError(63);\n        }\n        return parent.node_ops.mknod(parent, name, mode, dev);\n      },\n      create: function(path, mode) {\n        mode = mode !== void 0 ? mode : 438;\n        mode &= 4095;\n        mode |= 32768;\n        return FS.mknod(path, mode, 0);\n      },\n      mkdir: function(path, mode) {\n        mode = mode !== void 0 ? mode : 511;\n        mode &= 511 | 512;\n        mode |= 16384;\n        return FS.mknod(path, mode, 0);\n      },\n      mkdirTree: function(path, mode) {\n        var dirs = path.split(\"/\");\n        var d = \"\";\n        for (var i = 0; i < dirs.length; ++i) {\n          if (!dirs[i])\n            continue;\n          d += \"/\" + dirs[i];\n          try {\n            FS.mkdir(d, mode);\n          } catch (e) {\n            if (e.errno != 20)\n              throw e;\n          }\n        }\n      },\n      mkdev: function(path, mode, dev) {\n        if (typeof dev === \"undefined\") {\n          dev = mode;\n          mode = 438;\n        }\n        mode |= 8192;\n        return FS.mknod(path, mode, dev);\n      },\n      symlink: function(oldpath, newpath) {\n        if (!PATH_FS.resolve(oldpath)) {\n          throw new FS.ErrnoError(44);\n        }\n        var lookup = FS.lookupPath(newpath, { parent: true });\n        var parent = lookup.node;\n        if (!parent) {\n          throw new FS.ErrnoError(44);\n        }\n        var newname = PATH.basename(newpath);\n        var errCode = FS.mayCreate(parent, newname);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.symlink) {\n          throw new FS.ErrnoError(63);\n        }\n        return parent.node_ops.symlink(parent, newname, oldpath);\n      },\n      rename: function(old_path, new_path) {\n        var old_dirname = PATH.dirname(old_path);\n        var new_dirname = PATH.dirname(new_path);\n        var old_name = PATH.basename(old_path);\n        var new_name = PATH.basename(new_path);\n        var lookup, old_dir, new_dir;\n        try {\n          lookup = FS.lookupPath(old_path, { parent: true });\n          old_dir = lookup.node;\n          lookup = FS.lookupPath(new_path, { parent: true });\n          new_dir = lookup.node;\n        } catch (e) {\n          throw new FS.ErrnoError(10);\n        }\n        if (!old_dir || !new_dir)\n          throw new FS.ErrnoError(44);\n        if (old_dir.mount !== new_dir.mount) {\n          throw new FS.ErrnoError(75);\n        }\n        var old_node = FS.lookupNode(old_dir, old_name);\n        var relative = PATH_FS.relative(old_path, new_dirname);\n        if (relative.charAt(0) !== \".\") {\n          throw new FS.ErrnoError(28);\n        }\n        relative = PATH_FS.relative(new_path, old_dirname);\n        if (relative.charAt(0) !== \".\") {\n          throw new FS.ErrnoError(55);\n        }\n        var new_node;\n        try {\n          new_node = FS.lookupNode(new_dir, new_name);\n        } catch (e) {\n        }\n        if (old_node === new_node) {\n          return;\n        }\n        var isdir = FS.isDir(old_node.mode);\n        var errCode = FS.mayDelete(old_dir, old_name, isdir);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!old_dir.node_ops.rename) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {\n          throw new FS.ErrnoError(10);\n        }\n        if (new_dir !== old_dir) {\n          errCode = FS.nodePermissions(old_dir, \"w\");\n          if (errCode) {\n            throw new FS.ErrnoError(errCode);\n          }\n        }\n        try {\n          if (FS.trackingDelegate[\"willMovePath\"]) {\n            FS.trackingDelegate[\"willMovePath\"](old_path, new_path);\n          }\n        } catch (e) {\n          err(\"FS.trackingDelegate['willMovePath']('\" + old_path + \"', '\" + new_path + \"') threw an exception: \" + e.message);\n        }\n        FS.hashRemoveNode(old_node);\n        try {\n          old_dir.node_ops.rename(old_node, new_dir, new_name);\n        } catch (e) {\n          throw e;\n        } finally {\n          FS.hashAddNode(old_node);\n        }\n        try {\n          if (FS.trackingDelegate[\"onMovePath\"])\n            FS.trackingDelegate[\"onMovePath\"](old_path, new_path);\n        } catch (e) {\n          err(\"FS.trackingDelegate['onMovePath']('\" + old_path + \"', '\" + new_path + \"') threw an exception: \" + e.message);\n        }\n      },\n      rmdir: function(path) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var errCode = FS.mayDelete(parent, name, true);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.rmdir) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10);\n        }\n        try {\n          if (FS.trackingDelegate[\"willDeletePath\"]) {\n            FS.trackingDelegate[\"willDeletePath\"](path);\n          }\n        } catch (e) {\n          err(\"FS.trackingDelegate['willDeletePath']('\" + path + \"') threw an exception: \" + e.message);\n        }\n        parent.node_ops.rmdir(parent, name);\n        FS.destroyNode(node);\n        try {\n          if (FS.trackingDelegate[\"onDeletePath\"])\n            FS.trackingDelegate[\"onDeletePath\"](path);\n        } catch (e) {\n          err(\"FS.trackingDelegate['onDeletePath']('\" + path + \"') threw an exception: \" + e.message);\n        }\n      },\n      readdir: function(path) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        var node = lookup.node;\n        if (!node.node_ops.readdir) {\n          throw new FS.ErrnoError(54);\n        }\n        return node.node_ops.readdir(node);\n      },\n      unlink: function(path) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var errCode = FS.mayDelete(parent, name, false);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.unlink) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10);\n        }\n        try {\n          if (FS.trackingDelegate[\"willDeletePath\"]) {\n            FS.trackingDelegate[\"willDeletePath\"](path);\n          }\n        } catch (e) {\n          err(\"FS.trackingDelegate['willDeletePath']('\" + path + \"') threw an exception: \" + e.message);\n        }\n        parent.node_ops.unlink(parent, name);\n        FS.destroyNode(node);\n        try {\n          if (FS.trackingDelegate[\"onDeletePath\"])\n            FS.trackingDelegate[\"onDeletePath\"](path);\n        } catch (e) {\n          err(\"FS.trackingDelegate['onDeletePath']('\" + path + \"') threw an exception: \" + e.message);\n        }\n      },\n      readlink: function(path) {\n        var lookup = FS.lookupPath(path);\n        var link = lookup.node;\n        if (!link) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!link.node_ops.readlink) {\n          throw new FS.ErrnoError(28);\n        }\n        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\n      },\n      stat: function(path, dontFollow) {\n        var lookup = FS.lookupPath(path, { follow: !dontFollow });\n        var node = lookup.node;\n        if (!node) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!node.node_ops.getattr) {\n          throw new FS.ErrnoError(63);\n        }\n        return node.node_ops.getattr(node);\n      },\n      lstat: function(path) {\n        return FS.stat(path, true);\n      },\n      chmod: function(path, mode, dontFollow) {\n        var node;\n        if (typeof path === \"string\") {\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        node.node_ops.setattr(node, {\n          mode: mode & 4095 | node.mode & ~4095,\n          timestamp: Date.now()\n        });\n      },\n      lchmod: function(path, mode) {\n        FS.chmod(path, mode, true);\n      },\n      fchmod: function(fd, mode) {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n          throw new FS.ErrnoError(8);\n        }\n        FS.chmod(stream.node, mode);\n      },\n      chown: function(path, uid, gid, dontFollow) {\n        var node;\n        if (typeof path === \"string\") {\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        node.node_ops.setattr(node, { timestamp: Date.now() });\n      },\n      lchown: function(path, uid, gid) {\n        FS.chown(path, uid, gid, true);\n      },\n      fchown: function(fd, uid, gid) {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n          throw new FS.ErrnoError(8);\n        }\n        FS.chown(stream.node, uid, gid);\n      },\n      truncate: function(path, len) {\n        if (len < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        var node;\n        if (typeof path === \"string\") {\n          var lookup = FS.lookupPath(path, { follow: true });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!FS.isFile(node.mode)) {\n          throw new FS.ErrnoError(28);\n        }\n        var errCode = FS.nodePermissions(node, \"w\");\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        node.node_ops.setattr(node, { size: len, timestamp: Date.now() });\n      },\n      ftruncate: function(fd, len) {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(28);\n        }\n        FS.truncate(stream.node, len);\n      },\n      utime: function(path, atime, mtime) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        var node = lookup.node;\n        node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) });\n      },\n      open: function(path, flags, mode, fd_start, fd_end) {\n        if (path === \"\") {\n          throw new FS.ErrnoError(44);\n        }\n        flags = typeof flags === \"string\" ? FS.modeStringToFlags(flags) : flags;\n        mode = typeof mode === \"undefined\" ? 438 : mode;\n        if (flags & 64) {\n          mode = mode & 4095 | 32768;\n        } else {\n          mode = 0;\n        }\n        var node;\n        if (typeof path === \"object\") {\n          node = path;\n        } else {\n          path = PATH.normalize(path);\n          try {\n            var lookup = FS.lookupPath(path, { follow: !(flags & 131072) });\n            node = lookup.node;\n          } catch (e) {\n          }\n        }\n        var created = false;\n        if (flags & 64) {\n          if (node) {\n            if (flags & 128) {\n              throw new FS.ErrnoError(20);\n            }\n          } else {\n            node = FS.mknod(path, mode, 0);\n            created = true;\n          }\n        }\n        if (!node) {\n          throw new FS.ErrnoError(44);\n        }\n        if (FS.isChrdev(node.mode)) {\n          flags &= ~512;\n        }\n        if (flags & 65536 && !FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(54);\n        }\n        if (!created) {\n          var errCode = FS.mayOpen(node, flags);\n          if (errCode) {\n            throw new FS.ErrnoError(errCode);\n          }\n        }\n        if (flags & 512) {\n          FS.truncate(node, 0);\n        }\n        flags &= ~(128 | 512);\n        var stream = FS.createStream({\n          node,\n          path: FS.getPath(node),\n          flags,\n          seekable: true,\n          position: 0,\n          stream_ops: node.stream_ops,\n          ungotten: [],\n          error: false\n        }, fd_start, fd_end);\n        if (stream.stream_ops.open) {\n          stream.stream_ops.open(stream);\n        }\n        if (Module[\"logReadFiles\"] && !(flags & 1)) {\n          if (!FS.readFiles)\n            FS.readFiles = {};\n          if (!(path in FS.readFiles)) {\n            FS.readFiles[path] = 1;\n            err(\"FS.trackingDelegate error on read file: \" + path);\n          }\n        }\n        try {\n          if (FS.trackingDelegate[\"onOpenFile\"]) {\n            var trackingFlags = 0;\n            if ((flags & 2097155) !== 1) {\n              trackingFlags |= FS.tracking.openFlags.READ;\n            }\n            if ((flags & 2097155) !== 0) {\n              trackingFlags |= FS.tracking.openFlags.WRITE;\n            }\n            FS.trackingDelegate[\"onOpenFile\"](path, trackingFlags);\n          }\n        } catch (e) {\n          err(\"FS.trackingDelegate['onOpenFile']('\" + path + \"', flags) threw an exception: \" + e.message);\n        }\n        return stream;\n      },\n      close: function(stream) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (stream.getdents)\n          stream.getdents = null;\n        try {\n          if (stream.stream_ops.close) {\n            stream.stream_ops.close(stream);\n          }\n        } catch (e) {\n          throw e;\n        } finally {\n          FS.closeStream(stream.fd);\n        }\n        stream.fd = null;\n      },\n      isClosed: function(stream) {\n        return stream.fd === null;\n      },\n      llseek: function(stream, offset, whence) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (!stream.seekable || !stream.stream_ops.llseek) {\n          throw new FS.ErrnoError(70);\n        }\n        if (whence != 0 && whence != 1 && whence != 2) {\n          throw new FS.ErrnoError(28);\n        }\n        stream.position = stream.stream_ops.llseek(stream, offset, whence);\n        stream.ungotten = [];\n        return stream.position;\n      },\n      read: function(stream, buffer2, offset, length, position) {\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(8);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!stream.stream_ops.read) {\n          throw new FS.ErrnoError(28);\n        }\n        var seeking = typeof position !== \"undefined\";\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(70);\n        }\n        var bytesRead = stream.stream_ops.read(stream, buffer2, offset, length, position);\n        if (!seeking)\n          stream.position += bytesRead;\n        return bytesRead;\n      },\n      write: function(stream, buffer2, offset, length, position, canOwn) {\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(8);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!stream.stream_ops.write) {\n          throw new FS.ErrnoError(28);\n        }\n        if (stream.flags & 1024) {\n          FS.llseek(stream, 0, 2);\n        }\n        var seeking = typeof position !== \"undefined\";\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(70);\n        }\n        var bytesWritten = stream.stream_ops.write(stream, buffer2, offset, length, position, canOwn);\n        if (!seeking)\n          stream.position += bytesWritten;\n        try {\n          if (stream.path && FS.trackingDelegate[\"onWriteToFile\"])\n            FS.trackingDelegate[\"onWriteToFile\"](stream.path);\n        } catch (e) {\n          err(\"FS.trackingDelegate['onWriteToFile']('\" + stream.path + \"') threw an exception: \" + e.message);\n        }\n        return bytesWritten;\n      },\n      allocate: function(stream, offset, length) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (offset < 0 || length <= 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(8);\n        }\n        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(43);\n        }\n        if (!stream.stream_ops.allocate) {\n          throw new FS.ErrnoError(138);\n        }\n        stream.stream_ops.allocate(stream, offset, length);\n      },\n      mmap: function(stream, buffer2, offset, length, position, prot, flags) {\n        if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {\n          throw new FS.ErrnoError(2);\n        }\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(2);\n        }\n        if (!stream.stream_ops.mmap) {\n          throw new FS.ErrnoError(43);\n        }\n        return stream.stream_ops.mmap(stream, buffer2, offset, length, position, prot, flags);\n      },\n      msync: function(stream, buffer2, offset, length, mmapFlags) {\n        if (!stream || !stream.stream_ops.msync) {\n          return 0;\n        }\n        return stream.stream_ops.msync(stream, buffer2, offset, length, mmapFlags);\n      },\n      munmap: function(stream) {\n        return 0;\n      },\n      ioctl: function(stream, cmd, arg) {\n        if (!stream.stream_ops.ioctl) {\n          throw new FS.ErrnoError(59);\n        }\n        return stream.stream_ops.ioctl(stream, cmd, arg);\n      },\n      readFile: function(path, opts) {\n        opts = opts || {};\n        opts.flags = opts.flags || \"r\";\n        opts.encoding = opts.encoding || \"binary\";\n        if (opts.encoding !== \"utf8\" && opts.encoding !== \"binary\") {\n          throw new Error('Invalid encoding type \"' + opts.encoding + '\"');\n        }\n        var ret;\n        var stream = FS.open(path, opts.flags);\n        var stat = FS.stat(path);\n        var length = stat.size;\n        var buf = new Uint8Array(length);\n        FS.read(stream, buf, 0, length, 0);\n        if (opts.encoding === \"utf8\") {\n          ret = UTF8ArrayToString(buf, 0);\n        } else if (opts.encoding === \"binary\") {\n          ret = buf;\n        }\n        FS.close(stream);\n        return ret;\n      },\n      writeFile: function(path, data, opts) {\n        opts = opts || {};\n        opts.flags = opts.flags || \"w\";\n        var stream = FS.open(path, opts.flags, opts.mode);\n        if (typeof data === \"string\") {\n          var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\n          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n          FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);\n        } else if (ArrayBuffer.isView(data)) {\n          FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);\n        } else {\n          throw new Error(\"Unsupported data type\");\n        }\n        FS.close(stream);\n      },\n      cwd: function() {\n        return FS.currentPath;\n      },\n      chdir: function(path) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        if (lookup.node === null) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!FS.isDir(lookup.node.mode)) {\n          throw new FS.ErrnoError(54);\n        }\n        var errCode = FS.nodePermissions(lookup.node, \"x\");\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        FS.currentPath = lookup.path;\n      },\n      createDefaultDirectories: function() {\n        FS.mkdir(\"/tmp\");\n        FS.mkdir(\"/home\");\n        FS.mkdir(\"/home/web_user\");\n      },\n      createDefaultDevices: function() {\n        FS.mkdir(\"/dev\");\n        FS.registerDevice(FS.makedev(1, 3), {\n          read: function() {\n            return 0;\n          },\n          write: function(stream, buffer2, offset, length, pos) {\n            return length;\n          }\n        });\n        FS.mkdev(\"/dev/null\", FS.makedev(1, 3));\n        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n        FS.mkdev(\"/dev/tty\", FS.makedev(5, 0));\n        FS.mkdev(\"/dev/tty1\", FS.makedev(6, 0));\n        var random_device;\n        if (typeof crypto === \"object\" && typeof crypto[\"getRandomValues\"] === \"function\") {\n          var randomBuffer = new Uint8Array(1);\n          random_device = function() {\n            crypto.getRandomValues(randomBuffer);\n            return randomBuffer[0];\n          };\n        } else if (ENVIRONMENT_IS_NODE) {\n          try {\n            var crypto_module = require(\"crypto\");\n            random_device = function() {\n              return crypto_module[\"randomBytes\"](1)[0];\n            };\n          } catch (e) {\n          }\n        } else\n          ;\n        if (!random_device) {\n          random_device = function() {\n            abort(\"no cryptographic support found for random_device. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: function(array) { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };\");\n          };\n        }\n        FS.createDevice(\"/dev\", \"random\", random_device);\n        FS.createDevice(\"/dev\", \"urandom\", random_device);\n        FS.mkdir(\"/dev/shm\");\n        FS.mkdir(\"/dev/shm/tmp\");\n      },\n      createSpecialDirectories: function() {\n        FS.mkdir(\"/proc\");\n        FS.mkdir(\"/proc/self\");\n        FS.mkdir(\"/proc/self/fd\");\n        FS.mount({\n          mount: function() {\n            var node = FS.createNode(\"/proc/self\", \"fd\", 16384 | 511, 73);\n            node.node_ops = {\n              lookup: function(parent, name) {\n                var fd = +name;\n                var stream = FS.getStream(fd);\n                if (!stream)\n                  throw new FS.ErrnoError(8);\n                var ret = {\n                  parent: null,\n                  mount: { mountpoint: \"fake\" },\n                  node_ops: {\n                    readlink: function() {\n                      return stream.path;\n                    }\n                  }\n                };\n                ret.parent = ret;\n                return ret;\n              }\n            };\n            return node;\n          }\n        }, {}, \"/proc/self/fd\");\n      },\n      createStandardStreams: function() {\n        if (Module[\"stdin\"]) {\n          FS.createDevice(\"/dev\", \"stdin\", Module[\"stdin\"]);\n        } else {\n          FS.symlink(\"/dev/tty\", \"/dev/stdin\");\n        }\n        if (Module[\"stdout\"]) {\n          FS.createDevice(\"/dev\", \"stdout\", null, Module[\"stdout\"]);\n        } else {\n          FS.symlink(\"/dev/tty\", \"/dev/stdout\");\n        }\n        if (Module[\"stderr\"]) {\n          FS.createDevice(\"/dev\", \"stderr\", null, Module[\"stderr\"]);\n        } else {\n          FS.symlink(\"/dev/tty1\", \"/dev/stderr\");\n        }\n        var stdin = FS.open(\"/dev/stdin\", \"r\");\n        var stdout = FS.open(\"/dev/stdout\", \"w\");\n        var stderr = FS.open(\"/dev/stderr\", \"w\");\n        assert(stdin.fd === 0, \"invalid handle for stdin (\" + stdin.fd + \")\");\n        assert(stdout.fd === 1, \"invalid handle for stdout (\" + stdout.fd + \")\");\n        assert(stderr.fd === 2, \"invalid handle for stderr (\" + stderr.fd + \")\");\n      },\n      ensureErrnoError: function() {\n        if (FS.ErrnoError)\n          return;\n        FS.ErrnoError = function ErrnoError(errno, node) {\n          this.node = node;\n          this.setErrno = function(errno2) {\n            this.errno = errno2;\n            for (var key2 in ERRNO_CODES) {\n              if (ERRNO_CODES[key2] === errno2) {\n                this.code = key2;\n                break;\n              }\n            }\n          };\n          this.setErrno(errno);\n          this.message = ERRNO_MESSAGES[errno];\n          if (this.stack) {\n            Object.defineProperty(this, \"stack\", {\n              value: new Error().stack,\n              writable: true\n            });\n            this.stack = demangleAll(this.stack);\n          }\n        };\n        FS.ErrnoError.prototype = new Error();\n        FS.ErrnoError.prototype.constructor = FS.ErrnoError;\n        [44].forEach(function(code) {\n          FS.genericErrors[code] = new FS.ErrnoError(code);\n          FS.genericErrors[code].stack = \"<generic error, no stack>\";\n        });\n      },\n      staticInit: function() {\n        FS.ensureErrnoError();\n        FS.nameTable = new Array(4096);\n        FS.mount(MEMFS, {}, \"/\");\n        FS.createDefaultDirectories();\n        FS.createDefaultDevices();\n        FS.createSpecialDirectories();\n        FS.filesystems = { MEMFS };\n      },\n      init: function(input, output, error) {\n        assert(!FS.init.initialized, \"FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)\");\n        FS.init.initialized = true;\n        FS.ensureErrnoError();\n        Module[\"stdin\"] = input || Module[\"stdin\"];\n        Module[\"stdout\"] = output || Module[\"stdout\"];\n        Module[\"stderr\"] = error || Module[\"stderr\"];\n        FS.createStandardStreams();\n      },\n      quit: function() {\n        FS.init.initialized = false;\n        var fflush = Module[\"_fflush\"];\n        if (fflush)\n          fflush(0);\n        for (var i = 0; i < FS.streams.length; i++) {\n          var stream = FS.streams[i];\n          if (!stream) {\n            continue;\n          }\n          FS.close(stream);\n        }\n      },\n      getMode: function(canRead, canWrite) {\n        var mode = 0;\n        if (canRead)\n          mode |= 292 | 73;\n        if (canWrite)\n          mode |= 146;\n        return mode;\n      },\n      joinPath: function(parts, forceRelative) {\n        var path = PATH.join.apply(null, parts);\n        if (forceRelative && path[0] == \"/\")\n          path = path.substr(1);\n        return path;\n      },\n      absolutePath: function(relative, base) {\n        return PATH_FS.resolve(base, relative);\n      },\n      standardizePath: function(path) {\n        return PATH.normalize(path);\n      },\n      findObject: function(path, dontResolveLastLink) {\n        var ret = FS.analyzePath(path, dontResolveLastLink);\n        if (ret.exists) {\n          return ret.object;\n        } else {\n          ___setErrNo(ret.error);\n          return null;\n        }\n      },\n      analyzePath: function(path, dontResolveLastLink) {\n        try {\n          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n          path = lookup.path;\n        } catch (e) {\n        }\n        var ret = {\n          isRoot: false,\n          exists: false,\n          error: 0,\n          name: null,\n          path: null,\n          object: null,\n          parentExists: false,\n          parentPath: null,\n          parentObject: null\n        };\n        try {\n          var lookup = FS.lookupPath(path, { parent: true });\n          ret.parentExists = true;\n          ret.parentPath = lookup.path;\n          ret.parentObject = lookup.node;\n          ret.name = PATH.basename(path);\n          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n          ret.exists = true;\n          ret.path = lookup.path;\n          ret.object = lookup.node;\n          ret.name = lookup.node.name;\n          ret.isRoot = lookup.path === \"/\";\n        } catch (e) {\n          ret.error = e.errno;\n        }\n        return ret;\n      },\n      createFolder: function(parent, name, canRead, canWrite) {\n        var path = PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name);\n        var mode = FS.getMode(canRead, canWrite);\n        return FS.mkdir(path, mode);\n      },\n      createPath: function(parent, path, canRead, canWrite) {\n        parent = typeof parent === \"string\" ? parent : FS.getPath(parent);\n        var parts = path.split(\"/\").reverse();\n        while (parts.length) {\n          var part = parts.pop();\n          if (!part)\n            continue;\n          var current = PATH.join2(parent, part);\n          try {\n            FS.mkdir(current);\n          } catch (e) {\n          }\n          parent = current;\n        }\n        return current;\n      },\n      createFile: function(parent, name, properties, canRead, canWrite) {\n        var path = PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name);\n        var mode = FS.getMode(canRead, canWrite);\n        return FS.create(path, mode);\n      },\n      createDataFile: function(parent, name, data, canRead, canWrite, canOwn) {\n        var path = name ? PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name) : parent;\n        var mode = FS.getMode(canRead, canWrite);\n        var node = FS.create(path, mode);\n        if (data) {\n          if (typeof data === \"string\") {\n            var arr = new Array(data.length);\n            for (var i = 0, len = data.length; i < len; ++i)\n              arr[i] = data.charCodeAt(i);\n            data = arr;\n          }\n          FS.chmod(node, mode | 146);\n          var stream = FS.open(node, \"w\");\n          FS.write(stream, data, 0, data.length, 0, canOwn);\n          FS.close(stream);\n          FS.chmod(node, mode);\n        }\n        return node;\n      },\n      createDevice: function(parent, name, input, output) {\n        var path = PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name);\n        var mode = FS.getMode(!!input, !!output);\n        if (!FS.createDevice.major)\n          FS.createDevice.major = 64;\n        var dev = FS.makedev(FS.createDevice.major++, 0);\n        FS.registerDevice(dev, {\n          open: function(stream) {\n            stream.seekable = false;\n          },\n          close: function(stream) {\n            if (output && output.buffer && output.buffer.length) {\n              output(10);\n            }\n          },\n          read: function(stream, buffer2, offset, length, pos) {\n            var bytesRead = 0;\n            for (var i = 0; i < length; i++) {\n              var result;\n              try {\n                result = input();\n              } catch (e) {\n                throw new FS.ErrnoError(29);\n              }\n              if (result === void 0 && bytesRead === 0) {\n                throw new FS.ErrnoError(6);\n              }\n              if (result === null || result === void 0)\n                break;\n              bytesRead++;\n              buffer2[offset + i] = result;\n            }\n            if (bytesRead) {\n              stream.node.timestamp = Date.now();\n            }\n            return bytesRead;\n          },\n          write: function(stream, buffer2, offset, length, pos) {\n            for (var i = 0; i < length; i++) {\n              try {\n                output(buffer2[offset + i]);\n              } catch (e) {\n                throw new FS.ErrnoError(29);\n              }\n            }\n            if (length) {\n              stream.node.timestamp = Date.now();\n            }\n            return i;\n          }\n        });\n        return FS.mkdev(path, mode, dev);\n      },\n      createLink: function(parent, name, target, canRead, canWrite) {\n        var path = PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name);\n        return FS.symlink(target, path);\n      },\n      forceLoadFile: function(obj) {\n        if (obj.isDevice || obj.isFolder || obj.link || obj.contents)\n          return true;\n        var success = true;\n        if (typeof XMLHttpRequest !== \"undefined\") {\n          throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\n        } else if (read_) {\n          try {\n            obj.contents = intArrayFromString(read_(obj.url), true);\n            obj.usedBytes = obj.contents.length;\n          } catch (e) {\n            success = false;\n          }\n        } else {\n          throw new Error(\"Cannot load without read() or XMLHttpRequest.\");\n        }\n        if (!success)\n          ___setErrNo(29);\n        return success;\n      },\n      createLazyFile: function(parent, name, url, canRead, canWrite) {\n        function LazyUint8Array() {\n          this.lengthKnown = false;\n          this.chunks = [];\n        }\n        LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {\n          if (idx > this.length - 1 || idx < 0) {\n            return void 0;\n          }\n          var chunkOffset = idx % this.chunkSize;\n          var chunkNum = idx / this.chunkSize | 0;\n          return this.getter(chunkNum)[chunkOffset];\n        };\n        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\n          this.getter = getter;\n        };\n        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"HEAD\", url, false);\n          xhr.send(null);\n          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))\n            throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n          var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\n          var header;\n          var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\n          var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\n          var chunkSize = 1024 * 1024;\n          if (!hasByteServing)\n            chunkSize = datalength;\n          var doXHR = function(from, to) {\n            if (from > to)\n              throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\n            if (to > datalength - 1)\n              throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\n            var xhr2 = new XMLHttpRequest();\n            xhr2.open(\"GET\", url, false);\n            if (datalength !== chunkSize)\n              xhr2.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\n            if (typeof Uint8Array != \"undefined\")\n              xhr2.responseType = \"arraybuffer\";\n            if (xhr2.overrideMimeType) {\n              xhr2.overrideMimeType(\"text/plain; charset=x-user-defined\");\n            }\n            xhr2.send(null);\n            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))\n              throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr2.status);\n            if (xhr2.response !== void 0) {\n              return new Uint8Array(xhr2.response || []);\n            } else {\n              return intArrayFromString(xhr2.responseText || \"\", true);\n            }\n          };\n          var lazyArray2 = this;\n          lazyArray2.setDataGetter(function(chunkNum) {\n            var start = chunkNum * chunkSize;\n            var end = (chunkNum + 1) * chunkSize - 1;\n            end = Math.min(end, datalength - 1);\n            if (typeof lazyArray2.chunks[chunkNum] === \"undefined\") {\n              lazyArray2.chunks[chunkNum] = doXHR(start, end);\n            }\n            if (typeof lazyArray2.chunks[chunkNum] === \"undefined\")\n              throw new Error(\"doXHR failed!\");\n            return lazyArray2.chunks[chunkNum];\n          });\n          if (usesGzip || !datalength) {\n            chunkSize = datalength = 1;\n            datalength = this.getter(0).length;\n            chunkSize = datalength;\n            out(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\n          }\n          this._length = datalength;\n          this._chunkSize = chunkSize;\n          this.lengthKnown = true;\n        };\n        if (typeof XMLHttpRequest !== \"undefined\") {\n          if (!ENVIRONMENT_IS_WORKER)\n            throw \"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\";\n          var lazyArray = new LazyUint8Array();\n          Object.defineProperties(lazyArray, {\n            length: {\n              get: function() {\n                if (!this.lengthKnown) {\n                  this.cacheLength();\n                }\n                return this._length;\n              }\n            },\n            chunkSize: {\n              get: function() {\n                if (!this.lengthKnown) {\n                  this.cacheLength();\n                }\n                return this._chunkSize;\n              }\n            }\n          });\n          var properties = { isDevice: false, contents: lazyArray };\n        } else {\n          var properties = { isDevice: false, url };\n        }\n        var node = FS.createFile(parent, name, properties, canRead, canWrite);\n        if (properties.contents) {\n          node.contents = properties.contents;\n        } else if (properties.url) {\n          node.contents = null;\n          node.url = properties.url;\n        }\n        Object.defineProperties(node, {\n          usedBytes: {\n            get: function() {\n              return this.contents.length;\n            }\n          }\n        });\n        var stream_ops = {};\n        var keys = Object.keys(node.stream_ops);\n        keys.forEach(function(key2) {\n          var fn = node.stream_ops[key2];\n          stream_ops[key2] = function forceLoadLazyFile() {\n            if (!FS.forceLoadFile(node)) {\n              throw new FS.ErrnoError(29);\n            }\n            return fn.apply(null, arguments);\n          };\n        });\n        stream_ops.read = function stream_ops_read(stream, buffer2, offset, length, position) {\n          if (!FS.forceLoadFile(node)) {\n            throw new FS.ErrnoError(29);\n          }\n          var contents = stream.node.contents;\n          if (position >= contents.length)\n            return 0;\n          var size = Math.min(contents.length - position, length);\n          assert(size >= 0);\n          if (contents.slice) {\n            for (var i = 0; i < size; i++) {\n              buffer2[offset + i] = contents[position + i];\n            }\n          } else {\n            for (var i = 0; i < size; i++) {\n              buffer2[offset + i] = contents.get(position + i);\n            }\n          }\n          return size;\n        };\n        node.stream_ops = stream_ops;\n        return node;\n      },\n      createPreloadedFile: function(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {\n        Browser.init();\n        var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\n        var dep = getUniqueRunDependency(\"cp \" + fullname);\n        function processData(byteArray) {\n          function finish(byteArray2) {\n            if (preFinish)\n              preFinish();\n            if (!dontCreateFile) {\n              FS.createDataFile(parent, name, byteArray2, canRead, canWrite, canOwn);\n            }\n            if (onload)\n              onload();\n            removeRunDependency(dep);\n          }\n          var handled = false;\n          Module[\"preloadPlugins\"].forEach(function(plugin) {\n            if (handled)\n              return;\n            if (plugin[\"canHandle\"](fullname)) {\n              plugin[\"handle\"](byteArray, fullname, finish, function() {\n                if (onerror)\n                  onerror();\n                removeRunDependency(dep);\n              });\n              handled = true;\n            }\n          });\n          if (!handled)\n            finish(byteArray);\n        }\n        addRunDependency(dep);\n        if (typeof url == \"string\") {\n          Browser.asyncLoad(url, function(byteArray) {\n            processData(byteArray);\n          }, onerror);\n        } else {\n          processData(url);\n        }\n      },\n      indexedDB: function() {\n        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n      },\n      DB_NAME: function() {\n        return \"EM_FS_\" + window.location.pathname;\n      },\n      DB_VERSION: 20,\n      DB_STORE_NAME: \"FILE_DATA\",\n      saveFilesToDB: function(paths, onload, onerror) {\n        onload = onload || function() {\n        };\n        onerror = onerror || function() {\n        };\n        var indexedDB = FS.indexedDB();\n        try {\n          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\n        } catch (e) {\n          return onerror(e);\n        }\n        openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {\n          out(\"creating db\");\n          var db = openRequest.result;\n          db.createObjectStore(FS.DB_STORE_NAME);\n        };\n        openRequest.onsuccess = function openRequest_onsuccess() {\n          var db = openRequest.result;\n          var transaction = db.transaction([FS.DB_STORE_NAME], \"readwrite\");\n          var files = transaction.objectStore(FS.DB_STORE_NAME);\n          var ok = 0, fail = 0, total = paths.length;\n          function finish() {\n            if (fail == 0)\n              onload();\n            else\n              onerror();\n          }\n          paths.forEach(function(path) {\n            var putRequest = files.put(FS.analyzePath(path).object.contents, path);\n            putRequest.onsuccess = function putRequest_onsuccess() {\n              ok++;\n              if (ok + fail == total)\n                finish();\n            };\n            putRequest.onerror = function putRequest_onerror() {\n              fail++;\n              if (ok + fail == total)\n                finish();\n            };\n          });\n          transaction.onerror = onerror;\n        };\n        openRequest.onerror = onerror;\n      },\n      loadFilesFromDB: function(paths, onload, onerror) {\n        onload = onload || function() {\n        };\n        onerror = onerror || function() {\n        };\n        var indexedDB = FS.indexedDB();\n        try {\n          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\n        } catch (e) {\n          return onerror(e);\n        }\n        openRequest.onupgradeneeded = onerror;\n        openRequest.onsuccess = function openRequest_onsuccess() {\n          var db = openRequest.result;\n          try {\n            var transaction = db.transaction([FS.DB_STORE_NAME], \"readonly\");\n          } catch (e) {\n            onerror(e);\n            return;\n          }\n          var files = transaction.objectStore(FS.DB_STORE_NAME);\n          var ok = 0, fail = 0, total = paths.length;\n          function finish() {\n            if (fail == 0)\n              onload();\n            else\n              onerror();\n          }\n          paths.forEach(function(path) {\n            var getRequest = files.get(path);\n            getRequest.onsuccess = function getRequest_onsuccess() {\n              if (FS.analyzePath(path).exists) {\n                FS.unlink(path);\n              }\n              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);\n              ok++;\n              if (ok + fail == total)\n                finish();\n            };\n            getRequest.onerror = function getRequest_onerror() {\n              fail++;\n              if (ok + fail == total)\n                finish();\n            };\n          });\n          transaction.onerror = onerror;\n        };\n        openRequest.onerror = onerror;\n      }\n    };\n    var SOCKFS = {\n      mount: function(mount) {\n        Module[\"websocket\"] = Module[\"websocket\"] && typeof Module[\"websocket\"] === \"object\" ? Module[\"websocket\"] : {};\n        Module[\"websocket\"]._callbacks = {};\n        Module[\"websocket\"][\"on\"] = function(event, callback2) {\n          if (typeof callback2 === \"function\") {\n            this._callbacks[event] = callback2;\n          }\n          return this;\n        };\n        Module[\"websocket\"].emit = function(event, param) {\n          if (typeof this._callbacks[event] === \"function\") {\n            this._callbacks[event].call(this, param);\n          }\n        };\n        return FS.createNode(null, \"/\", 16384 | 511, 0);\n      },\n      createSocket: function(family, type, protocol) {\n        var streaming = type == 1;\n        if (protocol) {\n          assert(streaming == (protocol == 6));\n        }\n        var sock = {\n          family,\n          type,\n          protocol,\n          server: null,\n          error: null,\n          peers: {},\n          pending: [],\n          recv_queue: [],\n          sock_ops: SOCKFS.websocket_sock_ops\n        };\n        var name = SOCKFS.nextname();\n        var node = FS.createNode(SOCKFS.root, name, 49152, 0);\n        node.sock = sock;\n        var stream = FS.createStream({\n          path: name,\n          node,\n          flags: FS.modeStringToFlags(\"r+\"),\n          seekable: false,\n          stream_ops: SOCKFS.stream_ops\n        });\n        sock.stream = stream;\n        return sock;\n      },\n      getSocket: function(fd) {\n        var stream = FS.getStream(fd);\n        if (!stream || !FS.isSocket(stream.node.mode)) {\n          return null;\n        }\n        return stream.node.sock;\n      },\n      stream_ops: {\n        poll: function(stream) {\n          var sock = stream.node.sock;\n          return sock.sock_ops.poll(sock);\n        },\n        ioctl: function(stream, request, varargs) {\n          var sock = stream.node.sock;\n          return sock.sock_ops.ioctl(sock, request, varargs);\n        },\n        read: function(stream, buffer2, offset, length, position) {\n          var sock = stream.node.sock;\n          var msg = sock.sock_ops.recvmsg(sock, length);\n          if (!msg) {\n            return 0;\n          }\n          buffer2.set(msg.buffer, offset);\n          return msg.buffer.length;\n        },\n        write: function(stream, buffer2, offset, length, position) {\n          var sock = stream.node.sock;\n          return sock.sock_ops.sendmsg(sock, buffer2, offset, length);\n        },\n        close: function(stream) {\n          var sock = stream.node.sock;\n          sock.sock_ops.close(sock);\n        }\n      },\n      nextname: function() {\n        if (!SOCKFS.nextname.current) {\n          SOCKFS.nextname.current = 0;\n        }\n        return \"socket[\" + SOCKFS.nextname.current++ + \"]\";\n      },\n      websocket_sock_ops: {\n        createPeer: function(sock, addr, port) {\n          var ws;\n          if (typeof addr === \"object\") {\n            ws = addr;\n            addr = null;\n            port = null;\n          }\n          if (ws) {\n            if (ws._socket) {\n              addr = ws._socket.remoteAddress;\n              port = ws._socket.remotePort;\n            } else {\n              var result = /ws[s]?:\\/\\/([^:]+):(\\d+)/.exec(ws.url);\n              if (!result) {\n                throw new Error(\"WebSocket URL must be in the format ws(s)://address:port\");\n              }\n              addr = result[1];\n              port = parseInt(result[2], 10);\n            }\n          } else {\n            try {\n              var runtimeConfig = Module[\"websocket\"] && typeof Module[\"websocket\"] === \"object\";\n              var url = \"ws:#\".replace(\"#\", \"//\");\n              if (runtimeConfig) {\n                if (typeof Module[\"websocket\"][\"url\"] === \"string\") {\n                  url = Module[\"websocket\"][\"url\"];\n                }\n              }\n              if (url === \"ws://\" || url === \"wss://\") {\n                var parts = addr.split(\"/\");\n                url = url + parts[0] + \":\" + port + \"/\" + parts.slice(1).join(\"/\");\n              }\n              var subProtocols = \"binary\";\n              if (runtimeConfig) {\n                if (typeof Module[\"websocket\"][\"subprotocol\"] === \"string\") {\n                  subProtocols = Module[\"websocket\"][\"subprotocol\"];\n                }\n              }\n              var opts = void 0;\n              if (subProtocols !== \"null\") {\n                subProtocols = subProtocols.replace(/^ +| +$/g, \"\").split(/ *, */);\n                opts = ENVIRONMENT_IS_NODE ? { protocol: subProtocols.toString() } : subProtocols;\n              }\n              if (runtimeConfig && Module[\"websocket\"][\"subprotocol\"] === null) {\n                subProtocols = \"null\";\n                opts = void 0;\n              }\n              var WebSocketConstructor;\n              if (ENVIRONMENT_IS_NODE) {\n              } else {\n                WebSocketConstructor = WebSocket;\n              }\n              ws = new WebSocketConstructor(url, opts);\n              ws.binaryType = \"arraybuffer\";\n            } catch (e) {\n              throw new FS.ErrnoError(ERRNO_CODES.EHOSTUNREACH);\n            }\n          }\n          var peer = {\n            addr,\n            port,\n            socket: ws,\n            dgram_send_queue: []\n          };\n          SOCKFS.websocket_sock_ops.addPeer(sock, peer);\n          SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);\n          if (sock.type === 2 && typeof sock.sport !== \"undefined\") {\n            peer.dgram_send_queue.push(new Uint8Array([\n              255,\n              255,\n              255,\n              255,\n              \"p\".charCodeAt(0),\n              \"o\".charCodeAt(0),\n              \"r\".charCodeAt(0),\n              \"t\".charCodeAt(0),\n              (sock.sport & 65280) >> 8,\n              sock.sport & 255\n            ]));\n          }\n          return peer;\n        },\n        getPeer: function(sock, addr, port) {\n          return sock.peers[addr + \":\" + port];\n        },\n        addPeer: function(sock, peer) {\n          sock.peers[peer.addr + \":\" + peer.port] = peer;\n        },\n        removePeer: function(sock, peer) {\n          delete sock.peers[peer.addr + \":\" + peer.port];\n        },\n        handlePeerEvents: function(sock, peer) {\n          var first = true;\n          var handleOpen = function() {\n            Module[\"websocket\"].emit(\"open\", sock.stream.fd);\n            try {\n              var queued = peer.dgram_send_queue.shift();\n              while (queued) {\n                peer.socket.send(queued);\n                queued = peer.dgram_send_queue.shift();\n              }\n            } catch (e) {\n              peer.socket.close();\n            }\n          };\n          function handleMessage(data) {\n            if (typeof data === \"string\") {\n              var encoder = new TextEncoder();\n              data = encoder.encode(data);\n            } else {\n              assert(data.byteLength !== void 0);\n              if (data.byteLength == 0) {\n                return;\n              } else {\n                data = new Uint8Array(data);\n              }\n            }\n            var wasfirst = first;\n            first = false;\n            if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === \"p\".charCodeAt(0) && data[5] === \"o\".charCodeAt(0) && data[6] === \"r\".charCodeAt(0) && data[7] === \"t\".charCodeAt(0)) {\n              var newport = data[8] << 8 | data[9];\n              SOCKFS.websocket_sock_ops.removePeer(sock, peer);\n              peer.port = newport;\n              SOCKFS.websocket_sock_ops.addPeer(sock, peer);\n              return;\n            }\n            sock.recv_queue.push({\n              addr: peer.addr,\n              port: peer.port,\n              data\n            });\n            Module[\"websocket\"].emit(\"message\", sock.stream.fd);\n          }\n          if (ENVIRONMENT_IS_NODE) {\n            peer.socket.on(\"open\", handleOpen);\n            peer.socket.on(\"message\", function(data, flags) {\n              if (!flags.binary) {\n                return;\n              }\n              handleMessage(new Uint8Array(data).buffer);\n            });\n            peer.socket.on(\"close\", function() {\n              Module[\"websocket\"].emit(\"close\", sock.stream.fd);\n            });\n            peer.socket.on(\"error\", function(error) {\n              sock.error = ERRNO_CODES.ECONNREFUSED;\n              Module[\"websocket\"].emit(\"error\", [\n                sock.stream.fd,\n                sock.error,\n                \"ECONNREFUSED: Connection refused\"\n              ]);\n            });\n          } else {\n            peer.socket.onopen = handleOpen;\n            peer.socket.onclose = function() {\n              Module[\"websocket\"].emit(\"close\", sock.stream.fd);\n            };\n            peer.socket.onmessage = function peer_socket_onmessage(event) {\n              handleMessage(event.data);\n            };\n            peer.socket.onerror = function(error) {\n              sock.error = ERRNO_CODES.ECONNREFUSED;\n              Module[\"websocket\"].emit(\"error\", [\n                sock.stream.fd,\n                sock.error,\n                \"ECONNREFUSED: Connection refused\"\n              ]);\n            };\n          }\n        },\n        poll: function(sock) {\n          if (sock.type === 1 && sock.server) {\n            return sock.pending.length ? 64 | 1 : 0;\n          }\n          var mask = 0;\n          var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) : null;\n          if (sock.recv_queue.length || !dest || dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {\n            mask |= 64 | 1;\n          }\n          if (!dest || dest && dest.socket.readyState === dest.socket.OPEN) {\n            mask |= 4;\n          }\n          if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {\n            mask |= 16;\n          }\n          return mask;\n        },\n        ioctl: function(sock, request, arg) {\n          switch (request) {\n            case 21531:\n              var bytes = 0;\n              if (sock.recv_queue.length) {\n                bytes = sock.recv_queue[0].data.length;\n              }\n              HEAP32[arg >> 2] = bytes;\n              return 0;\n            default:\n              return ERRNO_CODES.EINVAL;\n          }\n        },\n        close: function(sock) {\n          if (sock.server) {\n            try {\n              sock.server.close();\n            } catch (e) {\n            }\n            sock.server = null;\n          }\n          var peers = Object.keys(sock.peers);\n          for (var i = 0; i < peers.length; i++) {\n            var peer = sock.peers[peers[i]];\n            try {\n              peer.socket.close();\n            } catch (e) {\n            }\n            SOCKFS.websocket_sock_ops.removePeer(sock, peer);\n          }\n          return 0;\n        },\n        bind: function(sock, addr, port) {\n          if (typeof sock.saddr !== \"undefined\" || typeof sock.sport !== \"undefined\") {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n          }\n          sock.saddr = addr;\n          sock.sport = port;\n          if (sock.type === 2) {\n            if (sock.server) {\n              sock.server.close();\n              sock.server = null;\n            }\n            try {\n              sock.sock_ops.listen(sock, 0);\n            } catch (e) {\n              if (!(e instanceof FS.ErrnoError))\n                throw e;\n              if (e.errno !== ERRNO_CODES.EOPNOTSUPP)\n                throw e;\n            }\n          }\n        },\n        connect: function(sock, addr, port) {\n          if (sock.server) {\n            throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);\n          }\n          if (typeof sock.daddr !== \"undefined\" && typeof sock.dport !== \"undefined\") {\n            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);\n            if (dest) {\n              if (dest.socket.readyState === dest.socket.CONNECTING) {\n                throw new FS.ErrnoError(ERRNO_CODES.EALREADY);\n              } else {\n                throw new FS.ErrnoError(ERRNO_CODES.EISCONN);\n              }\n            }\n          }\n          var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);\n          sock.daddr = peer.addr;\n          sock.dport = peer.port;\n          throw new FS.ErrnoError(ERRNO_CODES.EINPROGRESS);\n        },\n        listen: function(sock, backlog) {\n        },\n        accept: function(listensock) {\n          if (!listensock.server) {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n          }\n          var newsock = listensock.pending.shift();\n          newsock.stream.flags = listensock.stream.flags;\n          return newsock;\n        },\n        getname: function(sock, peer) {\n          var addr, port;\n          if (peer) {\n            if (sock.daddr === void 0 || sock.dport === void 0) {\n              throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);\n            }\n            addr = sock.daddr;\n            port = sock.dport;\n          } else {\n            addr = sock.saddr || 0;\n            port = sock.sport || 0;\n          }\n          return { addr, port };\n        },\n        sendmsg: function(sock, buffer2, offset, length, addr, port) {\n          if (sock.type === 2) {\n            if (addr === void 0 || port === void 0) {\n              addr = sock.daddr;\n              port = sock.dport;\n            }\n            if (addr === void 0 || port === void 0) {\n              throw new FS.ErrnoError(ERRNO_CODES.EDESTADDRREQ);\n            }\n          } else {\n            addr = sock.daddr;\n            port = sock.dport;\n          }\n          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);\n          if (sock.type === 1) {\n            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {\n              throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);\n            } else if (dest.socket.readyState === dest.socket.CONNECTING) {\n              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);\n            }\n          }\n          if (ArrayBuffer.isView(buffer2)) {\n            offset += buffer2.byteOffset;\n            buffer2 = buffer2.buffer;\n          }\n          var data;\n          data = buffer2.slice(offset, offset + length);\n          if (sock.type === 2) {\n            if (!dest || dest.socket.readyState !== dest.socket.OPEN) {\n              if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {\n                dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);\n              }\n              dest.dgram_send_queue.push(data);\n              return length;\n            }\n          }\n          try {\n            dest.socket.send(data);\n            return length;\n          } catch (e) {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n          }\n        },\n        recvmsg: function(sock, length) {\n          if (sock.type === 1 && sock.server) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);\n          }\n          var queued = sock.recv_queue.shift();\n          if (!queued) {\n            if (sock.type === 1) {\n              var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);\n              if (!dest) {\n                throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);\n              } else if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {\n                return null;\n              } else {\n                throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);\n              }\n            } else {\n              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);\n            }\n          }\n          var queuedLength = queued.data.byteLength || queued.data.length;\n          var queuedOffset = queued.data.byteOffset || 0;\n          var queuedBuffer = queued.data.buffer || queued.data;\n          var bytesRead = Math.min(length, queuedLength);\n          var res = {\n            buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),\n            addr: queued.addr,\n            port: queued.port\n          };\n          if (sock.type === 1 && bytesRead < queuedLength) {\n            var bytesRemaining = queuedLength - bytesRead;\n            queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);\n            sock.recv_queue.unshift(queued);\n          }\n          return res;\n        }\n      }\n    };\n    function __inet_pton4_raw(str) {\n      var b = str.split(\".\");\n      for (var i = 0; i < 4; i++) {\n        var tmp = Number(b[i]);\n        if (isNaN(tmp))\n          return null;\n        b[i] = tmp;\n      }\n      return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;\n    }\n    function jstoi_q(str) {\n      return parseInt(str, void 0);\n    }\n    function __inet_pton6_raw(str) {\n      var words;\n      var w, offset, z;\n      var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\\dA-F]{1,4}:(:|\\b)|){5}|([\\dA-F]{1,4}:){6})((([\\dA-F]{1,4}((?!\\3)::|:\\b|$))|(?!\\2\\3)){2}|(((2[0-4]|1\\d|[1-9])?\\d|25[0-5])\\.?\\b){4})$/i;\n      var parts = [];\n      if (!valid6regx.test(str)) {\n        return null;\n      }\n      if (str === \"::\") {\n        return [0, 0, 0, 0, 0, 0, 0, 0];\n      }\n      if (str.indexOf(\"::\") === 0) {\n        str = str.replace(\"::\", \"Z:\");\n      } else {\n        str = str.replace(\"::\", \":Z:\");\n      }\n      if (str.indexOf(\".\") > 0) {\n        str = str.replace(new RegExp(\"[.]\", \"g\"), \":\");\n        words = str.split(\":\");\n        words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;\n        words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;\n        words = words.slice(0, words.length - 2);\n      } else {\n        words = str.split(\":\");\n      }\n      offset = 0;\n      z = 0;\n      for (w = 0; w < words.length; w++) {\n        if (typeof words[w] === \"string\") {\n          if (words[w] === \"Z\") {\n            for (z = 0; z < 8 - words.length + 1; z++) {\n              parts[w + z] = 0;\n            }\n            offset = z - 1;\n          } else {\n            parts[w + offset] = _htons(parseInt(words[w], 16));\n          }\n        } else {\n          parts[w + offset] = words[w];\n        }\n      }\n      return [\n        parts[1] << 16 | parts[0],\n        parts[3] << 16 | parts[2],\n        parts[5] << 16 | parts[4],\n        parts[7] << 16 | parts[6]\n      ];\n    }\n    var DNS = {\n      address_map: { id: 1, addrs: {}, names: {} },\n      lookup_name: function(name) {\n        var res = __inet_pton4_raw(name);\n        if (res !== null) {\n          return name;\n        }\n        res = __inet_pton6_raw(name);\n        if (res !== null) {\n          return name;\n        }\n        var addr;\n        if (DNS.address_map.addrs[name]) {\n          addr = DNS.address_map.addrs[name];\n        } else {\n          var id = DNS.address_map.id++;\n          assert(id < 65535, \"exceeded max address mappings of 65535\");\n          addr = \"172.29.\" + (id & 255) + \".\" + (id & 65280);\n          DNS.address_map.names[addr] = name;\n          DNS.address_map.addrs[name] = addr;\n        }\n        return addr;\n      },\n      lookup_addr: function(addr) {\n        if (DNS.address_map.names[addr]) {\n          return DNS.address_map.names[addr];\n        }\n        return null;\n      }\n    };\n    function __inet_ntop4_raw(addr) {\n      return (addr & 255) + \".\" + (addr >> 8 & 255) + \".\" + (addr >> 16 & 255) + \".\" + (addr >> 24 & 255);\n    }\n    function __inet_ntop6_raw(ints) {\n      var str = \"\";\n      var word = 0;\n      var longest = 0;\n      var lastzero = 0;\n      var zstart = 0;\n      var len = 0;\n      var i = 0;\n      var parts = [\n        ints[0] & 65535,\n        ints[0] >> 16,\n        ints[1] & 65535,\n        ints[1] >> 16,\n        ints[2] & 65535,\n        ints[2] >> 16,\n        ints[3] & 65535,\n        ints[3] >> 16\n      ];\n      var hasipv4 = true;\n      var v4part = \"\";\n      for (i = 0; i < 5; i++) {\n        if (parts[i] !== 0) {\n          hasipv4 = false;\n          break;\n        }\n      }\n      if (hasipv4) {\n        v4part = __inet_ntop4_raw(parts[6] | parts[7] << 16);\n        if (parts[5] === -1) {\n          str = \"::ffff:\";\n          str += v4part;\n          return str;\n        }\n        if (parts[5] === 0) {\n          str = \"::\";\n          if (v4part === \"0.0.0.0\")\n            v4part = \"\";\n          if (v4part === \"0.0.0.1\")\n            v4part = \"1\";\n          str += v4part;\n          return str;\n        }\n      }\n      for (word = 0; word < 8; word++) {\n        if (parts[word] === 0) {\n          if (word - lastzero > 1) {\n            len = 0;\n          }\n          lastzero = word;\n          len++;\n        }\n        if (len > longest) {\n          longest = len;\n          zstart = word - longest + 1;\n        }\n      }\n      for (word = 0; word < 8; word++) {\n        if (longest > 1) {\n          if (parts[word] === 0 && word >= zstart && word < zstart + longest) {\n            if (word === zstart) {\n              str += \":\";\n              if (zstart === 0)\n                str += \":\";\n            }\n            continue;\n          }\n        }\n        str += Number(_ntohs(parts[word] & 65535)).toString(16);\n        str += word < 7 ? \":\" : \"\";\n      }\n      return str;\n    }\n    function __read_sockaddr(sa, salen) {\n      var family = HEAP16[sa >> 1];\n      var port = _ntohs(HEAPU16[sa + 2 >> 1]);\n      var addr;\n      switch (family) {\n        case 2:\n          if (salen !== 16) {\n            return { errno: 28 };\n          }\n          addr = HEAP32[sa + 4 >> 2];\n          addr = __inet_ntop4_raw(addr);\n          break;\n        case 10:\n          if (salen !== 28) {\n            return { errno: 28 };\n          }\n          addr = [\n            HEAP32[sa + 8 >> 2],\n            HEAP32[sa + 12 >> 2],\n            HEAP32[sa + 16 >> 2],\n            HEAP32[sa + 20 >> 2]\n          ];\n          addr = __inet_ntop6_raw(addr);\n          break;\n        default:\n          return { errno: 5 };\n      }\n      return { family, addr, port };\n    }\n    function __write_sockaddr(sa, family, addr, port) {\n      switch (family) {\n        case 2:\n          addr = __inet_pton4_raw(addr);\n          HEAP16[sa >> 1] = family;\n          HEAP32[sa + 4 >> 2] = addr;\n          HEAP16[sa + 2 >> 1] = _htons(port);\n          break;\n        case 10:\n          addr = __inet_pton6_raw(addr);\n          HEAP32[sa >> 2] = family;\n          HEAP32[sa + 8 >> 2] = addr[0];\n          HEAP32[sa + 12 >> 2] = addr[1];\n          HEAP32[sa + 16 >> 2] = addr[2];\n          HEAP32[sa + 20 >> 2] = addr[3];\n          HEAP16[sa + 2 >> 1] = _htons(port);\n          HEAP32[sa + 4 >> 2] = 0;\n          HEAP32[sa + 24 >> 2] = 0;\n          break;\n        default:\n          return { errno: 5 };\n      }\n      return {};\n    }\n    var SYSCALLS = {\n      mappings: {},\n      DEFAULT_POLLMASK: 5,\n      umask: 511,\n      calculateAt: function(dirfd, path) {\n        if (path[0] !== \"/\") {\n          var dir;\n          if (dirfd === -100) {\n            dir = FS.cwd();\n          } else {\n            var dirstream = FS.getStream(dirfd);\n            if (!dirstream)\n              throw new FS.ErrnoError(8);\n            dir = dirstream.path;\n          }\n          path = PATH.join2(dir, path);\n        }\n        return path;\n      },\n      doStat: function(func, path, buf) {\n        try {\n          var stat = func(path);\n        } catch (e) {\n          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\n            return -54;\n          }\n          throw e;\n        }\n        HEAP32[buf >> 2] = stat.dev;\n        HEAP32[buf + 4 >> 2] = 0;\n        HEAP32[buf + 8 >> 2] = stat.ino;\n        HEAP32[buf + 12 >> 2] = stat.mode;\n        HEAP32[buf + 16 >> 2] = stat.nlink;\n        HEAP32[buf + 20 >> 2] = stat.uid;\n        HEAP32[buf + 24 >> 2] = stat.gid;\n        HEAP32[buf + 28 >> 2] = stat.rdev;\n        HEAP32[buf + 32 >> 2] = 0;\n        tempI64 = [\n          stat.size >>> 0,\n          (tempDouble = stat.size, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n        ], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];\n        HEAP32[buf + 48 >> 2] = 4096;\n        HEAP32[buf + 52 >> 2] = stat.blocks;\n        HEAP32[buf + 56 >> 2] = stat.atime.getTime() / 1e3 | 0;\n        HEAP32[buf + 60 >> 2] = 0;\n        HEAP32[buf + 64 >> 2] = stat.mtime.getTime() / 1e3 | 0;\n        HEAP32[buf + 68 >> 2] = 0;\n        HEAP32[buf + 72 >> 2] = stat.ctime.getTime() / 1e3 | 0;\n        HEAP32[buf + 76 >> 2] = 0;\n        tempI64 = [\n          stat.ino >>> 0,\n          (tempDouble = stat.ino, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n        ], HEAP32[buf + 80 >> 2] = tempI64[0], HEAP32[buf + 84 >> 2] = tempI64[1];\n        return 0;\n      },\n      doMsync: function(addr, stream, len, flags, offset) {\n        var buffer2 = HEAPU8.slice(addr, addr + len);\n        FS.msync(stream, buffer2, offset, len, flags);\n      },\n      doMkdir: function(path, mode) {\n        path = PATH.normalize(path);\n        if (path[path.length - 1] === \"/\")\n          path = path.substr(0, path.length - 1);\n        FS.mkdir(path, mode, 0);\n        return 0;\n      },\n      doMknod: function(path, mode, dev) {\n        switch (mode & 61440) {\n          case 32768:\n          case 8192:\n          case 24576:\n          case 4096:\n          case 49152:\n            break;\n          default:\n            return -28;\n        }\n        FS.mknod(path, mode, dev);\n        return 0;\n      },\n      doReadlink: function(path, buf, bufsize) {\n        if (bufsize <= 0)\n          return -28;\n        var ret = FS.readlink(path);\n        var len = Math.min(bufsize, lengthBytesUTF8(ret));\n        var endChar = HEAP8[buf + len];\n        stringToUTF8(ret, buf, bufsize + 1);\n        HEAP8[buf + len] = endChar;\n        return len;\n      },\n      doAccess: function(path, amode) {\n        if (amode & ~7) {\n          return -28;\n        }\n        var node;\n        var lookup = FS.lookupPath(path, { follow: true });\n        node = lookup.node;\n        if (!node) {\n          return -44;\n        }\n        var perms = \"\";\n        if (amode & 4)\n          perms += \"r\";\n        if (amode & 2)\n          perms += \"w\";\n        if (amode & 1)\n          perms += \"x\";\n        if (perms && FS.nodePermissions(node, perms)) {\n          return -2;\n        }\n        return 0;\n      },\n      doDup: function(path, flags, suggestFD) {\n        var suggest = FS.getStream(suggestFD);\n        if (suggest)\n          FS.close(suggest);\n        return FS.open(path, flags, 0, suggestFD, suggestFD).fd;\n      },\n      doReadv: function(stream, iov, iovcnt, offset) {\n        var ret = 0;\n        for (var i = 0; i < iovcnt; i++) {\n          var ptr = HEAP32[iov + i * 8 >> 2];\n          var len = HEAP32[iov + (i * 8 + 4) >> 2];\n          var curr = FS.read(stream, HEAP8, ptr, len, offset);\n          if (curr < 0)\n            return -1;\n          ret += curr;\n          if (curr < len)\n            break;\n        }\n        return ret;\n      },\n      doWritev: function(stream, iov, iovcnt, offset) {\n        var ret = 0;\n        for (var i = 0; i < iovcnt; i++) {\n          var ptr = HEAP32[iov + i * 8 >> 2];\n          var len = HEAP32[iov + (i * 8 + 4) >> 2];\n          var curr = FS.write(stream, HEAP8, ptr, len, offset);\n          if (curr < 0)\n            return -1;\n          ret += curr;\n        }\n        return ret;\n      },\n      varargs: void 0,\n      get: function() {\n        assert(SYSCALLS.varargs != void 0);\n        SYSCALLS.varargs += 4;\n        var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];\n        return ret;\n      },\n      getStr: function(ptr) {\n        var ret = UTF8ToString(ptr);\n        return ret;\n      },\n      getStreamFromFD: function(fd) {\n        var stream = FS.getStream(fd);\n        if (!stream)\n          throw new FS.ErrnoError(8);\n        return stream;\n      },\n      get64: function(low, high) {\n        if (low >= 0)\n          assert(high === 0);\n        else\n          assert(high === -1);\n        return low;\n      }\n    };\n    function ___syscall102(call, socketvararg) {\n      try {\n        SYSCALLS.varargs = socketvararg;\n        var getSocketFromFD = function() {\n          var socket = SOCKFS.getSocket(SYSCALLS.get());\n          if (!socket)\n            throw new FS.ErrnoError(8);\n          return socket;\n        };\n        var getSocketAddress = function(allowNull) {\n          var addrp = SYSCALLS.get(), addrlen2 = SYSCALLS.get();\n          if (allowNull && addrp === 0)\n            return null;\n          var info2 = __read_sockaddr(addrp, addrlen2);\n          if (info2.errno)\n            throw new FS.ErrnoError(info2.errno);\n          info2.addr = DNS.lookup_addr(info2.addr) || info2.addr;\n          return info2;\n        };\n        switch (call) {\n          case 1: {\n            var domain = SYSCALLS.get(), type = SYSCALLS.get(), protocol = SYSCALLS.get();\n            var sock = SOCKFS.createSocket(domain, type, protocol);\n            assert(sock.stream.fd < 64);\n            return sock.stream.fd;\n          }\n          case 2: {\n            var sock = getSocketFromFD(), info = getSocketAddress();\n            sock.sock_ops.bind(sock, info.addr, info.port);\n            return 0;\n          }\n          case 3: {\n            var sock = getSocketFromFD(), info = getSocketAddress();\n            sock.sock_ops.connect(sock, info.addr, info.port);\n            return 0;\n          }\n          case 4: {\n            var sock = getSocketFromFD(), backlog = SYSCALLS.get();\n            sock.sock_ops.listen(sock, backlog);\n            return 0;\n          }\n          case 5: {\n            var sock = getSocketFromFD(), addr = SYSCALLS.get(), addrlen = SYSCALLS.get();\n            var newsock = sock.sock_ops.accept(sock);\n            if (addr) {\n              var res = __write_sockaddr(addr, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport);\n              assert(!res.errno);\n            }\n            return newsock.stream.fd;\n          }\n          case 6: {\n            var sock = getSocketFromFD(), addr = SYSCALLS.get(), addrlen = SYSCALLS.get();\n            var res = __write_sockaddr(addr, sock.family, DNS.lookup_name(sock.saddr || \"0.0.0.0\"), sock.sport);\n            assert(!res.errno);\n            return 0;\n          }\n          case 7: {\n            var sock = getSocketFromFD(), addr = SYSCALLS.get(), addrlen = SYSCALLS.get();\n            if (!sock.daddr) {\n              return -53;\n            }\n            var res = __write_sockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport);\n            assert(!res.errno);\n            return 0;\n          }\n          case 11: {\n            var sock = getSocketFromFD(), message = SYSCALLS.get(), length = SYSCALLS.get(), flags = SYSCALLS.get(), dest = getSocketAddress(true);\n            if (!dest) {\n              return FS.write(sock.stream, HEAP8, message, length);\n            } else {\n              return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port);\n            }\n          }\n          case 12: {\n            var sock = getSocketFromFD(), buf = SYSCALLS.get(), len = SYSCALLS.get(), flags = SYSCALLS.get(), addr = SYSCALLS.get(), addrlen = SYSCALLS.get();\n            var msg = sock.sock_ops.recvmsg(sock, len);\n            if (!msg)\n              return 0;\n            if (addr) {\n              var res = __write_sockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port);\n              assert(!res.errno);\n            }\n            HEAPU8.set(msg.buffer, buf);\n            return msg.buffer.byteLength;\n          }\n          case 14: {\n            return -50;\n          }\n          case 15: {\n            var sock = getSocketFromFD(), level = SYSCALLS.get(), optname = SYSCALLS.get(), optval = SYSCALLS.get(), optlen = SYSCALLS.get();\n            if (level === 1) {\n              if (optname === 4) {\n                HEAP32[optval >> 2] = sock.error;\n                HEAP32[optlen >> 2] = 4;\n                sock.error = null;\n                return 0;\n              }\n            }\n            return -50;\n          }\n          case 16: {\n            var sock = getSocketFromFD(), message = SYSCALLS.get(), flags = SYSCALLS.get();\n            var iov = HEAP32[message + 8 >> 2];\n            var num = HEAP32[message + 12 >> 2];\n            var addr, port;\n            var name = HEAP32[message >> 2];\n            var namelen = HEAP32[message + 4 >> 2];\n            if (name) {\n              var info = __read_sockaddr(name, namelen);\n              if (info.errno)\n                return -info.errno;\n              port = info.port;\n              addr = DNS.lookup_addr(info.addr) || info.addr;\n            }\n            var total = 0;\n            for (var i = 0; i < num; i++) {\n              total += HEAP32[iov + (8 * i + 4) >> 2];\n            }\n            var view = new Uint8Array(total);\n            var offset = 0;\n            for (var i = 0; i < num; i++) {\n              var iovbase = HEAP32[iov + (8 * i + 0) >> 2];\n              var iovlen = HEAP32[iov + (8 * i + 4) >> 2];\n              for (var j = 0; j < iovlen; j++) {\n                view[offset++] = HEAP8[iovbase + j >> 0];\n              }\n            }\n            return sock.sock_ops.sendmsg(sock, view, 0, total, addr, port);\n          }\n          case 17: {\n            var sock = getSocketFromFD(), message = SYSCALLS.get(), flags = SYSCALLS.get();\n            var iov = HEAP32[message + 8 >> 2];\n            var num = HEAP32[message + 12 >> 2];\n            var total = 0;\n            for (var i = 0; i < num; i++) {\n              total += HEAP32[iov + (8 * i + 4) >> 2];\n            }\n            var msg = sock.sock_ops.recvmsg(sock, total);\n            if (!msg)\n              return 0;\n            var name = HEAP32[message >> 2];\n            if (name) {\n              var res = __write_sockaddr(name, sock.family, DNS.lookup_name(msg.addr), msg.port);\n              assert(!res.errno);\n            }\n            var bytesRead = 0;\n            var bytesRemaining = msg.buffer.byteLength;\n            for (var i = 0; bytesRemaining > 0 && i < num; i++) {\n              var iovbase = HEAP32[iov + (8 * i + 0) >> 2];\n              var iovlen = HEAP32[iov + (8 * i + 4) >> 2];\n              if (!iovlen) {\n                continue;\n              }\n              var length = Math.min(iovlen, bytesRemaining);\n              var buf = msg.buffer.subarray(bytesRead, bytesRead + length);\n              HEAPU8.set(buf, iovbase + bytesRead);\n              bytesRead += length;\n              bytesRemaining -= length;\n            }\n            return bytesRead;\n          }\n          default: {\n            return -52;\n          }\n        }\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError))\n          abort(e);\n        return -e.errno;\n      }\n    }\n    function ___syscall12(path) {\n      try {\n        path = SYSCALLS.getStr(path);\n        FS.chdir(path);\n        return 0;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError))\n          abort(e);\n        return -e.errno;\n      }\n    }\n    function ___syscall142(nfds, readfds, writefds, exceptfds, timeout) {\n      try {\n        assert(nfds <= 64, \"nfds must be less than or equal to 64\");\n        assert(!exceptfds, \"exceptfds not supported\");\n        var total = 0;\n        var srcReadLow = readfds ? HEAP32[readfds >> 2] : 0, srcReadHigh = readfds ? HEAP32[readfds + 4 >> 2] : 0;\n        var srcWriteLow = writefds ? HEAP32[writefds >> 2] : 0, srcWriteHigh = writefds ? HEAP32[writefds + 4 >> 2] : 0;\n        var srcExceptLow = exceptfds ? HEAP32[exceptfds >> 2] : 0, srcExceptHigh = exceptfds ? HEAP32[exceptfds + 4 >> 2] : 0;\n        var dstReadLow = 0, dstReadHigh = 0;\n        var dstWriteLow = 0, dstWriteHigh = 0;\n        var dstExceptLow = 0, dstExceptHigh = 0;\n        var allLow = (readfds ? HEAP32[readfds >> 2] : 0) | (writefds ? HEAP32[writefds >> 2] : 0) | (exceptfds ? HEAP32[exceptfds >> 2] : 0);\n        var allHigh = (readfds ? HEAP32[readfds + 4 >> 2] : 0) | (writefds ? HEAP32[writefds + 4 >> 2] : 0) | (exceptfds ? HEAP32[exceptfds + 4 >> 2] : 0);\n        var check = function(fd2, low, high, val) {\n          return fd2 < 32 ? low & val : high & val;\n        };\n        for (var fd = 0; fd < nfds; fd++) {\n          var mask = 1 << fd % 32;\n          if (!check(fd, allLow, allHigh, mask)) {\n            continue;\n          }\n          var stream = FS.getStream(fd);\n          if (!stream)\n            throw new FS.ErrnoError(8);\n          var flags = SYSCALLS.DEFAULT_POLLMASK;\n          if (stream.stream_ops.poll) {\n            flags = stream.stream_ops.poll(stream);\n          }\n          if (flags & 1 && check(fd, srcReadLow, srcReadHigh, mask)) {\n            fd < 32 ? dstReadLow = dstReadLow | mask : dstReadHigh = dstReadHigh | mask;\n            total++;\n          }\n          if (flags & 4 && check(fd, srcWriteLow, srcWriteHigh, mask)) {\n            fd < 32 ? dstWriteLow = dstWriteLow | mask : dstWriteHigh = dstWriteHigh | mask;\n            total++;\n          }\n          if (flags & 2 && check(fd, srcExceptLow, srcExceptHigh, mask)) {\n            fd < 32 ? dstExceptLow = dstExceptLow | mask : dstExceptHigh = dstExceptHigh | mask;\n            total++;\n          }\n        }\n        if (readfds) {\n          HEAP32[readfds >> 2] = dstReadLow;\n          HEAP32[readfds + 4 >> 2] = dstReadHigh;\n        }\n        if (writefds) {\n          HEAP32[writefds >> 2] = dstWriteLow;\n          HEAP32[writefds + 4 >> 2] = dstWriteHigh;\n        }\n        if (exceptfds) {\n          HEAP32[exceptfds >> 2] = dstExceptLow;\n          HEAP32[exceptfds + 4 >> 2] = dstExceptHigh;\n        }\n        return total;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError))\n          abort(e);\n        return -e.errno;\n      }\n    }\n    function ___syscall183(buf, size) {\n      try {\n        if (size === 0)\n          return -28;\n        var cwd = FS.cwd();\n        var cwdLengthInBytes = lengthBytesUTF8(cwd);\n        if (size < cwdLengthInBytes + 1)\n          return -68;\n        stringToUTF8(cwd, buf, size);\n        return buf;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError))\n          abort(e);\n        return -e.errno;\n      }\n    }\n    function ___syscall195(path, buf) {\n      try {\n        path = SYSCALLS.getStr(path);\n        return SYSCALLS.doStat(FS.stat, path, buf);\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError))\n          abort(e);\n        return -e.errno;\n      }\n    }\n    function ___syscall197(fd, buf) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        return SYSCALLS.doStat(FS.stat, stream.path, buf);\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError))\n          abort(e);\n        return -e.errno;\n      }\n    }\n    function ___syscall221(fd, cmd, varargs) {\n      SYSCALLS.varargs = varargs;\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        switch (cmd) {\n          case 0: {\n            var arg = SYSCALLS.get();\n            if (arg < 0) {\n              return -28;\n            }\n            var newStream;\n            newStream = FS.open(stream.path, stream.flags, 0, arg);\n            return newStream.fd;\n          }\n          case 1:\n          case 2:\n            return 0;\n          case 3:\n            return stream.flags;\n          case 4: {\n            var arg = SYSCALLS.get();\n            stream.flags |= arg;\n            return 0;\n          }\n          case 12: {\n            var arg = SYSCALLS.get();\n            var offset = 0;\n            HEAP16[arg + offset >> 1] = 2;\n            return 0;\n          }\n          case 13:\n          case 14:\n            return 0;\n          case 16:\n          case 8:\n            return -28;\n          case 9:\n            ___setErrNo(28);\n            return -1;\n          default: {\n            return -28;\n          }\n        }\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError))\n          abort(e);\n        return -e.errno;\n      }\n    }\n    function ___syscall3(fd, buf, count) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        return FS.read(stream, HEAP8, buf, count);\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError))\n          abort(e);\n        return -e.errno;\n      }\n    }\n    function ___syscall39(path, mode) {\n      try {\n        path = SYSCALLS.getStr(path);\n        return SYSCALLS.doMkdir(path, mode);\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError))\n          abort(e);\n        return -e.errno;\n      }\n    }\n    function ___syscall5(path, flags, varargs) {\n      SYSCALLS.varargs = varargs;\n      try {\n        var pathname = SYSCALLS.getStr(path);\n        var mode = SYSCALLS.get();\n        var stream = FS.open(pathname, flags, mode);\n        return stream.fd;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError))\n          abort(e);\n        return -e.errno;\n      }\n    }\n    function ___syscall54(fd, op, varargs) {\n      SYSCALLS.varargs = varargs;\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        switch (op) {\n          case 21509:\n          case 21505: {\n            if (!stream.tty)\n              return -59;\n            return 0;\n          }\n          case 21510:\n          case 21511:\n          case 21512:\n          case 21506:\n          case 21507:\n          case 21508: {\n            if (!stream.tty)\n              return -59;\n            return 0;\n          }\n          case 21519: {\n            if (!stream.tty)\n              return -59;\n            var argp = SYSCALLS.get();\n            HEAP32[argp >> 2] = 0;\n            return 0;\n          }\n          case 21520: {\n            if (!stream.tty)\n              return -59;\n            return -28;\n          }\n          case 21531: {\n            var argp = SYSCALLS.get();\n            return FS.ioctl(stream, op, argp);\n          }\n          case 21523: {\n            if (!stream.tty)\n              return -59;\n            return 0;\n          }\n          case 21524: {\n            if (!stream.tty)\n              return -59;\n            return 0;\n          }\n          default:\n            abort(\"bad ioctl syscall \" + op);\n        }\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError))\n          abort(e);\n        return -e.errno;\n      }\n    }\n    function ___syscall85(path, buf, bufsize) {\n      try {\n        path = SYSCALLS.getStr(path);\n        return SYSCALLS.doReadlink(path, buf, bufsize);\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError))\n          abort(e);\n        return -e.errno;\n      }\n    }\n    function syscallMunmap(addr, len) {\n      if (addr === -1 || len === 0) {\n        return -28;\n      }\n      var info = SYSCALLS.mappings[addr];\n      if (!info)\n        return 0;\n      if (len === info.len) {\n        var stream = FS.getStream(info.fd);\n        SYSCALLS.doMsync(addr, stream, len, info.flags, info.offset);\n        FS.munmap(stream);\n        SYSCALLS.mappings[addr] = null;\n        if (info.allocated) {\n          _free(info.malloc);\n        }\n      }\n      return 0;\n    }\n    function ___syscall91(addr, len) {\n      try {\n        return syscallMunmap(addr, len);\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError))\n          abort(e);\n        return -e.errno;\n      }\n    }\n    function getShiftFromSize(size) {\n      switch (size) {\n        case 1:\n          return 0;\n        case 2:\n          return 1;\n        case 4:\n          return 2;\n        case 8:\n          return 3;\n        default:\n          throw new TypeError(\"Unknown type size: \" + size);\n      }\n    }\n    function embind_init_charCodes() {\n      var codes = new Array(256);\n      for (var i = 0; i < 256; ++i) {\n        codes[i] = String.fromCharCode(i);\n      }\n      embind_charCodes = codes;\n    }\n    var embind_charCodes = void 0;\n    function readLatin1String(ptr) {\n      var ret = \"\";\n      var c = ptr;\n      while (HEAPU8[c]) {\n        ret += embind_charCodes[HEAPU8[c++]];\n      }\n      return ret;\n    }\n    var awaitingDependencies = {};\n    var registeredTypes = {};\n    var typeDependencies = {};\n    var char_0 = 48;\n    var char_9 = 57;\n    function makeLegalFunctionName(name) {\n      if (name === void 0) {\n        return \"_unknown\";\n      }\n      name = name.replace(/[^a-zA-Z0-9_]/g, \"$\");\n      var f = name.charCodeAt(0);\n      if (f >= char_0 && f <= char_9) {\n        return \"_\" + name;\n      } else {\n        return name;\n      }\n    }\n    function createNamedFunction(name, body) {\n      name = makeLegalFunctionName(name);\n      return new Function(\"body\", \"return function \" + name + '() {\\n    \"use strict\";    return body.apply(this, arguments);\\n};\\n')(body);\n    }\n    function extendError(baseErrorType, errorName) {\n      var errorClass = createNamedFunction(errorName, function(message) {\n        this.name = errorName;\n        this.message = message;\n        var stack = new Error(message).stack;\n        if (stack !== void 0) {\n          this.stack = this.toString() + \"\\n\" + stack.replace(/^Error(:[^\\n]*)?\\n/, \"\");\n        }\n      });\n      errorClass.prototype = Object.create(baseErrorType.prototype);\n      errorClass.prototype.constructor = errorClass;\n      errorClass.prototype.toString = function() {\n        if (this.message === void 0) {\n          return this.name;\n        } else {\n          return this.name + \": \" + this.message;\n        }\n      };\n      return errorClass;\n    }\n    var BindingError = void 0;\n    function throwBindingError(message) {\n      throw new BindingError(message);\n    }\n    var InternalError = void 0;\n    function throwInternalError(message) {\n      throw new InternalError(message);\n    }\n    function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {\n      myTypes.forEach(function(type) {\n        typeDependencies[type] = dependentTypes;\n      });\n      function onComplete(typeConverters2) {\n        var myTypeConverters = getTypeConverters(typeConverters2);\n        if (myTypeConverters.length !== myTypes.length) {\n          throwInternalError(\"Mismatched type converter count\");\n        }\n        for (var i = 0; i < myTypes.length; ++i) {\n          registerType(myTypes[i], myTypeConverters[i]);\n        }\n      }\n      var typeConverters = new Array(dependentTypes.length);\n      var unregisteredTypes = [];\n      var registered = 0;\n      dependentTypes.forEach(function(dt, i) {\n        if (registeredTypes.hasOwnProperty(dt)) {\n          typeConverters[i] = registeredTypes[dt];\n        } else {\n          unregisteredTypes.push(dt);\n          if (!awaitingDependencies.hasOwnProperty(dt)) {\n            awaitingDependencies[dt] = [];\n          }\n          awaitingDependencies[dt].push(function() {\n            typeConverters[i] = registeredTypes[dt];\n            ++registered;\n            if (registered === unregisteredTypes.length) {\n              onComplete(typeConverters);\n            }\n          });\n        }\n      });\n      if (unregisteredTypes.length === 0) {\n        onComplete(typeConverters);\n      }\n    }\n    function registerType(rawType, registeredInstance, options) {\n      options = options || {};\n      if (!(\"argPackAdvance\" in registeredInstance)) {\n        throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");\n      }\n      var name = registeredInstance.name;\n      if (!rawType) {\n        throwBindingError('type \"' + name + '\" must have a positive integer typeid pointer');\n      }\n      if (registeredTypes.hasOwnProperty(rawType)) {\n        if (options.ignoreDuplicateRegistrations) {\n          return;\n        } else {\n          throwBindingError(\"Cannot register type '\" + name + \"' twice\");\n        }\n      }\n      registeredTypes[rawType] = registeredInstance;\n      delete typeDependencies[rawType];\n      if (awaitingDependencies.hasOwnProperty(rawType)) {\n        var callbacks = awaitingDependencies[rawType];\n        delete awaitingDependencies[rawType];\n        callbacks.forEach(function(cb) {\n          cb();\n        });\n      }\n    }\n    function __embind_register_bool(rawType, name, size, trueValue, falseValue) {\n      var shift = getShiftFromSize(size);\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name,\n        fromWireType: function(wt) {\n          return !!wt;\n        },\n        toWireType: function(destructors, o) {\n          return o ? trueValue : falseValue;\n        },\n        argPackAdvance: 8,\n        readValueFromPointer: function(pointer) {\n          var heap;\n          if (size === 1) {\n            heap = HEAP8;\n          } else if (size === 2) {\n            heap = HEAP16;\n          } else if (size === 4) {\n            heap = HEAP32;\n          } else {\n            throw new TypeError(\"Unknown boolean type size: \" + name);\n          }\n          return this[\"fromWireType\"](heap[pointer >> shift]);\n        },\n        destructorFunction: null\n      });\n    }\n    function ClassHandle_isAliasOf(other) {\n      if (!(this instanceof ClassHandle)) {\n        return false;\n      }\n      if (!(other instanceof ClassHandle)) {\n        return false;\n      }\n      var leftClass = this.$$.ptrType.registeredClass;\n      var left = this.$$.ptr;\n      var rightClass = other.$$.ptrType.registeredClass;\n      var right = other.$$.ptr;\n      while (leftClass.baseClass) {\n        left = leftClass.upcast(left);\n        leftClass = leftClass.baseClass;\n      }\n      while (rightClass.baseClass) {\n        right = rightClass.upcast(right);\n        rightClass = rightClass.baseClass;\n      }\n      return leftClass === rightClass && left === right;\n    }\n    function shallowCopyInternalPointer(o) {\n      return {\n        count: o.count,\n        deleteScheduled: o.deleteScheduled,\n        preservePointerOnDelete: o.preservePointerOnDelete,\n        ptr: o.ptr,\n        ptrType: o.ptrType,\n        smartPtr: o.smartPtr,\n        smartPtrType: o.smartPtrType\n      };\n    }\n    function throwInstanceAlreadyDeleted(obj) {\n      function getInstanceTypeName(handle) {\n        return handle.$$.ptrType.registeredClass.name;\n      }\n      throwBindingError(getInstanceTypeName(obj) + \" instance already deleted\");\n    }\n    var finalizationGroup = false;\n    function detachFinalizer(handle) {\n    }\n    function runDestructor($$) {\n      if ($$.smartPtr) {\n        $$.smartPtrType.rawDestructor($$.smartPtr);\n      } else {\n        $$.ptrType.registeredClass.rawDestructor($$.ptr);\n      }\n    }\n    function releaseClassHandle($$) {\n      $$.count.value -= 1;\n      var toDelete = $$.count.value === 0;\n      if (toDelete) {\n        runDestructor($$);\n      }\n    }\n    function attachFinalizer(handle) {\n      if (typeof FinalizationGroup === \"undefined\") {\n        attachFinalizer = function(handle2) {\n          return handle2;\n        };\n        return handle;\n      }\n      finalizationGroup = new FinalizationGroup(function(iter) {\n        for (var result = iter.next(); !result.done; result = iter.next()) {\n          var $$ = result.value;\n          if (!$$.ptr) {\n            console.warn(\"object already deleted: \" + $$.ptr);\n          } else {\n            releaseClassHandle($$);\n          }\n        }\n      });\n      attachFinalizer = function(handle2) {\n        finalizationGroup.register(handle2, handle2.$$, handle2.$$);\n        return handle2;\n      };\n      detachFinalizer = function(handle2) {\n        finalizationGroup.unregister(handle2.$$);\n      };\n      return attachFinalizer(handle);\n    }\n    function ClassHandle_clone() {\n      if (!this.$$.ptr) {\n        throwInstanceAlreadyDeleted(this);\n      }\n      if (this.$$.preservePointerOnDelete) {\n        this.$$.count.value += 1;\n        return this;\n      } else {\n        var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {\n          $$: { value: shallowCopyInternalPointer(this.$$) }\n        }));\n        clone.$$.count.value += 1;\n        clone.$$.deleteScheduled = false;\n        return clone;\n      }\n    }\n    function ClassHandle_delete() {\n      if (!this.$$.ptr) {\n        throwInstanceAlreadyDeleted(this);\n      }\n      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n        throwBindingError(\"Object already scheduled for deletion\");\n      }\n      detachFinalizer(this);\n      releaseClassHandle(this.$$);\n      if (!this.$$.preservePointerOnDelete) {\n        this.$$.smartPtr = void 0;\n        this.$$.ptr = void 0;\n      }\n    }\n    function ClassHandle_isDeleted() {\n      return !this.$$.ptr;\n    }\n    var delayFunction = void 0;\n    var deletionQueue = [];\n    function flushPendingDeletes() {\n      while (deletionQueue.length) {\n        var obj = deletionQueue.pop();\n        obj.$$.deleteScheduled = false;\n        obj[\"delete\"]();\n      }\n    }\n    function ClassHandle_deleteLater() {\n      if (!this.$$.ptr) {\n        throwInstanceAlreadyDeleted(this);\n      }\n      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n        throwBindingError(\"Object already scheduled for deletion\");\n      }\n      deletionQueue.push(this);\n      if (deletionQueue.length === 1 && delayFunction) {\n        delayFunction(flushPendingDeletes);\n      }\n      this.$$.deleteScheduled = true;\n      return this;\n    }\n    function init_ClassHandle() {\n      ClassHandle.prototype[\"isAliasOf\"] = ClassHandle_isAliasOf;\n      ClassHandle.prototype[\"clone\"] = ClassHandle_clone;\n      ClassHandle.prototype[\"delete\"] = ClassHandle_delete;\n      ClassHandle.prototype[\"isDeleted\"] = ClassHandle_isDeleted;\n      ClassHandle.prototype[\"deleteLater\"] = ClassHandle_deleteLater;\n    }\n    function ClassHandle() {\n    }\n    var registeredPointers = {};\n    function ensureOverloadTable(proto, methodName, humanName) {\n      if (proto[methodName].overloadTable === void 0) {\n        var prevFunc = proto[methodName];\n        proto[methodName] = function() {\n          if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {\n            throwBindingError(\"Function '\" + humanName + \"' called with an invalid number of arguments (\" + arguments.length + \") - expects one of (\" + proto[methodName].overloadTable + \")!\");\n          }\n          return proto[methodName].overloadTable[arguments.length].apply(this, arguments);\n        };\n        proto[methodName].overloadTable = [];\n        proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n      }\n    }\n    function exposePublicSymbol(name, value, numArguments) {\n      if (Module.hasOwnProperty(name)) {\n        if (numArguments === void 0 || Module[name].overloadTable !== void 0 && Module[name].overloadTable[numArguments] !== void 0) {\n          throwBindingError(\"Cannot register public name '\" + name + \"' twice\");\n        }\n        ensureOverloadTable(Module, name, name);\n        if (Module.hasOwnProperty(numArguments)) {\n          throwBindingError(\"Cannot register multiple overloads of a function with the same number of arguments (\" + numArguments + \")!\");\n        }\n        Module[name].overloadTable[numArguments] = value;\n      } else {\n        Module[name] = value;\n        if (numArguments !== void 0) {\n          Module[name].numArguments = numArguments;\n        }\n      }\n    }\n    function RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {\n      this.name = name;\n      this.constructor = constructor;\n      this.instancePrototype = instancePrototype;\n      this.rawDestructor = rawDestructor;\n      this.baseClass = baseClass;\n      this.getActualType = getActualType;\n      this.upcast = upcast;\n      this.downcast = downcast;\n      this.pureVirtualFunctions = [];\n    }\n    function upcastPointer(ptr, ptrClass, desiredClass) {\n      while (ptrClass !== desiredClass) {\n        if (!ptrClass.upcast) {\n          throwBindingError(\"Expected null or instance of \" + desiredClass.name + \", got an instance of \" + ptrClass.name);\n        }\n        ptr = ptrClass.upcast(ptr);\n        ptrClass = ptrClass.baseClass;\n      }\n      return ptr;\n    }\n    function constNoSmartPtrRawPointerToWireType(destructors, handle) {\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError(\"null is not a valid \" + this.name);\n        }\n        return 0;\n      }\n      if (!handle.$$) {\n        throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\n      }\n      if (!handle.$$.ptr) {\n        throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      return ptr;\n    }\n    function genericPointerToWireType(destructors, handle) {\n      var ptr;\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError(\"null is not a valid \" + this.name);\n        }\n        if (this.isSmartPointer) {\n          ptr = this.rawConstructor();\n          if (destructors !== null) {\n            destructors.push(this.rawDestructor, ptr);\n          }\n          return ptr;\n        } else {\n          return 0;\n        }\n      }\n      if (!handle.$$) {\n        throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\n      }\n      if (!handle.$$.ptr) {\n        throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n      }\n      if (!this.isConst && handle.$$.ptrType.isConst) {\n        throwBindingError(\"Cannot convert argument of type \" + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + \" to parameter type \" + this.name);\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      if (this.isSmartPointer) {\n        if (handle.$$.smartPtr === void 0) {\n          throwBindingError(\"Passing raw pointer to smart pointer is illegal\");\n        }\n        switch (this.sharingPolicy) {\n          case 0:\n            if (handle.$$.smartPtrType === this) {\n              ptr = handle.$$.smartPtr;\n            } else {\n              throwBindingError(\"Cannot convert argument of type \" + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + \" to parameter type \" + this.name);\n            }\n            break;\n          case 1:\n            ptr = handle.$$.smartPtr;\n            break;\n          case 2:\n            if (handle.$$.smartPtrType === this) {\n              ptr = handle.$$.smartPtr;\n            } else {\n              var clonedHandle = handle[\"clone\"]();\n              ptr = this.rawShare(ptr, __emval_register(function() {\n                clonedHandle[\"delete\"]();\n              }));\n              if (destructors !== null) {\n                destructors.push(this.rawDestructor, ptr);\n              }\n            }\n            break;\n          default:\n            throwBindingError(\"Unsupporting sharing policy\");\n        }\n      }\n      return ptr;\n    }\n    function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError(\"null is not a valid \" + this.name);\n        }\n        return 0;\n      }\n      if (!handle.$$) {\n        throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\n      }\n      if (!handle.$$.ptr) {\n        throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n      }\n      if (handle.$$.ptrType.isConst) {\n        throwBindingError(\"Cannot convert argument of type \" + handle.$$.ptrType.name + \" to parameter type \" + this.name);\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      return ptr;\n    }\n    function simpleReadValueFromPointer(pointer) {\n      return this[\"fromWireType\"](HEAPU32[pointer >> 2]);\n    }\n    function RegisteredPointer_getPointee(ptr) {\n      if (this.rawGetPointee) {\n        ptr = this.rawGetPointee(ptr);\n      }\n      return ptr;\n    }\n    function RegisteredPointer_destructor(ptr) {\n      if (this.rawDestructor) {\n        this.rawDestructor(ptr);\n      }\n    }\n    function RegisteredPointer_deleteObject(handle) {\n      if (handle !== null) {\n        handle[\"delete\"]();\n      }\n    }\n    function downcastPointer(ptr, ptrClass, desiredClass) {\n      if (ptrClass === desiredClass) {\n        return ptr;\n      }\n      if (desiredClass.baseClass === void 0) {\n        return null;\n      }\n      var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\n      if (rv === null) {\n        return null;\n      }\n      return desiredClass.downcast(rv);\n    }\n    function getInheritedInstanceCount() {\n      return Object.keys(registeredInstances).length;\n    }\n    function getLiveInheritedInstances() {\n      var rv = [];\n      for (var k in registeredInstances) {\n        if (registeredInstances.hasOwnProperty(k)) {\n          rv.push(registeredInstances[k]);\n        }\n      }\n      return rv;\n    }\n    function setDelayFunction(fn) {\n      delayFunction = fn;\n      if (deletionQueue.length && delayFunction) {\n        delayFunction(flushPendingDeletes);\n      }\n    }\n    function init_embind() {\n      Module[\"getInheritedInstanceCount\"] = getInheritedInstanceCount;\n      Module[\"getLiveInheritedInstances\"] = getLiveInheritedInstances;\n      Module[\"flushPendingDeletes\"] = flushPendingDeletes;\n      Module[\"setDelayFunction\"] = setDelayFunction;\n    }\n    var registeredInstances = {};\n    function getBasestPointer(class_, ptr) {\n      if (ptr === void 0) {\n        throwBindingError(\"ptr should not be undefined\");\n      }\n      while (class_.baseClass) {\n        ptr = class_.upcast(ptr);\n        class_ = class_.baseClass;\n      }\n      return ptr;\n    }\n    function getInheritedInstance(class_, ptr) {\n      ptr = getBasestPointer(class_, ptr);\n      return registeredInstances[ptr];\n    }\n    function makeClassHandle(prototype, record) {\n      if (!record.ptrType || !record.ptr) {\n        throwInternalError(\"makeClassHandle requires ptr and ptrType\");\n      }\n      var hasSmartPtrType = !!record.smartPtrType;\n      var hasSmartPtr = !!record.smartPtr;\n      if (hasSmartPtrType !== hasSmartPtr) {\n        throwInternalError(\"Both smartPtrType and smartPtr must be specified\");\n      }\n      record.count = { value: 1 };\n      return attachFinalizer(Object.create(prototype, { $$: { value: record } }));\n    }\n    function RegisteredPointer_fromWireType(ptr) {\n      var rawPointer = this.getPointee(ptr);\n      if (!rawPointer) {\n        this.destructor(ptr);\n        return null;\n      }\n      var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);\n      if (registeredInstance !== void 0) {\n        if (registeredInstance.$$.count.value === 0) {\n          registeredInstance.$$.ptr = rawPointer;\n          registeredInstance.$$.smartPtr = ptr;\n          return registeredInstance[\"clone\"]();\n        } else {\n          var rv = registeredInstance[\"clone\"]();\n          this.destructor(ptr);\n          return rv;\n        }\n      }\n      function makeDefaultHandle() {\n        if (this.isSmartPointer) {\n          return makeClassHandle(this.registeredClass.instancePrototype, {\n            ptrType: this.pointeeType,\n            ptr: rawPointer,\n            smartPtrType: this,\n            smartPtr: ptr\n          });\n        } else {\n          return makeClassHandle(this.registeredClass.instancePrototype, {\n            ptrType: this,\n            ptr\n          });\n        }\n      }\n      var actualType = this.registeredClass.getActualType(rawPointer);\n      var registeredPointerRecord = registeredPointers[actualType];\n      if (!registeredPointerRecord) {\n        return makeDefaultHandle.call(this);\n      }\n      var toType;\n      if (this.isConst) {\n        toType = registeredPointerRecord.constPointerType;\n      } else {\n        toType = registeredPointerRecord.pointerType;\n      }\n      var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);\n      if (dp === null) {\n        return makeDefaultHandle.call(this);\n      }\n      if (this.isSmartPointer) {\n        return makeClassHandle(toType.registeredClass.instancePrototype, {\n          ptrType: toType,\n          ptr: dp,\n          smartPtrType: this,\n          smartPtr: ptr\n        });\n      } else {\n        return makeClassHandle(toType.registeredClass.instancePrototype, {\n          ptrType: toType,\n          ptr: dp\n        });\n      }\n    }\n    function init_RegisteredPointer() {\n      RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;\n      RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;\n      RegisteredPointer.prototype[\"argPackAdvance\"] = 8;\n      RegisteredPointer.prototype[\"readValueFromPointer\"] = simpleReadValueFromPointer;\n      RegisteredPointer.prototype[\"deleteObject\"] = RegisteredPointer_deleteObject;\n      RegisteredPointer.prototype[\"fromWireType\"] = RegisteredPointer_fromWireType;\n    }\n    function RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {\n      this.name = name;\n      this.registeredClass = registeredClass;\n      this.isReference = isReference;\n      this.isConst = isConst;\n      this.isSmartPointer = isSmartPointer;\n      this.pointeeType = pointeeType;\n      this.sharingPolicy = sharingPolicy;\n      this.rawGetPointee = rawGetPointee;\n      this.rawConstructor = rawConstructor;\n      this.rawShare = rawShare;\n      this.rawDestructor = rawDestructor;\n      if (!isSmartPointer && registeredClass.baseClass === void 0) {\n        if (isConst) {\n          this[\"toWireType\"] = constNoSmartPtrRawPointerToWireType;\n          this.destructorFunction = null;\n        } else {\n          this[\"toWireType\"] = nonConstNoSmartPtrRawPointerToWireType;\n          this.destructorFunction = null;\n        }\n      } else {\n        this[\"toWireType\"] = genericPointerToWireType;\n      }\n    }\n    function replacePublicSymbol(name, value, numArguments) {\n      if (!Module.hasOwnProperty(name)) {\n        throwInternalError(\"Replacing nonexistant public symbol\");\n      }\n      if (Module[name].overloadTable !== void 0 && numArguments !== void 0) {\n        Module[name].overloadTable[numArguments] = value;\n      } else {\n        Module[name] = value;\n        Module[name].argCount = numArguments;\n      }\n    }\n    function embind__requireFunction(signature, rawFunction) {\n      signature = readLatin1String(signature);\n      function makeDynCaller(dynCall) {\n        var args = [];\n        for (var i = 1; i < signature.length; ++i) {\n          args.push(\"a\" + i);\n        }\n        var name = \"dynCall_\" + signature + \"_\" + rawFunction;\n        var body = \"return function \" + name + \"(\" + args.join(\", \") + \") {\\n\";\n        body += \"    return dynCall(rawFunction\" + (args.length ? \", \" : \"\") + args.join(\", \") + \");\\n\";\n        body += \"};\\n\";\n        return new Function(\"dynCall\", \"rawFunction\", body)(dynCall, rawFunction);\n      }\n      var dc = Module[\"dynCall_\" + signature];\n      var fp = makeDynCaller(dc);\n      if (typeof fp !== \"function\") {\n        throwBindingError(\"unknown function pointer with signature \" + signature + \": \" + rawFunction);\n      }\n      return fp;\n    }\n    var UnboundTypeError = void 0;\n    function getTypeName(type) {\n      var ptr = ___getTypeName(type);\n      var rv = readLatin1String(ptr);\n      _free(ptr);\n      return rv;\n    }\n    function throwUnboundTypeError(message, types) {\n      var unboundTypes = [];\n      var seen = {};\n      function visit(type) {\n        if (seen[type]) {\n          return;\n        }\n        if (registeredTypes[type]) {\n          return;\n        }\n        if (typeDependencies[type]) {\n          typeDependencies[type].forEach(visit);\n          return;\n        }\n        unboundTypes.push(type);\n        seen[type] = true;\n      }\n      types.forEach(visit);\n      throw new UnboundTypeError(message + \": \" + unboundTypes.map(getTypeName).join([\", \"]));\n    }\n    function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) {\n      name = readLatin1String(name);\n      getActualType = embind__requireFunction(getActualTypeSignature, getActualType);\n      if (upcast) {\n        upcast = embind__requireFunction(upcastSignature, upcast);\n      }\n      if (downcast) {\n        downcast = embind__requireFunction(downcastSignature, downcast);\n      }\n      rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\n      var legalFunctionName = makeLegalFunctionName(name);\n      exposePublicSymbol(legalFunctionName, function() {\n        throwUnboundTypeError(\"Cannot construct \" + name + \" due to unbound types\", [baseClassRawType]);\n      });\n      whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function(base) {\n        base = base[0];\n        var baseClass;\n        var basePrototype;\n        if (baseClassRawType) {\n          baseClass = base.registeredClass;\n          basePrototype = baseClass.instancePrototype;\n        } else {\n          basePrototype = ClassHandle.prototype;\n        }\n        var constructor = createNamedFunction(legalFunctionName, function() {\n          if (Object.getPrototypeOf(this) !== instancePrototype) {\n            throw new BindingError(\"Use 'new' to construct \" + name);\n          }\n          if (registeredClass.constructor_body === void 0) {\n            throw new BindingError(name + \" has no accessible constructor\");\n          }\n          var body = registeredClass.constructor_body[arguments.length];\n          if (body === void 0) {\n            throw new BindingError(\"Tried to invoke ctor of \" + name + \" with invalid number of parameters (\" + arguments.length + \") - expected (\" + Object.keys(registeredClass.constructor_body).toString() + \") parameters instead!\");\n          }\n          return body.apply(this, arguments);\n        });\n        var instancePrototype = Object.create(basePrototype, {\n          constructor: { value: constructor }\n        });\n        constructor.prototype = instancePrototype;\n        var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);\n        var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);\n        var pointerConverter = new RegisteredPointer(name + \"*\", registeredClass, false, false, false);\n        var constPointerConverter = new RegisteredPointer(name + \" const*\", registeredClass, false, true, false);\n        registeredPointers[rawType] = {\n          pointerType: pointerConverter,\n          constPointerType: constPointerConverter\n        };\n        replacePublicSymbol(legalFunctionName, constructor);\n        return [referenceConverter, pointerConverter, constPointerConverter];\n      });\n    }\n    function new_(constructor, argumentList) {\n      if (!(constructor instanceof Function)) {\n        throw new TypeError(\"new_ called with constructor type \" + typeof constructor + \" which is not a function\");\n      }\n      var dummy = createNamedFunction(constructor.name || \"unknownFunctionName\", function() {\n      });\n      dummy.prototype = constructor.prototype;\n      var obj = new dummy();\n      var r = constructor.apply(obj, argumentList);\n      return r instanceof Object ? r : obj;\n    }\n    function runDestructors(destructors) {\n      while (destructors.length) {\n        var ptr = destructors.pop();\n        var del = destructors.pop();\n        del(ptr);\n      }\n    }\n    function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {\n      var argCount = argTypes.length;\n      if (argCount < 2) {\n        throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n      }\n      var isClassMethodFunc = argTypes[1] !== null && classType !== null;\n      var needsDestructorStack = false;\n      for (var i = 1; i < argTypes.length; ++i) {\n        if (argTypes[i] !== null && argTypes[i].destructorFunction === void 0) {\n          needsDestructorStack = true;\n          break;\n        }\n      }\n      var returns = argTypes[0].name !== \"void\";\n      var argsList = \"\";\n      var argsListWired = \"\";\n      for (var i = 0; i < argCount - 2; ++i) {\n        argsList += (i !== 0 ? \", \" : \"\") + \"arg\" + i;\n        argsListWired += (i !== 0 ? \", \" : \"\") + \"arg\" + i + \"Wired\";\n      }\n      var invokerFnBody = \"return function \" + makeLegalFunctionName(humanName) + \"(\" + argsList + \") {\\nif (arguments.length !== \" + (argCount - 2) + \") {\\nthrowBindingError('function \" + humanName + \" called with ' + arguments.length + ' arguments, expected \" + (argCount - 2) + \" args!');\\n}\\n\";\n      if (needsDestructorStack) {\n        invokerFnBody += \"var destructors = [];\\n\";\n      }\n      var dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\n      var args1 = [\n        \"throwBindingError\",\n        \"invoker\",\n        \"fn\",\n        \"runDestructors\",\n        \"retType\",\n        \"classParam\"\n      ];\n      var args2 = [\n        throwBindingError,\n        cppInvokerFunc,\n        cppTargetFunc,\n        runDestructors,\n        argTypes[0],\n        argTypes[1]\n      ];\n      if (isClassMethodFunc) {\n        invokerFnBody += \"var thisWired = classParam.toWireType(\" + dtorStack + \", this);\\n\";\n      }\n      for (var i = 0; i < argCount - 2; ++i) {\n        invokerFnBody += \"var arg\" + i + \"Wired = argType\" + i + \".toWireType(\" + dtorStack + \", arg\" + i + \"); // \" + argTypes[i + 2].name + \"\\n\";\n        args1.push(\"argType\" + i);\n        args2.push(argTypes[i + 2]);\n      }\n      if (isClassMethodFunc) {\n        argsListWired = \"thisWired\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired;\n      }\n      invokerFnBody += (returns ? \"var rv = \" : \"\") + \"invoker(fn\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired + \");\\n\";\n      if (needsDestructorStack) {\n        invokerFnBody += \"runDestructors(destructors);\\n\";\n      } else {\n        for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {\n          var paramName = i === 1 ? \"thisWired\" : \"arg\" + (i - 2) + \"Wired\";\n          if (argTypes[i].destructorFunction !== null) {\n            invokerFnBody += paramName + \"_dtor(\" + paramName + \"); // \" + argTypes[i].name + \"\\n\";\n            args1.push(paramName + \"_dtor\");\n            args2.push(argTypes[i].destructorFunction);\n          }\n        }\n      }\n      if (returns) {\n        invokerFnBody += \"var ret = retType.fromWireType(rv);\\nreturn ret;\\n\";\n      }\n      invokerFnBody += \"}\\n\";\n      args1.push(invokerFnBody);\n      var invokerFunction = new_(Function, args1).apply(null, args2);\n      return invokerFunction;\n    }\n    function heap32VectorToArray(count, firstElement) {\n      var array = [];\n      for (var i = 0; i < count; i++) {\n        array.push(HEAP32[(firstElement >> 2) + i]);\n      }\n      return array;\n    }\n    function __embind_register_class_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, fn) {\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      methodName = readLatin1String(methodName);\n      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\n      whenDependentTypesAreResolved([], [rawClassType], function(classType) {\n        classType = classType[0];\n        var humanName = classType.name + \".\" + methodName;\n        function unboundTypesHandler() {\n          throwUnboundTypeError(\"Cannot call \" + humanName + \" due to unbound types\", rawArgTypes);\n        }\n        var proto = classType.registeredClass.constructor;\n        if (proto[methodName] === void 0) {\n          unboundTypesHandler.argCount = argCount - 1;\n          proto[methodName] = unboundTypesHandler;\n        } else {\n          ensureOverloadTable(proto, methodName, humanName);\n          proto[methodName].overloadTable[argCount - 1] = unboundTypesHandler;\n        }\n        whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {\n          var invokerArgsArray = [argTypes[0], null].concat(argTypes.slice(1));\n          var func = craftInvokerFunction(humanName, invokerArgsArray, null, rawInvoker, fn);\n          if (proto[methodName].overloadTable === void 0) {\n            func.argCount = argCount - 1;\n            proto[methodName] = func;\n          } else {\n            proto[methodName].overloadTable[argCount - 1] = func;\n          }\n          return [];\n        });\n        return [];\n      });\n    }\n    function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {\n      assert(argCount > 0);\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      invoker = embind__requireFunction(invokerSignature, invoker);\n      var args = [rawConstructor];\n      var destructors = [];\n      whenDependentTypesAreResolved([], [rawClassType], function(classType) {\n        classType = classType[0];\n        var humanName = \"constructor \" + classType.name;\n        if (classType.registeredClass.constructor_body === void 0) {\n          classType.registeredClass.constructor_body = [];\n        }\n        if (classType.registeredClass.constructor_body[argCount - 1] !== void 0) {\n          throw new BindingError(\"Cannot register multiple constructors with identical number of parameters (\" + (argCount - 1) + \") for class '\" + classType.name + \"'! Overload resolution is currently only performed using the parameter count, not actual type info!\");\n        }\n        classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {\n          throwUnboundTypeError(\"Cannot construct \" + classType.name + \" due to unbound types\", rawArgTypes);\n        };\n        whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {\n          classType.registeredClass.constructor_body[argCount - 1] = function constructor_body() {\n            if (arguments.length !== argCount - 1) {\n              throwBindingError(humanName + \" called with \" + arguments.length + \" arguments, expected \" + (argCount - 1));\n            }\n            destructors.length = 0;\n            args.length = argCount;\n            for (var i = 1; i < argCount; ++i) {\n              args[i] = argTypes[i][\"toWireType\"](destructors, arguments[i - 1]);\n            }\n            var ptr = invoker.apply(null, args);\n            runDestructors(destructors);\n            return argTypes[0][\"fromWireType\"](ptr);\n          };\n          return [];\n        });\n        return [];\n      });\n    }\n    function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      methodName = readLatin1String(methodName);\n      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\n      whenDependentTypesAreResolved([], [rawClassType], function(classType) {\n        classType = classType[0];\n        var humanName = classType.name + \".\" + methodName;\n        if (isPureVirtual) {\n          classType.registeredClass.pureVirtualFunctions.push(methodName);\n        }\n        function unboundTypesHandler() {\n          throwUnboundTypeError(\"Cannot call \" + humanName + \" due to unbound types\", rawArgTypes);\n        }\n        var proto = classType.registeredClass.instancePrototype;\n        var method = proto[methodName];\n        if (method === void 0 || method.overloadTable === void 0 && method.className !== classType.name && method.argCount === argCount - 2) {\n          unboundTypesHandler.argCount = argCount - 2;\n          unboundTypesHandler.className = classType.name;\n          proto[methodName] = unboundTypesHandler;\n        } else {\n          ensureOverloadTable(proto, methodName, humanName);\n          proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\n        }\n        whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {\n          var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);\n          if (proto[methodName].overloadTable === void 0) {\n            memberFunction.argCount = argCount - 2;\n            proto[methodName] = memberFunction;\n          } else {\n            proto[methodName].overloadTable[argCount - 2] = memberFunction;\n          }\n          return [];\n        });\n        return [];\n      });\n    }\n    var emval_free_list = [];\n    var emval_handle_array = [\n      {},\n      { value: void 0 },\n      { value: null },\n      { value: true },\n      { value: false }\n    ];\n    function __emval_decref(handle) {\n      if (handle > 4 && --emval_handle_array[handle].refcount === 0) {\n        emval_handle_array[handle] = void 0;\n        emval_free_list.push(handle);\n      }\n    }\n    function count_emval_handles() {\n      var count = 0;\n      for (var i = 5; i < emval_handle_array.length; ++i) {\n        if (emval_handle_array[i] !== void 0) {\n          ++count;\n        }\n      }\n      return count;\n    }\n    function get_first_emval() {\n      for (var i = 5; i < emval_handle_array.length; ++i) {\n        if (emval_handle_array[i] !== void 0) {\n          return emval_handle_array[i];\n        }\n      }\n      return null;\n    }\n    function init_emval() {\n      Module[\"count_emval_handles\"] = count_emval_handles;\n      Module[\"get_first_emval\"] = get_first_emval;\n    }\n    function __emval_register(value) {\n      switch (value) {\n        case void 0: {\n          return 1;\n        }\n        case null: {\n          return 2;\n        }\n        case true: {\n          return 3;\n        }\n        case false: {\n          return 4;\n        }\n        default: {\n          var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;\n          emval_handle_array[handle] = { refcount: 1, value };\n          return handle;\n        }\n      }\n    }\n    function __embind_register_emval(rawType, name) {\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name,\n        fromWireType: function(handle) {\n          var rv = emval_handle_array[handle].value;\n          __emval_decref(handle);\n          return rv;\n        },\n        toWireType: function(destructors, value) {\n          return __emval_register(value);\n        },\n        argPackAdvance: 8,\n        readValueFromPointer: simpleReadValueFromPointer,\n        destructorFunction: null\n      });\n    }\n    function _embind_repr(v) {\n      if (v === null) {\n        return \"null\";\n      }\n      var t = typeof v;\n      if (t === \"object\" || t === \"array\" || t === \"function\") {\n        return v.toString();\n      } else {\n        return \"\" + v;\n      }\n    }\n    function floatReadValueFromPointer(name, shift) {\n      switch (shift) {\n        case 2:\n          return function(pointer) {\n            return this[\"fromWireType\"](HEAPF32[pointer >> 2]);\n          };\n        case 3:\n          return function(pointer) {\n            return this[\"fromWireType\"](HEAPF64[pointer >> 3]);\n          };\n        default:\n          throw new TypeError(\"Unknown float type: \" + name);\n      }\n    }\n    function __embind_register_float(rawType, name, size) {\n      var shift = getShiftFromSize(size);\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name,\n        fromWireType: function(value) {\n          return value;\n        },\n        toWireType: function(destructors, value) {\n          if (typeof value !== \"number\" && typeof value !== \"boolean\") {\n            throw new TypeError('Cannot convert \"' + _embind_repr(value) + '\" to ' + this.name);\n          }\n          return value;\n        },\n        argPackAdvance: 8,\n        readValueFromPointer: floatReadValueFromPointer(name, shift),\n        destructorFunction: null\n      });\n    }\n    function __embind_register_function(name, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {\n      var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      name = readLatin1String(name);\n      rawInvoker = embind__requireFunction(signature, rawInvoker);\n      exposePublicSymbol(name, function() {\n        throwUnboundTypeError(\"Cannot call \" + name + \" due to unbound types\", argTypes);\n      }, argCount - 1);\n      whenDependentTypesAreResolved([], argTypes, function(argTypes2) {\n        var invokerArgsArray = [argTypes2[0], null].concat(argTypes2.slice(1));\n        replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn), argCount - 1);\n        return [];\n      });\n    }\n    function integerReadValueFromPointer(name, shift, signed) {\n      switch (shift) {\n        case 0:\n          return signed ? function readS8FromPointer(pointer) {\n            return HEAP8[pointer];\n          } : function readU8FromPointer(pointer) {\n            return HEAPU8[pointer];\n          };\n        case 1:\n          return signed ? function readS16FromPointer(pointer) {\n            return HEAP16[pointer >> 1];\n          } : function readU16FromPointer(pointer) {\n            return HEAPU16[pointer >> 1];\n          };\n        case 2:\n          return signed ? function readS32FromPointer(pointer) {\n            return HEAP32[pointer >> 2];\n          } : function readU32FromPointer(pointer) {\n            return HEAPU32[pointer >> 2];\n          };\n        default:\n          throw new TypeError(\"Unknown integer type: \" + name);\n      }\n    }\n    function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {\n      name = readLatin1String(name);\n      if (maxRange === -1) {\n        maxRange = 4294967295;\n      }\n      var shift = getShiftFromSize(size);\n      var fromWireType = function(value) {\n        return value;\n      };\n      if (minRange === 0) {\n        var bitshift = 32 - 8 * size;\n        fromWireType = function(value) {\n          return value << bitshift >>> bitshift;\n        };\n      }\n      var isUnsignedType = name.indexOf(\"unsigned\") != -1;\n      registerType(primitiveType, {\n        name,\n        fromWireType,\n        toWireType: function(destructors, value) {\n          if (typeof value !== \"number\" && typeof value !== \"boolean\") {\n            throw new TypeError('Cannot convert \"' + _embind_repr(value) + '\" to ' + this.name);\n          }\n          if (value < minRange || value > maxRange) {\n            throw new TypeError('Passing a number \"' + _embind_repr(value) + '\" from JS side to C/C++ side to an argument of type \"' + name + '\", which is outside the valid range [' + minRange + \", \" + maxRange + \"]!\");\n          }\n          return isUnsignedType ? value >>> 0 : value | 0;\n        },\n        argPackAdvance: 8,\n        readValueFromPointer: integerReadValueFromPointer(name, shift, minRange !== 0),\n        destructorFunction: null\n      });\n    }\n    function __embind_register_memory_view(rawType, dataTypeIndex, name) {\n      var typeMapping = [\n        Int8Array,\n        Uint8Array,\n        Int16Array,\n        Uint16Array,\n        Int32Array,\n        Uint32Array,\n        Float32Array,\n        Float64Array\n      ];\n      var TA = typeMapping[dataTypeIndex];\n      function decodeMemoryView(handle) {\n        handle = handle >> 2;\n        var heap = HEAPU32;\n        var size = heap[handle];\n        var data = heap[handle + 1];\n        return new TA(buffer, data, size);\n      }\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name,\n        fromWireType: decodeMemoryView,\n        argPackAdvance: 8,\n        readValueFromPointer: decodeMemoryView\n      }, { ignoreDuplicateRegistrations: true });\n    }\n    function __embind_register_std_string(rawType, name) {\n      name = readLatin1String(name);\n      var stdStringIsUTF8 = name === \"std::string\";\n      registerType(rawType, {\n        name,\n        fromWireType: function(value) {\n          var length = HEAPU32[value >> 2];\n          var str;\n          if (stdStringIsUTF8) {\n            var endChar = HEAPU8[value + 4 + length];\n            var endCharSwap = 0;\n            if (endChar != 0) {\n              endCharSwap = endChar;\n              HEAPU8[value + 4 + length] = 0;\n            }\n            var decodeStartPtr = value + 4;\n            for (var i = 0; i <= length; ++i) {\n              var currentBytePtr = value + 4 + i;\n              if (HEAPU8[currentBytePtr] == 0) {\n                var stringSegment = UTF8ToString(decodeStartPtr);\n                if (str === void 0) {\n                  str = stringSegment;\n                } else {\n                  str += String.fromCharCode(0);\n                  str += stringSegment;\n                }\n                decodeStartPtr = currentBytePtr + 1;\n              }\n            }\n            if (endCharSwap != 0) {\n              HEAPU8[value + 4 + length] = endCharSwap;\n            }\n          } else {\n            var a = new Array(length);\n            for (var i = 0; i < length; ++i) {\n              a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);\n            }\n            str = a.join(\"\");\n          }\n          _free(value);\n          return str;\n        },\n        toWireType: function(destructors, value) {\n          if (value instanceof ArrayBuffer) {\n            value = new Uint8Array(value);\n          }\n          var getLength;\n          var valueIsOfTypeString = typeof value === \"string\";\n          if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {\n            throwBindingError(\"Cannot pass non-string to std::string\");\n          }\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\n            getLength = function() {\n              return lengthBytesUTF8(value);\n            };\n          } else {\n            getLength = function() {\n              return value.length;\n            };\n          }\n          var length = getLength();\n          var ptr = _malloc(4 + length + 1);\n          HEAPU32[ptr >> 2] = length;\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\n            stringToUTF8(value, ptr + 4, length + 1);\n          } else {\n            if (valueIsOfTypeString) {\n              for (var i = 0; i < length; ++i) {\n                var charCode = value.charCodeAt(i);\n                if (charCode > 255) {\n                  _free(ptr);\n                  throwBindingError(\"String has UTF-16 code units that do not fit in 8 bits\");\n                }\n                HEAPU8[ptr + 4 + i] = charCode;\n              }\n            } else {\n              for (var i = 0; i < length; ++i) {\n                HEAPU8[ptr + 4 + i] = value[i];\n              }\n            }\n          }\n          if (destructors !== null) {\n            destructors.push(_free, ptr);\n          }\n          return ptr;\n        },\n        argPackAdvance: 8,\n        readValueFromPointer: simpleReadValueFromPointer,\n        destructorFunction: function(ptr) {\n          _free(ptr);\n        }\n      });\n    }\n    function __embind_register_std_wstring(rawType, charSize, name) {\n      name = readLatin1String(name);\n      var decodeString, encodeString, getHeap, lengthBytesUTF, shift;\n      if (charSize === 2) {\n        decodeString = UTF16ToString;\n        encodeString = stringToUTF16;\n        lengthBytesUTF = lengthBytesUTF16;\n        getHeap = function() {\n          return HEAPU16;\n        };\n        shift = 1;\n      } else if (charSize === 4) {\n        decodeString = UTF32ToString;\n        encodeString = stringToUTF32;\n        lengthBytesUTF = lengthBytesUTF32;\n        getHeap = function() {\n          return HEAPU32;\n        };\n        shift = 2;\n      }\n      registerType(rawType, {\n        name,\n        fromWireType: function(value) {\n          var length = HEAPU32[value >> 2];\n          var HEAP = getHeap();\n          var str;\n          var endChar = HEAP[value + 4 + length * charSize >> shift];\n          var endCharSwap = 0;\n          if (endChar != 0) {\n            endCharSwap = endChar;\n            HEAP[value + 4 + length * charSize >> shift] = 0;\n          }\n          var decodeStartPtr = value + 4;\n          for (var i = 0; i <= length; ++i) {\n            var currentBytePtr = value + 4 + i * charSize;\n            if (HEAP[currentBytePtr >> shift] == 0) {\n              var stringSegment = decodeString(decodeStartPtr);\n              if (str === void 0) {\n                str = stringSegment;\n              } else {\n                str += String.fromCharCode(0);\n                str += stringSegment;\n              }\n              decodeStartPtr = currentBytePtr + charSize;\n            }\n          }\n          if (endCharSwap != 0) {\n            HEAP[value + 4 + length * charSize >> shift] = endCharSwap;\n          }\n          _free(value);\n          return str;\n        },\n        toWireType: function(destructors, value) {\n          if (!(typeof value === \"string\")) {\n            throwBindingError(\"Cannot pass non-string to C++ string type \" + name);\n          }\n          var length = lengthBytesUTF(value);\n          var ptr = _malloc(4 + length + charSize);\n          HEAPU32[ptr >> 2] = length >> shift;\n          encodeString(value, ptr + 4, length + charSize);\n          if (destructors !== null) {\n            destructors.push(_free, ptr);\n          }\n          return ptr;\n        },\n        argPackAdvance: 8,\n        readValueFromPointer: simpleReadValueFromPointer,\n        destructorFunction: function(ptr) {\n          _free(ptr);\n        }\n      });\n    }\n    function __embind_register_void(rawType, name) {\n      name = readLatin1String(name);\n      registerType(rawType, {\n        isVoid: true,\n        name,\n        argPackAdvance: 0,\n        fromWireType: function() {\n          return void 0;\n        },\n        toWireType: function(destructors, o) {\n          return void 0;\n        }\n      });\n    }\n    function __emval_incref(handle) {\n      if (handle > 4) {\n        emval_handle_array[handle].refcount += 1;\n      }\n    }\n    function requireRegisteredType(rawType, humanName) {\n      var impl = registeredTypes[rawType];\n      if (impl === void 0) {\n        throwBindingError(humanName + \" has unknown type \" + getTypeName(rawType));\n      }\n      return impl;\n    }\n    function __emval_take_value(type, argv) {\n      type = requireRegisteredType(type, \"_emval_take_value\");\n      var v = type[\"readValueFromPointer\"](argv);\n      return __emval_register(v);\n    }\n    function _abort() {\n      abort();\n    }\n    function _emscripten_memcpy_big(dest, src, num) {\n      HEAPU8.copyWithin(dest, src, src + num);\n    }\n    function _emscripten_get_heap_size() {\n      return HEAPU8.length;\n    }\n    function emscripten_realloc_buffer(size) {\n      try {\n        wasmMemory.grow(size - buffer.byteLength + 65535 >> 16);\n        updateGlobalBufferAndViews(wasmMemory.buffer);\n        return 1;\n      } catch (e) {\n        console.error(\"emscripten_realloc_buffer: Attempted to grow heap from \" + buffer.byteLength + \" bytes to \" + size + \" bytes, but got error: \" + e);\n      }\n    }\n    function _emscripten_resize_heap(requestedSize) {\n      var oldSize = _emscripten_get_heap_size();\n      assert(requestedSize > oldSize);\n      var PAGE_MULTIPLE = 65536;\n      var maxHeapSize = 2147483648 - PAGE_MULTIPLE;\n      if (requestedSize > maxHeapSize) {\n        err(\"Cannot enlarge memory, asked to go up to \" + requestedSize + \" bytes, but the limit is \" + maxHeapSize + \" bytes!\");\n        return false;\n      }\n      var minHeapSize = 16777216;\n      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);\n        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n        var newSize = Math.min(maxHeapSize, alignUp(Math.max(minHeapSize, requestedSize, overGrownHeapSize), PAGE_MULTIPLE));\n        var replacement = emscripten_realloc_buffer(newSize);\n        if (replacement) {\n          return true;\n        }\n      }\n      err(\"Failed to grow the heap from \" + oldSize + \" bytes to \" + newSize + \" bytes, not enough memory!\");\n      return false;\n    }\n    var ENV = {};\n    function __getExecutableName() {\n      return thisProgram || \"./this.program\";\n    }\n    function _emscripten_get_environ() {\n      if (!_emscripten_get_environ.strings) {\n        var env = {\n          USER: \"web_user\",\n          LOGNAME: \"web_user\",\n          PATH: \"/\",\n          PWD: \"/\",\n          HOME: \"/home/web_user\",\n          LANG: (typeof navigator === \"object\" && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\",\n          _: __getExecutableName()\n        };\n        for (var x in ENV) {\n          env[x] = ENV[x];\n        }\n        var strings = [];\n        for (var x in env) {\n          strings.push(x + \"=\" + env[x]);\n        }\n        _emscripten_get_environ.strings = strings;\n      }\n      return _emscripten_get_environ.strings;\n    }\n    function _environ_get(__environ, environ_buf) {\n      var strings = _emscripten_get_environ();\n      var bufSize = 0;\n      strings.forEach(function(string, i) {\n        var ptr = environ_buf + bufSize;\n        HEAP32[__environ + i * 4 >> 2] = ptr;\n        writeAsciiToMemory(string, ptr);\n        bufSize += string.length + 1;\n      });\n      return 0;\n    }\n    function _environ_sizes_get(penviron_count, penviron_buf_size) {\n      var strings = _emscripten_get_environ();\n      HEAP32[penviron_count >> 2] = strings.length;\n      var bufSize = 0;\n      strings.forEach(function(string) {\n        bufSize += string.length + 1;\n      });\n      HEAP32[penviron_buf_size >> 2] = bufSize;\n      return 0;\n    }\n    function _fd_close(fd) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        FS.close(stream);\n        return 0;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError))\n          abort(e);\n        return e.errno;\n      }\n    }\n    function _fd_fdstat_get(fd, pbuf) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;\n        HEAP8[pbuf >> 0] = type;\n        return 0;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError))\n          abort(e);\n        return e.errno;\n      }\n    }\n    function _fd_read(fd, iov, iovcnt, pnum) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var num = SYSCALLS.doReadv(stream, iov, iovcnt);\n        HEAP32[pnum >> 2] = num;\n        return 0;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError))\n          abort(e);\n        return e.errno;\n      }\n    }\n    function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var HIGH_OFFSET = 4294967296;\n        var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);\n        var DOUBLE_LIMIT = 9007199254740992;\n        if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {\n          return -61;\n        }\n        FS.llseek(stream, offset, whence);\n        tempI64 = [\n          stream.position >>> 0,\n          (tempDouble = stream.position, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n        ], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];\n        if (stream.getdents && offset === 0 && whence === 0)\n          stream.getdents = null;\n        return 0;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError))\n          abort(e);\n        return e.errno;\n      }\n    }\n    function _fd_write(fd, iov, iovcnt, pnum) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var num = SYSCALLS.doWritev(stream, iov, iovcnt);\n        HEAP32[pnum >> 2] = num;\n        return 0;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError))\n          abort(e);\n        return e.errno;\n      }\n    }\n    function _gethostbyname(name) {\n      name = UTF8ToString(name);\n      var ret = _malloc(20);\n      var nameBuf = _malloc(name.length + 1);\n      stringToUTF8(name, nameBuf, name.length + 1);\n      HEAP32[ret >> 2] = nameBuf;\n      var aliasesBuf = _malloc(4);\n      HEAP32[aliasesBuf >> 2] = 0;\n      HEAP32[ret + 4 >> 2] = aliasesBuf;\n      var afinet = 2;\n      HEAP32[ret + 8 >> 2] = afinet;\n      HEAP32[ret + 12 >> 2] = 4;\n      var addrListBuf = _malloc(12);\n      HEAP32[addrListBuf >> 2] = addrListBuf + 8;\n      HEAP32[addrListBuf + 4 >> 2] = 0;\n      HEAP32[addrListBuf + 8 >> 2] = __inet_pton4_raw(DNS.lookup_name(name));\n      HEAP32[ret + 16 >> 2] = addrListBuf;\n      return ret;\n    }\n    function _gettimeofday(ptr) {\n      var now = Date.now();\n      HEAP32[ptr >> 2] = now / 1e3 | 0;\n      HEAP32[ptr + 4 >> 2] = now % 1e3 * 1e3 | 0;\n      return 0;\n    }\n    var ___tm_current = 2400384;\n    stringToUTF8(\"GMT\", 2400432, 4), 2400432;\n    function _tzset() {\n      if (_tzset.called)\n        return;\n      _tzset.called = true;\n      HEAP32[__get_timezone() >> 2] = new Date().getTimezoneOffset() * 60;\n      var currentYear = new Date().getFullYear();\n      var winter = new Date(currentYear, 0, 1);\n      var summer = new Date(currentYear, 6, 1);\n      HEAP32[__get_daylight() >> 2] = Number(winter.getTimezoneOffset() != summer.getTimezoneOffset());\n      function extractZone(date) {\n        var match = date.toTimeString().match(/\\(([A-Za-z ]+)\\)$/);\n        return match ? match[1] : \"GMT\";\n      }\n      var winterName = extractZone(winter);\n      var summerName = extractZone(summer);\n      var winterNamePtr = allocateUTF8(winterName);\n      var summerNamePtr = allocateUTF8(summerName);\n      if (summer.getTimezoneOffset() < winter.getTimezoneOffset()) {\n        HEAP32[__get_tzname() >> 2] = winterNamePtr;\n        HEAP32[__get_tzname() + 4 >> 2] = summerNamePtr;\n      } else {\n        HEAP32[__get_tzname() >> 2] = summerNamePtr;\n        HEAP32[__get_tzname() + 4 >> 2] = winterNamePtr;\n      }\n    }\n    function _localtime_r(time, tmPtr) {\n      _tzset();\n      var date = new Date(HEAP32[time >> 2] * 1e3);\n      HEAP32[tmPtr >> 2] = date.getSeconds();\n      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();\n      HEAP32[tmPtr + 8 >> 2] = date.getHours();\n      HEAP32[tmPtr + 12 >> 2] = date.getDate();\n      HEAP32[tmPtr + 16 >> 2] = date.getMonth();\n      HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;\n      HEAP32[tmPtr + 24 >> 2] = date.getDay();\n      var start = new Date(date.getFullYear(), 0, 1);\n      var yday = (date.getTime() - start.getTime()) / (1e3 * 60 * 60 * 24) | 0;\n      HEAP32[tmPtr + 28 >> 2] = yday;\n      HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);\n      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();\n      var winterOffset = start.getTimezoneOffset();\n      var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;\n      HEAP32[tmPtr + 32 >> 2] = dst;\n      var zonePtr = HEAP32[__get_tzname() + (dst ? 4 : 0) >> 2];\n      HEAP32[tmPtr + 40 >> 2] = zonePtr;\n      return tmPtr;\n    }\n    function _localtime(time) {\n      return _localtime_r(time, ___tm_current);\n    }\n    function _setTempRet0($i) {\n    }\n    function __isLeapYear(year) {\n      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n    }\n    function __arraySum(array, index) {\n      var sum = 0;\n      for (var i = 0; i <= index; sum += array[i++]) {\n      }\n      return sum;\n    }\n    var __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    var __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    function __addDays(date, days) {\n      var newDate = new Date(date.getTime());\n      while (days > 0) {\n        var leap = __isLeapYear(newDate.getFullYear());\n        var currentMonth = newDate.getMonth();\n        var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];\n        if (days > daysInCurrentMonth - newDate.getDate()) {\n          days -= daysInCurrentMonth - newDate.getDate() + 1;\n          newDate.setDate(1);\n          if (currentMonth < 11) {\n            newDate.setMonth(currentMonth + 1);\n          } else {\n            newDate.setMonth(0);\n            newDate.setFullYear(newDate.getFullYear() + 1);\n          }\n        } else {\n          newDate.setDate(newDate.getDate() + days);\n          return newDate;\n        }\n      }\n      return newDate;\n    }\n    function _strftime(s, maxsize, format, tm) {\n      var tm_zone = HEAP32[tm + 40 >> 2];\n      var date = {\n        tm_sec: HEAP32[tm >> 2],\n        tm_min: HEAP32[tm + 4 >> 2],\n        tm_hour: HEAP32[tm + 8 >> 2],\n        tm_mday: HEAP32[tm + 12 >> 2],\n        tm_mon: HEAP32[tm + 16 >> 2],\n        tm_year: HEAP32[tm + 20 >> 2],\n        tm_wday: HEAP32[tm + 24 >> 2],\n        tm_yday: HEAP32[tm + 28 >> 2],\n        tm_isdst: HEAP32[tm + 32 >> 2],\n        tm_gmtoff: HEAP32[tm + 36 >> 2],\n        tm_zone: tm_zone ? UTF8ToString(tm_zone) : \"\"\n      };\n      var pattern = UTF8ToString(format);\n      var EXPANSION_RULES_1 = {\n        \"%c\": \"%a %b %d %H:%M:%S %Y\",\n        \"%D\": \"%m/%d/%y\",\n        \"%F\": \"%Y-%m-%d\",\n        \"%h\": \"%b\",\n        \"%r\": \"%I:%M:%S %p\",\n        \"%R\": \"%H:%M\",\n        \"%T\": \"%H:%M:%S\",\n        \"%x\": \"%m/%d/%y\",\n        \"%X\": \"%H:%M:%S\",\n        \"%Ec\": \"%c\",\n        \"%EC\": \"%C\",\n        \"%Ex\": \"%m/%d/%y\",\n        \"%EX\": \"%H:%M:%S\",\n        \"%Ey\": \"%y\",\n        \"%EY\": \"%Y\",\n        \"%Od\": \"%d\",\n        \"%Oe\": \"%e\",\n        \"%OH\": \"%H\",\n        \"%OI\": \"%I\",\n        \"%Om\": \"%m\",\n        \"%OM\": \"%M\",\n        \"%OS\": \"%S\",\n        \"%Ou\": \"%u\",\n        \"%OU\": \"%U\",\n        \"%OV\": \"%V\",\n        \"%Ow\": \"%w\",\n        \"%OW\": \"%W\",\n        \"%Oy\": \"%y\"\n      };\n      for (var rule in EXPANSION_RULES_1) {\n        pattern = pattern.replace(new RegExp(rule, \"g\"), EXPANSION_RULES_1[rule]);\n      }\n      var WEEKDAYS = [\n        \"Sunday\",\n        \"Monday\",\n        \"Tuesday\",\n        \"Wednesday\",\n        \"Thursday\",\n        \"Friday\",\n        \"Saturday\"\n      ];\n      var MONTHS = [\n        \"January\",\n        \"February\",\n        \"March\",\n        \"April\",\n        \"May\",\n        \"June\",\n        \"July\",\n        \"August\",\n        \"September\",\n        \"October\",\n        \"November\",\n        \"December\"\n      ];\n      function leadingSomething(value, digits, character) {\n        var str = typeof value === \"number\" ? value.toString() : value || \"\";\n        while (str.length < digits) {\n          str = character[0] + str;\n        }\n        return str;\n      }\n      function leadingNulls(value, digits) {\n        return leadingSomething(value, digits, \"0\");\n      }\n      function compareByDay(date1, date2) {\n        function sgn(value) {\n          return value < 0 ? -1 : value > 0 ? 1 : 0;\n        }\n        var compare;\n        if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {\n          if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {\n            compare = sgn(date1.getDate() - date2.getDate());\n          }\n        }\n        return compare;\n      }\n      function getFirstWeekStartDate(janFourth) {\n        switch (janFourth.getDay()) {\n          case 0:\n            return new Date(janFourth.getFullYear() - 1, 11, 29);\n          case 1:\n            return janFourth;\n          case 2:\n            return new Date(janFourth.getFullYear(), 0, 3);\n          case 3:\n            return new Date(janFourth.getFullYear(), 0, 2);\n          case 4:\n            return new Date(janFourth.getFullYear(), 0, 1);\n          case 5:\n            return new Date(janFourth.getFullYear() - 1, 11, 31);\n          case 6:\n            return new Date(janFourth.getFullYear() - 1, 11, 30);\n        }\n      }\n      function getWeekBasedYear(date2) {\n        var thisDate = __addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);\n        var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);\n        var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);\n        var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\n        var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\n        if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {\n          if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {\n            return thisDate.getFullYear() + 1;\n          } else {\n            return thisDate.getFullYear();\n          }\n        } else {\n          return thisDate.getFullYear() - 1;\n        }\n      }\n      var EXPANSION_RULES_2 = {\n        \"%a\": function(date2) {\n          return WEEKDAYS[date2.tm_wday].substring(0, 3);\n        },\n        \"%A\": function(date2) {\n          return WEEKDAYS[date2.tm_wday];\n        },\n        \"%b\": function(date2) {\n          return MONTHS[date2.tm_mon].substring(0, 3);\n        },\n        \"%B\": function(date2) {\n          return MONTHS[date2.tm_mon];\n        },\n        \"%C\": function(date2) {\n          var year = date2.tm_year + 1900;\n          return leadingNulls(year / 100 | 0, 2);\n        },\n        \"%d\": function(date2) {\n          return leadingNulls(date2.tm_mday, 2);\n        },\n        \"%e\": function(date2) {\n          return leadingSomething(date2.tm_mday, 2, \" \");\n        },\n        \"%g\": function(date2) {\n          return getWeekBasedYear(date2).toString().substring(2);\n        },\n        \"%G\": function(date2) {\n          return getWeekBasedYear(date2);\n        },\n        \"%H\": function(date2) {\n          return leadingNulls(date2.tm_hour, 2);\n        },\n        \"%I\": function(date2) {\n          var twelveHour = date2.tm_hour;\n          if (twelveHour == 0)\n            twelveHour = 12;\n          else if (twelveHour > 12)\n            twelveHour -= 12;\n          return leadingNulls(twelveHour, 2);\n        },\n        \"%j\": function(date2) {\n          return leadingNulls(date2.tm_mday + __arraySum(__isLeapYear(date2.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3);\n        },\n        \"%m\": function(date2) {\n          return leadingNulls(date2.tm_mon + 1, 2);\n        },\n        \"%M\": function(date2) {\n          return leadingNulls(date2.tm_min, 2);\n        },\n        \"%n\": function() {\n          return \"\\n\";\n        },\n        \"%p\": function(date2) {\n          if (date2.tm_hour >= 0 && date2.tm_hour < 12) {\n            return \"AM\";\n          } else {\n            return \"PM\";\n          }\n        },\n        \"%S\": function(date2) {\n          return leadingNulls(date2.tm_sec, 2);\n        },\n        \"%t\": function() {\n          return \"\t\";\n        },\n        \"%u\": function(date2) {\n          return date2.tm_wday || 7;\n        },\n        \"%U\": function(date2) {\n          var janFirst = new Date(date2.tm_year + 1900, 0, 1);\n          var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7 - janFirst.getDay());\n          var endDate = new Date(date2.tm_year + 1900, date2.tm_mon, date2.tm_mday);\n          if (compareByDay(firstSunday, endDate) < 0) {\n            var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;\n            var firstSundayUntilEndJanuary = 31 - firstSunday.getDate();\n            var days = firstSundayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();\n            return leadingNulls(Math.ceil(days / 7), 2);\n          }\n          return compareByDay(firstSunday, janFirst) === 0 ? \"01\" : \"00\";\n        },\n        \"%V\": function(date2) {\n          var janFourthThisYear = new Date(date2.tm_year + 1900, 0, 4);\n          var janFourthNextYear = new Date(date2.tm_year + 1901, 0, 4);\n          var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\n          var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\n          var endDate = __addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);\n          if (compareByDay(endDate, firstWeekStartThisYear) < 0) {\n            return \"53\";\n          }\n          if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {\n            return \"01\";\n          }\n          var daysDifference;\n          if (firstWeekStartThisYear.getFullYear() < date2.tm_year + 1900) {\n            daysDifference = date2.tm_yday + 32 - firstWeekStartThisYear.getDate();\n          } else {\n            daysDifference = date2.tm_yday + 1 - firstWeekStartThisYear.getDate();\n          }\n          return leadingNulls(Math.ceil(daysDifference / 7), 2);\n        },\n        \"%w\": function(date2) {\n          return date2.tm_wday;\n        },\n        \"%W\": function(date2) {\n          var janFirst = new Date(date2.tm_year, 0, 1);\n          var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7 - janFirst.getDay() + 1);\n          var endDate = new Date(date2.tm_year + 1900, date2.tm_mon, date2.tm_mday);\n          if (compareByDay(firstMonday, endDate) < 0) {\n            var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;\n            var firstMondayUntilEndJanuary = 31 - firstMonday.getDate();\n            var days = firstMondayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();\n            return leadingNulls(Math.ceil(days / 7), 2);\n          }\n          return compareByDay(firstMonday, janFirst) === 0 ? \"01\" : \"00\";\n        },\n        \"%y\": function(date2) {\n          return (date2.tm_year + 1900).toString().substring(2);\n        },\n        \"%Y\": function(date2) {\n          return date2.tm_year + 1900;\n        },\n        \"%z\": function(date2) {\n          var off = date2.tm_gmtoff;\n          var ahead = off >= 0;\n          off = Math.abs(off) / 60;\n          off = off / 60 * 100 + off % 60;\n          return (ahead ? \"+\" : \"-\") + String(\"0000\" + off).slice(-4);\n        },\n        \"%Z\": function(date2) {\n          return date2.tm_zone;\n        },\n        \"%%\": function() {\n          return \"%\";\n        }\n      };\n      for (var rule in EXPANSION_RULES_2) {\n        if (pattern.indexOf(rule) >= 0) {\n          pattern = pattern.replace(new RegExp(rule, \"g\"), EXPANSION_RULES_2[rule](date));\n        }\n      }\n      var bytes = intArrayFromString(pattern, false);\n      if (bytes.length > maxsize) {\n        return 0;\n      }\n      writeArrayToMemory(bytes, s);\n      return bytes.length - 1;\n    }\n    function _strftime_l(s, maxsize, format, tm) {\n      return _strftime(s, maxsize, format, tm);\n    }\n    function _time(ptr) {\n      var ret = Date.now() / 1e3 | 0;\n      if (ptr) {\n        HEAP32[ptr >> 2] = ret;\n      }\n      return ret;\n    }\n    function readAsmConstArgs(sigPtr, buf) {\n      if (!readAsmConstArgs.array) {\n        readAsmConstArgs.array = [];\n      }\n      var args = readAsmConstArgs.array;\n      args.length = 0;\n      var ch;\n      while (ch = HEAPU8[sigPtr++]) {\n        if (ch === 100 || ch === 102) {\n          buf = buf + 7 & ~7;\n          args.push(HEAPF64[buf >> 3]);\n          buf += 8;\n        } else if (ch === 105) {\n          buf = buf + 3 & ~3;\n          args.push(HEAP32[buf >> 2]);\n          buf += 4;\n        } else\n          abort(\"unexpected char in asm const signature \" + ch);\n      }\n      return args;\n    }\n    var FSNode = function(parent, name, mode, rdev) {\n      if (!parent) {\n        parent = this;\n      }\n      this.parent = parent;\n      this.mount = parent.mount;\n      this.mounted = null;\n      this.id = FS.nextInode++;\n      this.name = name;\n      this.mode = mode;\n      this.node_ops = {};\n      this.stream_ops = {};\n      this.rdev = rdev;\n    };\n    var readMode = 292 | 73;\n    var writeMode = 146;\n    Object.defineProperties(FSNode.prototype, {\n      read: {\n        get: function() {\n          return (this.mode & readMode) === readMode;\n        },\n        set: function(val) {\n          val ? this.mode |= readMode : this.mode &= ~readMode;\n        }\n      },\n      write: {\n        get: function() {\n          return (this.mode & writeMode) === writeMode;\n        },\n        set: function(val) {\n          val ? this.mode |= writeMode : this.mode &= ~writeMode;\n        }\n      },\n      isFolder: {\n        get: function() {\n          return FS.isDir(this.mode);\n        }\n      },\n      isDevice: {\n        get: function() {\n          return FS.isChrdev(this.mode);\n        }\n      }\n    });\n    FS.FSNode = FSNode;\n    FS.staticInit();\n    Module[\"FS_createFolder\"] = FS.createFolder;\n    Module[\"FS_createPath\"] = FS.createPath;\n    Module[\"FS_createDataFile\"] = FS.createDataFile;\n    Module[\"FS_createPreloadedFile\"] = FS.createPreloadedFile;\n    Module[\"FS_createLazyFile\"] = FS.createLazyFile;\n    Module[\"FS_createLink\"] = FS.createLink;\n    Module[\"FS_createDevice\"] = FS.createDevice;\n    Module[\"FS_unlink\"] = FS.unlink;\n    embind_init_charCodes();\n    BindingError = Module[\"BindingError\"] = extendError(Error, \"BindingError\");\n    InternalError = Module[\"InternalError\"] = extendError(Error, \"InternalError\");\n    init_ClassHandle();\n    init_RegisteredPointer();\n    init_embind();\n    UnboundTypeError = Module[\"UnboundTypeError\"] = extendError(Error, \"UnboundTypeError\");\n    init_emval();\n    function intArrayFromString(stringy, dontAddNull, length) {\n      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n      var u8array = new Array(len);\n      var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n      if (dontAddNull)\n        u8array.length = numBytesWritten;\n      return u8array;\n    }\n    var asmLibraryArg = {\n      __cxa_allocate_exception: ___cxa_allocate_exception,\n      __cxa_throw: ___cxa_throw,\n      __handle_stack_overflow: ___handle_stack_overflow,\n      __map_file: ___map_file,\n      __syscall102: ___syscall102,\n      __syscall12: ___syscall12,\n      __syscall142: ___syscall142,\n      __syscall183: ___syscall183,\n      __syscall195: ___syscall195,\n      __syscall197: ___syscall197,\n      __syscall221: ___syscall221,\n      __syscall3: ___syscall3,\n      __syscall39: ___syscall39,\n      __syscall5: ___syscall5,\n      __syscall54: ___syscall54,\n      __syscall85: ___syscall85,\n      __syscall91: ___syscall91,\n      _embind_register_bool: __embind_register_bool,\n      _embind_register_class: __embind_register_class,\n      _embind_register_class_class_function: __embind_register_class_class_function,\n      _embind_register_class_constructor: __embind_register_class_constructor,\n      _embind_register_class_function: __embind_register_class_function,\n      _embind_register_emval: __embind_register_emval,\n      _embind_register_float: __embind_register_float,\n      _embind_register_function: __embind_register_function,\n      _embind_register_integer: __embind_register_integer,\n      _embind_register_memory_view: __embind_register_memory_view,\n      _embind_register_std_string: __embind_register_std_string,\n      _embind_register_std_wstring: __embind_register_std_wstring,\n      _embind_register_void: __embind_register_void,\n      _emval_decref: __emval_decref,\n      _emval_incref: __emval_incref,\n      _emval_take_value: __emval_take_value,\n      abort: _abort,\n      connectMemory,\n      emscripten_asm_const_iii: _emscripten_asm_const_iii,\n      emscripten_memcpy_big: _emscripten_memcpy_big,\n      emscripten_resize_heap: _emscripten_resize_heap,\n      environ_get: _environ_get,\n      environ_sizes_get: _environ_sizes_get,\n      fd_close: _fd_close,\n      fd_fdstat_get: _fd_fdstat_get,\n      fd_read: _fd_read,\n      fd_seek: _fd_seek,\n      fd_write: _fd_write,\n      gethostbyname: _gethostbyname,\n      gettimeofday: _gettimeofday,\n      localtime: _localtime,\n      memory: wasmMemory,\n      setTempRet0: _setTempRet0,\n      strftime: _strftime,\n      strftime_l: _strftime_l,\n      table: wasmTable,\n      time: _time\n    };\n    var asm = createWasm();\n    Module[\"asm\"] = asm;\n    var ___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"__wasm_call_ctors\"].apply(null, arguments);\n    };\n    Module[\"_fflush\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"fflush\"].apply(null, arguments);\n    };\n    Module[\"_expandCDSPFromString\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"expandCDSPFromString\"].apply(null, arguments);\n    };\n    Module[\"_generateCAuxFilesFromString\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"generateCAuxFilesFromString\"].apply(null, arguments);\n    };\n    Module[\"_freeCMemory\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"freeCMemory\"].apply(null, arguments);\n    };\n    var _free = Module[\"_free\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"free\"].apply(null, arguments);\n    };\n    Module[\"_getCLibFaustVersion\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"getCLibFaustVersion\"].apply(null, arguments);\n    };\n    Module[\"_getErrorAfterException\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"getErrorAfterException\"].apply(null, arguments);\n    };\n    Module[\"_cleanupAfterException\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"cleanupAfterException\"].apply(null, arguments);\n    };\n    var _malloc = Module[\"_malloc\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"malloc\"].apply(null, arguments);\n    };\n    Module[\"___errno_location\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"__errno_location\"].apply(null, arguments);\n    };\n    var _htons = Module[\"_htons\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"htons\"].apply(null, arguments);\n    };\n    Module[\"___em_js__connectMemory\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"__em_js__connectMemory\"].apply(null, arguments);\n    };\n    Module[\"_deleteAllWasmCDSPFactories\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"deleteAllWasmCDSPFactories\"].apply(null, arguments);\n    };\n    Module[\"_createWasmCDSPFactoryFromString\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"createWasmCDSPFactoryFromString\"].apply(null, arguments);\n    };\n    Module[\"_getWasmCModule\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"getWasmCModule\"].apply(null, arguments);\n    };\n    Module[\"_getWasmCModuleSize\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"getWasmCModuleSize\"].apply(null, arguments);\n    };\n    Module[\"_getWasmCHelpers\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"getWasmCHelpers\"].apply(null, arguments);\n    };\n    Module[\"_freeWasmCModule\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"freeWasmCModule\"].apply(null, arguments);\n    };\n    var _ntohs = Module[\"_ntohs\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"ntohs\"].apply(null, arguments);\n    };\n    var __get_tzname = Module[\"__get_tzname\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"_get_tzname\"].apply(null, arguments);\n    };\n    var __get_daylight = Module[\"__get_daylight\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"_get_daylight\"].apply(null, arguments);\n    };\n    var __get_timezone = Module[\"__get_timezone\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"_get_timezone\"].apply(null, arguments);\n    };\n    var ___getTypeName = Module[\"___getTypeName\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"__getTypeName\"].apply(null, arguments);\n    };\n    Module[\"___embind_register_native_and_builtin_types\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"__embind_register_native_and_builtin_types\"].apply(null, arguments);\n    };\n    Module[\"___set_stack_limit\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"__set_stack_limit\"].apply(null, arguments);\n    };\n    var stackSave = Module[\"stackSave\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"stackSave\"].apply(null, arguments);\n    };\n    var stackAlloc = Module[\"stackAlloc\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"stackAlloc\"].apply(null, arguments);\n    };\n    var stackRestore = Module[\"stackRestore\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"stackRestore\"].apply(null, arguments);\n    };\n    Module[\"dynCall_ii\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_ii\"].apply(null, arguments);\n    };\n    Module[\"dynCall_vi\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_vi\"].apply(null, arguments);\n    };\n    Module[\"dynCall_vii\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_vii\"].apply(null, arguments);\n    };\n    Module[\"dynCall_iiii\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_iiii\"].apply(null, arguments);\n    };\n    Module[\"dynCall_viijii\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_viijii\"].apply(null, arguments);\n    };\n    Module[\"dynCall_viiii\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_viiii\"].apply(null, arguments);\n    };\n    Module[\"dynCall_iii\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_iii\"].apply(null, arguments);\n    };\n    Module[\"dynCall_iiiii\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_iiiii\"].apply(null, arguments);\n    };\n    Module[\"dynCall_iiiiii\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_iiiiii\"].apply(null, arguments);\n    };\n    Module[\"dynCall_viddddii\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_viddddii\"].apply(null, arguments);\n    };\n    Module[\"dynCall_viddddiii\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_viddddiii\"].apply(null, arguments);\n    };\n    Module[\"dynCall_viddd\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_viddd\"].apply(null, arguments);\n    };\n    Module[\"dynCall_vidddi\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_vidddi\"].apply(null, arguments);\n    };\n    Module[\"dynCall_vidddd\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_vidddd\"].apply(null, arguments);\n    };\n    Module[\"dynCall_viddii\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_viddii\"].apply(null, arguments);\n    };\n    Module[\"dynCall_viddi\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_viddi\"].apply(null, arguments);\n    };\n    Module[\"dynCall_viiiiddd\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_viiiiddd\"].apply(null, arguments);\n    };\n    Module[\"dynCall_viii\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_viii\"].apply(null, arguments);\n    };\n    Module[\"dynCall_v\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_v\"].apply(null, arguments);\n    };\n    Module[\"dynCall_viiiffff\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_viiiffff\"].apply(null, arguments);\n    };\n    Module[\"dynCall_viiiff\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_viiiff\"].apply(null, arguments);\n    };\n    Module[\"dynCall_iiiiiiii\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_iiiiiiii\"].apply(null, arguments);\n    };\n    Module[\"dynCall_iiiiiii\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_iiiiiii\"].apply(null, arguments);\n    };\n    Module[\"dynCall_iiid\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_iiid\"].apply(null, arguments);\n    };\n    Module[\"dynCall_viiidddd\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_viiidddd\"].apply(null, arguments);\n    };\n    Module[\"dynCall_viiidd\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_viiidd\"].apply(null, arguments);\n    };\n    Module[\"dynCall_viiiii\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_viiiii\"].apply(null, arguments);\n    };\n    Module[\"dynCall_di\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_di\"].apply(null, arguments);\n    };\n    Module[\"dynCall_vid\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_vid\"].apply(null, arguments);\n    };\n    Module[\"dynCall_i\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_i\"].apply(null, arguments);\n    };\n    Module[\"dynCall_viiif\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_viiif\"].apply(null, arguments);\n    };\n    Module[\"dynCall_fiii\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_fiii\"].apply(null, arguments);\n    };\n    Module[\"dynCall_vidiii\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_vidiii\"].apply(null, arguments);\n    };\n    Module[\"dynCall_viif\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_viif\"].apply(null, arguments);\n    };\n    Module[\"dynCall_fii\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_fii\"].apply(null, arguments);\n    };\n    Module[\"dynCall_jiji\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_jiji\"].apply(null, arguments);\n    };\n    Module[\"dynCall_iidiiii\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_iidiiii\"].apply(null, arguments);\n    };\n    Module[\"dynCall_iiiiiiiii\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_iiiiiiiii\"].apply(null, arguments);\n    };\n    Module[\"dynCall_iiiiij\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_iiiiij\"].apply(null, arguments);\n    };\n    Module[\"dynCall_iiiiid\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_iiiiid\"].apply(null, arguments);\n    };\n    Module[\"dynCall_iiiiijj\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_iiiiijj\"].apply(null, arguments);\n    };\n    Module[\"dynCall_iiiiiijj\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_iiiiiijj\"].apply(null, arguments);\n    };\n    Module[\"dynCall_viiiiii\"] = function() {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"dynCall_viiiiii\"].apply(null, arguments);\n    };\n    Module[\"asm\"] = asm;\n    if (!Object.getOwnPropertyDescriptor(Module, \"intArrayFromString\"))\n      Module[\"intArrayFromString\"] = function() {\n        abort(\"'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"intArrayToString\"))\n      Module[\"intArrayToString\"] = function() {\n        abort(\"'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"ccall\"))\n      Module[\"ccall\"] = function() {\n        abort(\"'ccall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    Module[\"cwrap\"] = cwrap;\n    if (!Object.getOwnPropertyDescriptor(Module, \"setValue\"))\n      Module[\"setValue\"] = function() {\n        abort(\"'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"getValue\"))\n      Module[\"getValue\"] = function() {\n        abort(\"'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"allocate\"))\n      Module[\"allocate\"] = function() {\n        abort(\"'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    Module[\"getMemory\"] = getMemory;\n    if (!Object.getOwnPropertyDescriptor(Module, \"UTF8ArrayToString\"))\n      Module[\"UTF8ArrayToString\"] = function() {\n        abort(\"'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    Module[\"UTF8ToString\"] = UTF8ToString;\n    if (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF8Array\"))\n      Module[\"stringToUTF8Array\"] = function() {\n        abort(\"'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    Module[\"stringToUTF8\"] = stringToUTF8;\n    Module[\"lengthBytesUTF8\"] = lengthBytesUTF8;\n    if (!Object.getOwnPropertyDescriptor(Module, \"stackTrace\"))\n      Module[\"stackTrace\"] = function() {\n        abort(\"'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"addOnPreRun\"))\n      Module[\"addOnPreRun\"] = function() {\n        abort(\"'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"addOnInit\"))\n      Module[\"addOnInit\"] = function() {\n        abort(\"'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"addOnPreMain\"))\n      Module[\"addOnPreMain\"] = function() {\n        abort(\"'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"addOnExit\"))\n      Module[\"addOnExit\"] = function() {\n        abort(\"'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"addOnPostRun\"))\n      Module[\"addOnPostRun\"] = function() {\n        abort(\"'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"writeStringToMemory\"))\n      Module[\"writeStringToMemory\"] = function() {\n        abort(\"'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"writeArrayToMemory\"))\n      Module[\"writeArrayToMemory\"] = function() {\n        abort(\"'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"writeAsciiToMemory\"))\n      Module[\"writeAsciiToMemory\"] = function() {\n        abort(\"'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    Module[\"addRunDependency\"] = addRunDependency;\n    Module[\"removeRunDependency\"] = removeRunDependency;\n    Module[\"FS_createFolder\"] = FS.createFolder;\n    Module[\"FS_createPath\"] = FS.createPath;\n    Module[\"FS_createDataFile\"] = FS.createDataFile;\n    Module[\"FS_createPreloadedFile\"] = FS.createPreloadedFile;\n    Module[\"FS_createLazyFile\"] = FS.createLazyFile;\n    Module[\"FS_createLink\"] = FS.createLink;\n    Module[\"FS_createDevice\"] = FS.createDevice;\n    Module[\"FS_unlink\"] = FS.unlink;\n    if (!Object.getOwnPropertyDescriptor(Module, \"dynamicAlloc\"))\n      Module[\"dynamicAlloc\"] = function() {\n        abort(\"'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"loadDynamicLibrary\"))\n      Module[\"loadDynamicLibrary\"] = function() {\n        abort(\"'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"loadWebAssemblyModule\"))\n      Module[\"loadWebAssemblyModule\"] = function() {\n        abort(\"'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"getLEB\"))\n      Module[\"getLEB\"] = function() {\n        abort(\"'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"getFunctionTables\"))\n      Module[\"getFunctionTables\"] = function() {\n        abort(\"'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"alignFunctionTables\"))\n      Module[\"alignFunctionTables\"] = function() {\n        abort(\"'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"registerFunctions\"))\n      Module[\"registerFunctions\"] = function() {\n        abort(\"'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"addFunction\"))\n      Module[\"addFunction\"] = function() {\n        abort(\"'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"removeFunction\"))\n      Module[\"removeFunction\"] = function() {\n        abort(\"'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"getFuncWrapper\"))\n      Module[\"getFuncWrapper\"] = function() {\n        abort(\"'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"prettyPrint\"))\n      Module[\"prettyPrint\"] = function() {\n        abort(\"'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"makeBigInt\"))\n      Module[\"makeBigInt\"] = function() {\n        abort(\"'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"dynCall\"))\n      Module[\"dynCall\"] = function() {\n        abort(\"'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"getCompilerSetting\"))\n      Module[\"getCompilerSetting\"] = function() {\n        abort(\"'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"print\"))\n      Module[\"print\"] = function() {\n        abort(\"'print' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"printErr\"))\n      Module[\"printErr\"] = function() {\n        abort(\"'printErr' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"getTempRet0\"))\n      Module[\"getTempRet0\"] = function() {\n        abort(\"'getTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"setTempRet0\"))\n      Module[\"setTempRet0\"] = function() {\n        abort(\"'setTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"callMain\"))\n      Module[\"callMain\"] = function() {\n        abort(\"'callMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"abort\"))\n      Module[\"abort\"] = function() {\n        abort(\"'abort' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"stringToNewUTF8\"))\n      Module[\"stringToNewUTF8\"] = function() {\n        abort(\"'stringToNewUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"emscripten_realloc_buffer\"))\n      Module[\"emscripten_realloc_buffer\"] = function() {\n        abort(\"'emscripten_realloc_buffer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"ENV\"))\n      Module[\"ENV\"] = function() {\n        abort(\"'ENV' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"setjmpId\"))\n      Module[\"setjmpId\"] = function() {\n        abort(\"'setjmpId' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"ERRNO_CODES\"))\n      Module[\"ERRNO_CODES\"] = function() {\n        abort(\"'ERRNO_CODES' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"ERRNO_MESSAGES\"))\n      Module[\"ERRNO_MESSAGES\"] = function() {\n        abort(\"'ERRNO_MESSAGES' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"DNS\"))\n      Module[\"DNS\"] = function() {\n        abort(\"'DNS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"GAI_ERRNO_MESSAGES\"))\n      Module[\"GAI_ERRNO_MESSAGES\"] = function() {\n        abort(\"'GAI_ERRNO_MESSAGES' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"Protocols\"))\n      Module[\"Protocols\"] = function() {\n        abort(\"'Protocols' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"Sockets\"))\n      Module[\"Sockets\"] = function() {\n        abort(\"'Sockets' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"UNWIND_CACHE\"))\n      Module[\"UNWIND_CACHE\"] = function() {\n        abort(\"'UNWIND_CACHE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"readAsmConstArgs\"))\n      Module[\"readAsmConstArgs\"] = function() {\n        abort(\"'readAsmConstArgs' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"jstoi_q\"))\n      Module[\"jstoi_q\"] = function() {\n        abort(\"'jstoi_q' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"jstoi_s\"))\n      Module[\"jstoi_s\"] = function() {\n        abort(\"'jstoi_s' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"PATH\"))\n      Module[\"PATH\"] = function() {\n        abort(\"'PATH' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"PATH_FS\"))\n      Module[\"PATH_FS\"] = function() {\n        abort(\"'PATH_FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"SYSCALLS\"))\n      Module[\"SYSCALLS\"] = function() {\n        abort(\"'SYSCALLS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"syscallMmap2\"))\n      Module[\"syscallMmap2\"] = function() {\n        abort(\"'syscallMmap2' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"syscallMunmap\"))\n      Module[\"syscallMunmap\"] = function() {\n        abort(\"'syscallMunmap' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"JSEvents\"))\n      Module[\"JSEvents\"] = function() {\n        abort(\"'JSEvents' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"demangle\"))\n      Module[\"demangle\"] = function() {\n        abort(\"'demangle' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"demangleAll\"))\n      Module[\"demangleAll\"] = function() {\n        abort(\"'demangleAll' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"jsStackTrace\"))\n      Module[\"jsStackTrace\"] = function() {\n        abort(\"'jsStackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"stackTrace\"))\n      Module[\"stackTrace\"] = function() {\n        abort(\"'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToI64\"))\n      Module[\"writeI53ToI64\"] = function() {\n        abort(\"'writeI53ToI64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToI64Clamped\"))\n      Module[\"writeI53ToI64Clamped\"] = function() {\n        abort(\"'writeI53ToI64Clamped' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToI64Signaling\"))\n      Module[\"writeI53ToI64Signaling\"] = function() {\n        abort(\"'writeI53ToI64Signaling' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToU64Clamped\"))\n      Module[\"writeI53ToU64Clamped\"] = function() {\n        abort(\"'writeI53ToU64Clamped' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToU64Signaling\"))\n      Module[\"writeI53ToU64Signaling\"] = function() {\n        abort(\"'writeI53ToU64Signaling' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"readI53FromI64\"))\n      Module[\"readI53FromI64\"] = function() {\n        abort(\"'readI53FromI64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"readI53FromU64\"))\n      Module[\"readI53FromU64\"] = function() {\n        abort(\"'readI53FromU64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"convertI32PairToI53\"))\n      Module[\"convertI32PairToI53\"] = function() {\n        abort(\"'convertI32PairToI53' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"convertU32PairToI53\"))\n      Module[\"convertU32PairToI53\"] = function() {\n        abort(\"'convertU32PairToI53' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"Browser\"))\n      Module[\"Browser\"] = function() {\n        abort(\"'Browser' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    Module[\"FS\"] = FS;\n    if (!Object.getOwnPropertyDescriptor(Module, \"MEMFS\"))\n      Module[\"MEMFS\"] = function() {\n        abort(\"'MEMFS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"TTY\"))\n      Module[\"TTY\"] = function() {\n        abort(\"'TTY' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"PIPEFS\"))\n      Module[\"PIPEFS\"] = function() {\n        abort(\"'PIPEFS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"SOCKFS\"))\n      Module[\"SOCKFS\"] = function() {\n        abort(\"'SOCKFS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"GL\"))\n      Module[\"GL\"] = function() {\n        abort(\"'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGet\"))\n      Module[\"emscriptenWebGLGet\"] = function() {\n        abort(\"'emscriptenWebGLGet' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetTexPixelData\"))\n      Module[\"emscriptenWebGLGetTexPixelData\"] = function() {\n        abort(\"'emscriptenWebGLGetTexPixelData' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetUniform\"))\n      Module[\"emscriptenWebGLGetUniform\"] = function() {\n        abort(\"'emscriptenWebGLGetUniform' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetVertexAttrib\"))\n      Module[\"emscriptenWebGLGetVertexAttrib\"] = function() {\n        abort(\"'emscriptenWebGLGetVertexAttrib' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"AL\"))\n      Module[\"AL\"] = function() {\n        abort(\"'AL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"SDL\"))\n      Module[\"SDL\"] = function() {\n        abort(\"'SDL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"SDL_gfx\"))\n      Module[\"SDL_gfx\"] = function() {\n        abort(\"'SDL_gfx' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"GLUT\"))\n      Module[\"GLUT\"] = function() {\n        abort(\"'GLUT' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"EGL\"))\n      Module[\"EGL\"] = function() {\n        abort(\"'EGL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"GLFW_Window\"))\n      Module[\"GLFW_Window\"] = function() {\n        abort(\"'GLFW_Window' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"GLFW\"))\n      Module[\"GLFW\"] = function() {\n        abort(\"'GLFW' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"GLEW\"))\n      Module[\"GLEW\"] = function() {\n        abort(\"'GLEW' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"IDBStore\"))\n      Module[\"IDBStore\"] = function() {\n        abort(\"'IDBStore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"runAndAbortIfError\"))\n      Module[\"runAndAbortIfError\"] = function() {\n        abort(\"'runAndAbortIfError' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"emval_handle_array\"))\n      Module[\"emval_handle_array\"] = function() {\n        abort(\"'emval_handle_array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"emval_free_list\"))\n      Module[\"emval_free_list\"] = function() {\n        abort(\"'emval_free_list' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"emval_symbols\"))\n      Module[\"emval_symbols\"] = function() {\n        abort(\"'emval_symbols' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"init_emval\"))\n      Module[\"init_emval\"] = function() {\n        abort(\"'init_emval' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"count_emval_handles\"))\n      Module[\"count_emval_handles\"] = function() {\n        abort(\"'count_emval_handles' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"get_first_emval\"))\n      Module[\"get_first_emval\"] = function() {\n        abort(\"'get_first_emval' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"getStringOrSymbol\"))\n      Module[\"getStringOrSymbol\"] = function() {\n        abort(\"'getStringOrSymbol' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"requireHandle\"))\n      Module[\"requireHandle\"] = function() {\n        abort(\"'requireHandle' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"emval_newers\"))\n      Module[\"emval_newers\"] = function() {\n        abort(\"'emval_newers' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"craftEmvalAllocator\"))\n      Module[\"craftEmvalAllocator\"] = function() {\n        abort(\"'craftEmvalAllocator' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"emval_get_global\"))\n      Module[\"emval_get_global\"] = function() {\n        abort(\"'emval_get_global' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"emval_methodCallers\"))\n      Module[\"emval_methodCallers\"] = function() {\n        abort(\"'emval_methodCallers' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"InternalError\"))\n      Module[\"InternalError\"] = function() {\n        abort(\"'InternalError' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"BindingError\"))\n      Module[\"BindingError\"] = function() {\n        abort(\"'BindingError' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"UnboundTypeError\"))\n      Module[\"UnboundTypeError\"] = function() {\n        abort(\"'UnboundTypeError' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"PureVirtualError\"))\n      Module[\"PureVirtualError\"] = function() {\n        abort(\"'PureVirtualError' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"init_embind\"))\n      Module[\"init_embind\"] = function() {\n        abort(\"'init_embind' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"throwInternalError\"))\n      Module[\"throwInternalError\"] = function() {\n        abort(\"'throwInternalError' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"throwBindingError\"))\n      Module[\"throwBindingError\"] = function() {\n        abort(\"'throwBindingError' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"throwUnboundTypeError\"))\n      Module[\"throwUnboundTypeError\"] = function() {\n        abort(\"'throwUnboundTypeError' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"ensureOverloadTable\"))\n      Module[\"ensureOverloadTable\"] = function() {\n        abort(\"'ensureOverloadTable' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"exposePublicSymbol\"))\n      Module[\"exposePublicSymbol\"] = function() {\n        abort(\"'exposePublicSymbol' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"replacePublicSymbol\"))\n      Module[\"replacePublicSymbol\"] = function() {\n        abort(\"'replacePublicSymbol' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"extendError\"))\n      Module[\"extendError\"] = function() {\n        abort(\"'extendError' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"createNamedFunction\"))\n      Module[\"createNamedFunction\"] = function() {\n        abort(\"'createNamedFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"registeredInstances\"))\n      Module[\"registeredInstances\"] = function() {\n        abort(\"'registeredInstances' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"getBasestPointer\"))\n      Module[\"getBasestPointer\"] = function() {\n        abort(\"'getBasestPointer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"registerInheritedInstance\"))\n      Module[\"registerInheritedInstance\"] = function() {\n        abort(\"'registerInheritedInstance' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"unregisterInheritedInstance\"))\n      Module[\"unregisterInheritedInstance\"] = function() {\n        abort(\"'unregisterInheritedInstance' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"getInheritedInstance\"))\n      Module[\"getInheritedInstance\"] = function() {\n        abort(\"'getInheritedInstance' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"getInheritedInstanceCount\"))\n      Module[\"getInheritedInstanceCount\"] = function() {\n        abort(\"'getInheritedInstanceCount' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"getLiveInheritedInstances\"))\n      Module[\"getLiveInheritedInstances\"] = function() {\n        abort(\"'getLiveInheritedInstances' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"registeredTypes\"))\n      Module[\"registeredTypes\"] = function() {\n        abort(\"'registeredTypes' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"awaitingDependencies\"))\n      Module[\"awaitingDependencies\"] = function() {\n        abort(\"'awaitingDependencies' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"typeDependencies\"))\n      Module[\"typeDependencies\"] = function() {\n        abort(\"'typeDependencies' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"registeredPointers\"))\n      Module[\"registeredPointers\"] = function() {\n        abort(\"'registeredPointers' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"registerType\"))\n      Module[\"registerType\"] = function() {\n        abort(\"'registerType' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"whenDependentTypesAreResolved\"))\n      Module[\"whenDependentTypesAreResolved\"] = function() {\n        abort(\"'whenDependentTypesAreResolved' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"embind_charCodes\"))\n      Module[\"embind_charCodes\"] = function() {\n        abort(\"'embind_charCodes' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"embind_init_charCodes\"))\n      Module[\"embind_init_charCodes\"] = function() {\n        abort(\"'embind_init_charCodes' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"readLatin1String\"))\n      Module[\"readLatin1String\"] = function() {\n        abort(\"'readLatin1String' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"getTypeName\"))\n      Module[\"getTypeName\"] = function() {\n        abort(\"'getTypeName' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"heap32VectorToArray\"))\n      Module[\"heap32VectorToArray\"] = function() {\n        abort(\"'heap32VectorToArray' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"requireRegisteredType\"))\n      Module[\"requireRegisteredType\"] = function() {\n        abort(\"'requireRegisteredType' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"getShiftFromSize\"))\n      Module[\"getShiftFromSize\"] = function() {\n        abort(\"'getShiftFromSize' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"integerReadValueFromPointer\"))\n      Module[\"integerReadValueFromPointer\"] = function() {\n        abort(\"'integerReadValueFromPointer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"enumReadValueFromPointer\"))\n      Module[\"enumReadValueFromPointer\"] = function() {\n        abort(\"'enumReadValueFromPointer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"floatReadValueFromPointer\"))\n      Module[\"floatReadValueFromPointer\"] = function() {\n        abort(\"'floatReadValueFromPointer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"simpleReadValueFromPointer\"))\n      Module[\"simpleReadValueFromPointer\"] = function() {\n        abort(\"'simpleReadValueFromPointer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"runDestructors\"))\n      Module[\"runDestructors\"] = function() {\n        abort(\"'runDestructors' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"new_\"))\n      Module[\"new_\"] = function() {\n        abort(\"'new_' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"craftInvokerFunction\"))\n      Module[\"craftInvokerFunction\"] = function() {\n        abort(\"'craftInvokerFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"embind__requireFunction\"))\n      Module[\"embind__requireFunction\"] = function() {\n        abort(\"'embind__requireFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"tupleRegistrations\"))\n      Module[\"tupleRegistrations\"] = function() {\n        abort(\"'tupleRegistrations' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"structRegistrations\"))\n      Module[\"structRegistrations\"] = function() {\n        abort(\"'structRegistrations' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"genericPointerToWireType\"))\n      Module[\"genericPointerToWireType\"] = function() {\n        abort(\"'genericPointerToWireType' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"constNoSmartPtrRawPointerToWireType\"))\n      Module[\"constNoSmartPtrRawPointerToWireType\"] = function() {\n        abort(\"'constNoSmartPtrRawPointerToWireType' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"nonConstNoSmartPtrRawPointerToWireType\"))\n      Module[\"nonConstNoSmartPtrRawPointerToWireType\"] = function() {\n        abort(\"'nonConstNoSmartPtrRawPointerToWireType' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"init_RegisteredPointer\"))\n      Module[\"init_RegisteredPointer\"] = function() {\n        abort(\"'init_RegisteredPointer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"RegisteredPointer\"))\n      Module[\"RegisteredPointer\"] = function() {\n        abort(\"'RegisteredPointer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"RegisteredPointer_getPointee\"))\n      Module[\"RegisteredPointer_getPointee\"] = function() {\n        abort(\"'RegisteredPointer_getPointee' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"RegisteredPointer_destructor\"))\n      Module[\"RegisteredPointer_destructor\"] = function() {\n        abort(\"'RegisteredPointer_destructor' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"RegisteredPointer_deleteObject\"))\n      Module[\"RegisteredPointer_deleteObject\"] = function() {\n        abort(\"'RegisteredPointer_deleteObject' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"RegisteredPointer_fromWireType\"))\n      Module[\"RegisteredPointer_fromWireType\"] = function() {\n        abort(\"'RegisteredPointer_fromWireType' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"runDestructor\"))\n      Module[\"runDestructor\"] = function() {\n        abort(\"'runDestructor' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"releaseClassHandle\"))\n      Module[\"releaseClassHandle\"] = function() {\n        abort(\"'releaseClassHandle' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"finalizationGroup\"))\n      Module[\"finalizationGroup\"] = function() {\n        abort(\"'finalizationGroup' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"detachFinalizer_deps\"))\n      Module[\"detachFinalizer_deps\"] = function() {\n        abort(\"'detachFinalizer_deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"detachFinalizer\"))\n      Module[\"detachFinalizer\"] = function() {\n        abort(\"'detachFinalizer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"attachFinalizer\"))\n      Module[\"attachFinalizer\"] = function() {\n        abort(\"'attachFinalizer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"makeClassHandle\"))\n      Module[\"makeClassHandle\"] = function() {\n        abort(\"'makeClassHandle' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"init_ClassHandle\"))\n      Module[\"init_ClassHandle\"] = function() {\n        abort(\"'init_ClassHandle' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"ClassHandle\"))\n      Module[\"ClassHandle\"] = function() {\n        abort(\"'ClassHandle' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"ClassHandle_isAliasOf\"))\n      Module[\"ClassHandle_isAliasOf\"] = function() {\n        abort(\"'ClassHandle_isAliasOf' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"throwInstanceAlreadyDeleted\"))\n      Module[\"throwInstanceAlreadyDeleted\"] = function() {\n        abort(\"'throwInstanceAlreadyDeleted' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"ClassHandle_clone\"))\n      Module[\"ClassHandle_clone\"] = function() {\n        abort(\"'ClassHandle_clone' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"ClassHandle_delete\"))\n      Module[\"ClassHandle_delete\"] = function() {\n        abort(\"'ClassHandle_delete' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"deletionQueue\"))\n      Module[\"deletionQueue\"] = function() {\n        abort(\"'deletionQueue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"ClassHandle_isDeleted\"))\n      Module[\"ClassHandle_isDeleted\"] = function() {\n        abort(\"'ClassHandle_isDeleted' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"ClassHandle_deleteLater\"))\n      Module[\"ClassHandle_deleteLater\"] = function() {\n        abort(\"'ClassHandle_deleteLater' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"flushPendingDeletes\"))\n      Module[\"flushPendingDeletes\"] = function() {\n        abort(\"'flushPendingDeletes' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"delayFunction\"))\n      Module[\"delayFunction\"] = function() {\n        abort(\"'delayFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"setDelayFunction\"))\n      Module[\"setDelayFunction\"] = function() {\n        abort(\"'setDelayFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"RegisteredClass\"))\n      Module[\"RegisteredClass\"] = function() {\n        abort(\"'RegisteredClass' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"shallowCopyInternalPointer\"))\n      Module[\"shallowCopyInternalPointer\"] = function() {\n        abort(\"'shallowCopyInternalPointer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"downcastPointer\"))\n      Module[\"downcastPointer\"] = function() {\n        abort(\"'downcastPointer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"upcastPointer\"))\n      Module[\"upcastPointer\"] = function() {\n        abort(\"'upcastPointer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"validateThis\"))\n      Module[\"validateThis\"] = function() {\n        abort(\"'validateThis' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"char_0\"))\n      Module[\"char_0\"] = function() {\n        abort(\"'char_0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"char_9\"))\n      Module[\"char_9\"] = function() {\n        abort(\"'char_9' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"makeLegalFunctionName\"))\n      Module[\"makeLegalFunctionName\"] = function() {\n        abort(\"'makeLegalFunctionName' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"warnOnce\"))\n      Module[\"warnOnce\"] = function() {\n        abort(\"'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"stackSave\"))\n      Module[\"stackSave\"] = function() {\n        abort(\"'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"stackRestore\"))\n      Module[\"stackRestore\"] = function() {\n        abort(\"'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"stackAlloc\"))\n      Module[\"stackAlloc\"] = function() {\n        abort(\"'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"AsciiToString\"))\n      Module[\"AsciiToString\"] = function() {\n        abort(\"'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"stringToAscii\"))\n      Module[\"stringToAscii\"] = function() {\n        abort(\"'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"UTF16ToString\"))\n      Module[\"UTF16ToString\"] = function() {\n        abort(\"'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF16\"))\n      Module[\"stringToUTF16\"] = function() {\n        abort(\"'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"lengthBytesUTF16\"))\n      Module[\"lengthBytesUTF16\"] = function() {\n        abort(\"'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"UTF32ToString\"))\n      Module[\"UTF32ToString\"] = function() {\n        abort(\"'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF32\"))\n      Module[\"stringToUTF32\"] = function() {\n        abort(\"'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"lengthBytesUTF32\"))\n      Module[\"lengthBytesUTF32\"] = function() {\n        abort(\"'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"allocateUTF8\"))\n      Module[\"allocateUTF8\"] = function() {\n        abort(\"'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    if (!Object.getOwnPropertyDescriptor(Module, \"allocateUTF8OnStack\"))\n      Module[\"allocateUTF8OnStack\"] = function() {\n        abort(\"'allocateUTF8OnStack' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      };\n    Module[\"writeStackCookie\"] = writeStackCookie;\n    Module[\"checkStackCookie\"] = checkStackCookie;\n    Module[\"abortStackOverflow\"] = abortStackOverflow;\n    if (!Object.getOwnPropertyDescriptor(Module, \"ALLOC_NORMAL\"))\n      Object.defineProperty(Module, \"ALLOC_NORMAL\", {\n        configurable: true,\n        get: function() {\n          abort(\"'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n        }\n      });\n    if (!Object.getOwnPropertyDescriptor(Module, \"ALLOC_STACK\"))\n      Object.defineProperty(Module, \"ALLOC_STACK\", {\n        configurable: true,\n        get: function() {\n          abort(\"'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n        }\n      });\n    if (!Object.getOwnPropertyDescriptor(Module, \"ALLOC_DYNAMIC\"))\n      Object.defineProperty(Module, \"ALLOC_DYNAMIC\", {\n        configurable: true,\n        get: function() {\n          abort(\"'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n        }\n      });\n    if (!Object.getOwnPropertyDescriptor(Module, \"ALLOC_NONE\"))\n      Object.defineProperty(Module, \"ALLOC_NONE\", {\n        configurable: true,\n        get: function() {\n          abort(\"'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n        }\n      });\n    var calledRun;\n    Module[\"then\"] = function(func) {\n      if (calledRun) {\n        func(Module);\n      } else {\n        var old = Module[\"onRuntimeInitialized\"];\n        Module[\"onRuntimeInitialized\"] = function() {\n          if (old)\n            old();\n          func(Module);\n        };\n      }\n      return Module;\n    };\n    function ExitStatus(status) {\n      this.name = \"ExitStatus\";\n      this.message = \"Program terminated with exit(\" + status + \")\";\n      this.status = status;\n    }\n    dependenciesFulfilled = function runCaller() {\n      if (!calledRun)\n        run();\n      if (!calledRun)\n        dependenciesFulfilled = runCaller;\n    };\n    function run(args) {\n      if (runDependencies > 0) {\n        return;\n      }\n      writeStackCookie();\n      preRun();\n      if (runDependencies > 0)\n        return;\n      function doRun() {\n        if (calledRun)\n          return;\n        calledRun = true;\n        Module[\"calledRun\"] = true;\n        if (ABORT)\n          return;\n        initRuntime();\n        preMain();\n        if (Module[\"onRuntimeInitialized\"])\n          Module[\"onRuntimeInitialized\"]();\n        assert(!Module[\"_main\"], 'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]');\n        postRun();\n      }\n      if (Module[\"setStatus\"]) {\n        Module[\"setStatus\"](\"Running...\");\n        setTimeout(function() {\n          setTimeout(function() {\n            Module[\"setStatus\"](\"\");\n          }, 1);\n          doRun();\n        }, 1);\n      } else {\n        doRun();\n      }\n      checkStackCookie();\n    }\n    Module[\"run\"] = run;\n    if (Module[\"preInit\"]) {\n      if (typeof Module[\"preInit\"] == \"function\")\n        Module[\"preInit\"] = [Module[\"preInit\"]];\n      while (Module[\"preInit\"].length > 0) {\n        Module[\"preInit\"].pop()();\n      }\n    }\n    run();\n    return FaustModule2;\n  };\n}();\nvar Sha1 = {};\nSha1.hash = function(msg, utf8encode) {\n  utf8encode = typeof utf8encode == \"undefined\" ? true : utf8encode;\n  if (utf8encode)\n    msg = Utf8.encode(msg);\n  var K = [1518500249, 1859775393, 2400959708, 3395469782];\n  msg += String.fromCharCode(128);\n  var l = msg.length / 4 + 2;\n  var N = Math.ceil(l / 16);\n  var M = new Array(N);\n  for (var i = 0; i < N; i++) {\n    M[i] = new Array(16);\n    for (var j = 0; j < 16; j++) {\n      M[i][j] = msg.charCodeAt(i * 64 + j * 4) << 24 | msg.charCodeAt(i * 64 + j * 4 + 1) << 16 | msg.charCodeAt(i * 64 + j * 4 + 2) << 8 | msg.charCodeAt(i * 64 + j * 4 + 3);\n    }\n  }\n  M[N - 1][14] = (msg.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (msg.length - 1) * 8 & 4294967295;\n  var H0 = 1732584193;\n  var H1 = 4023233417;\n  var H2 = 2562383102;\n  var H3 = 271733878;\n  var H4 = 3285377520;\n  var W = new Array(80);\n  var a, b, c, d, e;\n  for (var i = 0; i < N; i++) {\n    for (var t = 0; t < 16; t++)\n      W[t] = M[i][t];\n    for (var t = 16; t < 80; t++)\n      W[t] = Sha1.ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n    a = H0;\n    b = H1;\n    c = H2;\n    d = H3;\n    e = H4;\n    for (var t = 0; t < 80; t++) {\n      var s = Math.floor(t / 20);\n      var T = Sha1.ROTL(a, 5) + Sha1.f(s, b, c, d) + e + K[s] + W[t] & 4294967295;\n      e = d;\n      d = c;\n      c = Sha1.ROTL(b, 30);\n      b = a;\n      a = T;\n    }\n    H0 = H0 + a & 4294967295;\n    H1 = H1 + b & 4294967295;\n    H2 = H2 + c & 4294967295;\n    H3 = H3 + d & 4294967295;\n    H4 = H4 + e & 4294967295;\n  }\n  return Sha1.toHexStr(H0) + Sha1.toHexStr(H1) + Sha1.toHexStr(H2) + Sha1.toHexStr(H3) + Sha1.toHexStr(H4);\n};\nSha1.f = function(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n    case 1:\n      return x ^ y ^ z;\n    case 2:\n      return x & y ^ x & z ^ y & z;\n    case 3:\n      return x ^ y ^ z;\n  }\n};\nSha1.ROTL = function(x, n) {\n  return x << n | x >>> 32 - n;\n};\nSha1.toHexStr = function(n) {\n  var s = \"\", v;\n  for (var i = 7; i >= 0; i--) {\n    v = n >>> i * 4 & 15;\n    s += v.toString(16);\n  }\n  return s;\n};\nvar Utf8 = {};\nUtf8.encode = function(strUni) {\n  var strUtf = strUni.replace(/[\\u0080-\\u07ff]/g, function(c) {\n    var cc = c.charCodeAt(0);\n    return String.fromCharCode(192 | cc >> 6, 128 | cc & 63);\n  });\n  strUtf = strUtf.replace(/[\\u0800-\\uffff]/g, function(c) {\n    var cc = c.charCodeAt(0);\n    return String.fromCharCode(224 | cc >> 12, 128 | cc >> 6 & 63, 128 | cc & 63);\n  });\n  return strUtf;\n};\nUtf8.decode = function(strUtf) {\n  var strUni = strUtf.replace(/[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g, function(c) {\n    var cc = (c.charCodeAt(0) & 15) << 12 | (c.charCodeAt(1) & 63) << 6 | c.charCodeAt(2) & 63;\n    return String.fromCharCode(cc);\n  });\n  strUni = strUni.replace(/[\\u00c0-\\u00df][\\u0080-\\u00bf]/g, function(c) {\n    var cc = (c.charCodeAt(0) & 31) << 6 | c.charCodeAt(1) & 63;\n    return String.fromCharCode(cc);\n  });\n  return strUni;\n};\nvar readyResolver = {\n  current: void 0\n};\nvar readyPromise = new Promise((resolve) => {\n  readyResolver.current = resolve;\n});\nvar faust_module$1 = FaustModule({\n  onRuntimeInitialized: readyResolver.current\n});\nfaust_module$1.lengthBytesUTF8 = function(str) {\n  var len = 0;\n  for (var i = 0; i < str.length; ++i) {\n    var u = str.charCodeAt(i);\n    if (u >= 55296 && u <= 57343)\n      u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;\n    if (u <= 127) {\n      ++len;\n    } else if (u <= 2047) {\n      len += 2;\n    } else if (u <= 65535) {\n      len += 3;\n    } else if (u <= 2097151) {\n      len += 4;\n    } else if (u <= 67108863) {\n      len += 5;\n    } else {\n      len += 6;\n    }\n  }\n  return len;\n};\nvar faust = faust || {};\nfaust.remap = function(v, mn0, mx0, mn1, mx1) {\n  return 1 * (v - mn0) / (mx0 - mn0) * (mx1 - mn1) + mn1;\n};\nfaust.debug = false;\nfaust.createWasmCDSPFactoryFromString = faust_module$1.cwrap(\"createWasmCDSPFactoryFromString\", \"number\", [\"number\", \"number\", \"number\", \"number\", \"number\", \"number\"]);\nfaust.deleteAllWasmCDSPFactories = faust_module$1.cwrap(\"deleteAllWasmCDSPFactories\", null, []);\nfaust.expandCDSPFromString = faust_module$1.cwrap(\"expandCDSPFromString\", \"number\", [\"number\", \"number\", \"number\", \"number\", \"number\", \"number\"]);\nfaust.getCLibFaustVersion = faust_module$1.cwrap(\"getCLibFaustVersion\", \"number\", []);\nfaust.getWasmCModule = faust_module$1.cwrap(\"getWasmCModule\", \"number\", [\n  \"number\"\n]);\nfaust.getWasmCModuleSize = faust_module$1.cwrap(\"getWasmCModuleSize\", \"number\", [\n  \"number\"\n]);\nfaust.getWasmCHelpers = faust_module$1.cwrap(\"getWasmCHelpers\", \"number\", [\n  \"number\"\n]);\nfaust.freeWasmCModule = faust_module$1.cwrap(\"freeWasmCModule\", null, [\"number\"]);\nfaust.freeCMemory = faust_module$1.cwrap(\"freeCMemory\", null, [\"number\"]);\nfaust.cleanupAfterException = faust_module$1.cwrap(\"cleanupAfterException\", null, []);\nfaust.getErrorAfterException = faust_module$1.cwrap(\"getErrorAfterException\", \"number\", []);\nfaust.error_msg = null;\nfaust.factory_number = 0;\nfaust.factory_table = [];\nfaust.getErrorMessage = function() {\n  return faust.error_msg;\n};\nfaust.getLibFaustVersion = function() {\n  return faust_module$1.UTF8ToString(faust.getCLibFaustVersion());\n};\nfaust.ab2str = function(buf) {\n  if (buf) {\n    return String.fromCharCode.apply(null, new Uint8Array(buf));\n  } else {\n    return null;\n  }\n};\nfaust.str2ab = function(str) {\n  if (str) {\n    var buf = new ArrayBuffer(str.length);\n    var bufView = new Uint8Array(buf);\n    for (var i = 0, strLen = str.length; i < strLen; i++) {\n      bufView[i] = str.charCodeAt(i);\n    }\n    return buf;\n  } else {\n    return null;\n  }\n};\nfaust.compileCode = function(factory_name, code, argv, internal_memory) {\n  var code_size = faust_module$1.lengthBytesUTF8(code) + 1;\n  var code_ptr = faust_module$1._malloc(code_size);\n  var name = \"FaustDSP\";\n  var name_size = faust_module$1.lengthBytesUTF8(name) + 1;\n  var name_ptr = faust_module$1._malloc(name_size);\n  var error_msg_ptr = faust_module$1._malloc(4096);\n  faust_module$1.stringToUTF8(name, name_ptr, name_size);\n  faust_module$1.stringToUTF8(code, code_ptr, code_size);\n  var argv_aux = argv === void 0 ? new Array() : argv;\n  argv_aux.push(\"-cn\", factory_name);\n  var ptr_size = 4;\n  var argv_ptr = faust_module$1._malloc(argv_aux.length * ptr_size);\n  var argv_ptr_buffer = new Int32Array(faust_module$1.HEAP32.buffer, argv_ptr, argv_aux.length);\n  for (var i = 0; i < argv_aux.length; i++) {\n    var arg_ptr_size = faust_module$1.lengthBytesUTF8(argv_aux[i]) + 1;\n    var arg_ptr = faust_module$1._malloc(arg_ptr_size);\n    faust_module$1.stringToUTF8(argv_aux[i], arg_ptr, arg_ptr_size);\n    argv_ptr_buffer[i] = arg_ptr;\n  }\n  try {\n    var module_code_ptr = faust.createWasmCDSPFactoryFromString(name_ptr, code_ptr, argv_aux.length, argv_ptr, error_msg_ptr, internal_memory);\n    faust.error_msg = faust_module$1.UTF8ToString(error_msg_ptr);\n    if (module_code_ptr === 0) {\n      return null;\n    } else {\n      var factory_code_ptr = faust.getWasmCModule(module_code_ptr);\n      var factory_code_size = faust.getWasmCModuleSize(module_code_ptr);\n      var factory_code = new Uint8Array(factory_code_size);\n      for (var i = 0; i < factory_code_size; i++) {\n        factory_code[i] = faust_module$1.HEAP8[factory_code_ptr + i];\n      }\n      var helpers_code_ptr = faust.getWasmCHelpers(module_code_ptr);\n      var helpers_code = faust_module$1.UTF8ToString(helpers_code_ptr);\n      faust_module$1._free(code_ptr);\n      faust_module$1._free(name_ptr);\n      faust_module$1._free(error_msg_ptr);\n      faust.freeWasmCModule(module_code_ptr);\n      argv_ptr_buffer = new Int32Array(faust_module$1.HEAP32.buffer, argv_ptr, argv_aux.length);\n      for (var i = 0; i < argv_aux.length; i++) {\n        faust_module$1._free(argv_ptr_buffer[i]);\n      }\n      faust_module$1._free(argv_ptr);\n      return { code: factory_code, code_source: code, helpers: helpers_code };\n    }\n  } catch (e) {\n    faust.error_msg = faust_module$1.UTF8ToString(faust.getErrorAfterException());\n    if (faust.error_msg === \"\") {\n      faust.error_msg = e;\n    }\n    faust.cleanupAfterException();\n    return null;\n  }\n};\nfaust.createDSPFactoryAux = function(code, argv, internal_memory, callback2) {\n  var argv_str = \"\";\n  for (var i = 0; i < argv.length; i++) {\n    argv_str += argv[i];\n  }\n  var sha_key2 = Sha1.hash(code + (internal_memory ? \"internal_memory\" : \"external_memory\") + argv_str, true);\n  var factory2 = faust.factory_table[sha_key2];\n  if (factory2) {\n    callback2(factory2);\n    return;\n  }\n  var factory_name12 = \"mydsp\" + faust.factory_number;\n  var factory_name22 = \"effect\" + faust.factory_number++;\n  var code_effect = \"adapt(1,1) = _; adapt(2,2) = _,_; adapt(1,2) = _ <: _,_; adapt(2,1) = _,_ :> _; adaptor(F,G) = adapt(outputs(F),inputs(G)); dsp_code = environment{\";\n  code_effect = code_effect.concat(code);\n  code_effect = code_effect.concat(\"};\");\n  code_effect = code_effect.concat(\"process = adaptor(dsp_code.process, dsp_code.effect) : dsp_code.effect;\");\n  var res1 = faust.compileCode(factory_name12, code, argv, internal_memory);\n  if (res1) {\n    var res2 = faust.compileCode(factory_name22, code_effect, argv, internal_memory);\n    if (res2) {\n      faust.readDSPFactoryFromMachineAux(factory_name12, res1.code, res1.code_source, res1.helpers, factory_name22, res2.code, res2.code_source, res2.helpers, sha_key2, callback2);\n    } else {\n      faust.readDSPFactoryFromMachineAux(factory_name12, res1.code, res1.code_source, res1.helpers, null, null, null, null, sha_key2, callback2);\n    }\n  } else {\n    callback2(null);\n  }\n};\nfaust.createDSPFactory = function(code, argv, callback2) {\n  readyPromise.then(() => {\n    faust.createDSPFactoryAux(code, argv, true, callback2);\n  });\n};\nfaust.ready = readyPromise;\nfaust.expandDSP = function(code, argv) {\n  argv.push(\"-lang\");\n  argv.push(\"wasm\");\n  var code_size = faust_module$1.lengthBytesUTF8(code) + 1;\n  var code_ptr = faust_module$1._malloc(code_size);\n  var name = \"FaustDSP\";\n  var name_size = faust_module$1.lengthBytesUTF8(name) + 1;\n  var name_ptr = faust_module$1._malloc(name_size);\n  var sha_key_ptr = faust_module$1._malloc(64);\n  var error_msg_ptr = faust_module$1._malloc(4096);\n  faust_module$1.stringToUTF8(name, name_ptr, name_size);\n  faust_module$1.stringToUTF8(code, code_ptr, code_size);\n  argv = argv === void 0 ? new Array() : argv;\n  var ptr_size = 4;\n  var argv_ptr = faust_module$1._malloc(argv.length * ptr_size);\n  var argv_ptr_buffer = new Int32Array(faust_module$1.HEAP32.buffer, argv_ptr, argv.length);\n  for (var i = 0; i < argv.length; i++) {\n    var arg_ptr_size = faust_module$1.lengthBytesUTF8(argv[i]) + 1;\n    var arg_ptr = faust_module$1._malloc(arg_ptr_size);\n    faust_module$1.stringToUTF8(argv[i], arg_ptr, arg_ptr_size);\n    argv_ptr_buffer[i] = arg_ptr;\n  }\n  try {\n    var expand_dsp_ptr = faust.expandCDSPFromString(name_ptr, code_ptr, argv.length, argv_ptr, sha_key_ptr, error_msg_ptr);\n    var expand_dsp = faust_module$1.UTF8ToString(expand_dsp_ptr);\n    var sha_key2 = faust_module$1.UTF8ToString(sha_key_ptr);\n    faust.error_msg = faust_module$1.UTF8ToString(error_msg_ptr);\n    faust_module$1._free(code_ptr);\n    faust_module$1._free(name_ptr);\n    faust_module$1._free(sha_key_ptr);\n    faust_module$1._free(error_msg_ptr);\n    faust.freeCMemory(expand_dsp_ptr);\n    argv_ptr_buffer = new Int32Array(faust_module$1.HEAP32.buffer, argv_ptr, argv.length);\n    for (var i = 0; i < argv.length; i++) {\n      faust_module$1._free(argv_ptr_buffer[i]);\n    }\n    faust_module$1._free(argv_ptr);\n    return expand_dsp;\n  } catch (e) {\n    faust.error_msg = faust_module$1.UTF8ToString(faust.getErrorAfterException());\n    if (faust.error_msg === \"\") {\n      faust.error_msg = e;\n    }\n    faust.cleanupAfterException();\n    return null;\n  }\n};\nfaust.writeDSPFactoryToMachine = function(factory2) {\n  return {\n    name: factory2.name,\n    code: faust.ab2str(factory2.code),\n    code_source: factory2.code_source,\n    helpers: factory2.helpers,\n    name_effect: factory2.name_effect,\n    code_effect: faust.ab2str(factory2.code_effect),\n    code_source_effect: factory2.code_source_effect,\n    helpers_effect: factory2.helpers_effect\n  };\n};\nfaust.readDSPFactoryFromMachine = function(machine, callback2) {\n  var sha_key2 = Sha1.hash(machine.code_source, true);\n  var factory2 = faust.factory_table[sha_key2];\n  if (factory2) {\n    callback2(factory2);\n  } else {\n    faust.readDSPFactoryFromMachineAux(machine.name, faust.str2ab(machine.code), machine.code_source, machine.helpers, machine.name_effect, faust.str2ab(machine.code_effect), machine.code_source_effect, machine.helpers_effect, sha_key2, callback2);\n  }\n};\nfaust.readDSPFactoryFromMachineAux = function(factory_name1, factory_code1, factory_code_source1, helpers_code1, factory_name2, factory_code2, factory_code_source2, helpers_code2, sha_key, callback) {\n  WebAssembly.compile(factory_code1).then((module) => {\n    var factory = {};\n    factory.polyphony = [];\n    factory.code = factory_code1;\n    factory.code_source = factory_code_source1;\n    factory.helpers = helpers_code1;\n    factory.module = module;\n    var jsToEval = helpers_code1 + \"\\nreturn [getJSON\" + factory_name1 + \", getBase64Code\" + factory_name1 + \"];\";\n    var evalResult = new Function(jsToEval)();\n    factory.getJSON = evalResult[0];\n    factory.getBase64Code = evalResult[1];\n    try {\n      factory.json_object = JSON.parse(factory.getJSON());\n    } catch (e) {\n      faust.error_msg = \"Error in JSON.parse: \" + e;\n      callback(null);\n      throw true;\n    }\n    factory.name = factory_name1;\n    factory.sha_key = sha_key;\n    faust.factory_table[sha_key] = factory;\n    if (factory_name2) {\n      WebAssembly.compile(factory_code2).then((module_effect) => {\n        factory.code_effect = factory_code2;\n        factory.code_source_effect = factory_code_source2;\n        factory.helpers_effect = helpers_code2;\n        factory.module_effect = module_effect;\n        eval(helpers_code2);\n        factory.getJSONeffect = eval(\"getJSON\" + factory_name2);\n        factory.getBase64Codeeffect = eval(\"getBase64Code\" + factory_name2);\n        try {\n          factory.effect_json_object = JSON.parse(factory.getJSONeffect());\n        } catch (e) {\n          faust.error_msg = \"Error in JSON.parse: \" + e;\n          callback(null);\n          throw true;\n        }\n        factory.name_effect = factory_name2;\n        callback(factory);\n      }).catch(function(error) {\n        faust.error_msg = \"Faust DSP factory cannot be compiled\";\n        callback(null);\n      });\n    } else {\n      callback(factory);\n    }\n  }).catch(function(error) {\n    faust.error_msg = \"Faust DSP factory cannot be compiled\";\n    callback(null);\n  });\n};\nfaust.deleteDSPFactory = function(factory2) {\n  faust.factory_table[factory2.sha_key] = null;\n};\nfaust.createDSPInstance = function(factory2, context, buffer_size, callback2) {\n  context.resume();\n  var importObject = {\n    env: {\n      memoryBase: 0,\n      tableBase: 0,\n      _abs: Math.abs,\n      _acosf: Math.acos,\n      _asinf: Math.asin,\n      _atanf: Math.atan,\n      _atan2f: Math.atan2,\n      _ceilf: Math.ceil,\n      _cosf: Math.cos,\n      _expf: Math.exp,\n      _floorf: Math.floor,\n      _fmodf: function(x, y) {\n        return x % y;\n      },\n      _logf: Math.log,\n      _log10f: Math.log10,\n      _max_f: Math.max,\n      _min_f: Math.min,\n      _remainderf: function(x, y) {\n        return x - Math.round(x / y) * y;\n      },\n      _powf: Math.pow,\n      _roundf: Math.fround,\n      _sinf: Math.sin,\n      _sqrtf: Math.sqrt,\n      _tanf: Math.tan,\n      _acoshf: Math.acosh,\n      _asinhf: Math.asinh,\n      _atanhf: Math.atanh,\n      _coshf: Math.cosh,\n      _sinhf: Math.sinh,\n      _tanhf: Math.tanh,\n      _isnanf: Number.isNaN,\n      _isinff: function(x) {\n        return !isFinite(x);\n      },\n      _copysignf: function(x, y) {\n        return Math.sign(x) === Math.sign(y) ? x : -x;\n      },\n      _acos: Math.acos,\n      _asin: Math.asin,\n      _atan: Math.atan,\n      _atan2: Math.atan2,\n      _ceil: Math.ceil,\n      _cos: Math.cos,\n      _exp: Math.exp,\n      _floor: Math.floor,\n      _fmod: function(x, y) {\n        return x % y;\n      },\n      _log: Math.log,\n      _log10: Math.log10,\n      _max_: Math.max,\n      _min_: Math.min,\n      _remainder: function(x, y) {\n        return x - Math.round(x / y) * y;\n      },\n      _pow: Math.pow,\n      _round: Math.fround,\n      _sin: Math.sin,\n      _sqrt: Math.sqrt,\n      _tan: Math.tan,\n      _acosh: Math.acosh,\n      _asinh: Math.asinh,\n      _atanh: Math.atanh,\n      _cosh: Math.cosh,\n      _sinh: Math.sinh,\n      _tanh: Math.tanh,\n      _isnan: Number.isNaN,\n      _isinf: function(x) {\n        return !isFinite(x);\n      },\n      _copysign: function(x, y) {\n        return Math.sign(x) === Math.sign(y) ? x : -x;\n      },\n      table: new WebAssembly.Table({ initial: 0, element: \"anyfunc\" })\n    }\n  };\n  performance.now();\n  WebAssembly.instantiate(factory2.module, importObject).then((dsp_instance) => {\n    performance.now();\n    var sp;\n    try {\n      sp = context.createScriptProcessor(buffer_size, dsp_instance.exports.getNumInputs(0), dsp_instance.exports.getNumOutputs(0));\n    } catch (e) {\n      faust.error_msg = \"Error in createScriptProcessor: \" + e;\n      callback2(null);\n      return;\n    }\n    sp.output_handler = null;\n    sp.ins = null;\n    sp.outs = null;\n    sp.compute_handler = null;\n    sp.dspInChannnels = [];\n    sp.dspOutChannnels = [];\n    sp.fPitchwheelLabel = [];\n    sp.fCtrlLabel = new Array(128);\n    for (var i = 0; i < sp.fCtrlLabel.length; i++) {\n      sp.fCtrlLabel[i] = [];\n    }\n    sp.outputs_timer = 5;\n    sp.outputs_items = [];\n    sp.inputs_items = [];\n    sp.ptr_size = 4;\n    sp.sample_size = 4;\n    sp.dsp = 0;\n    sp.pathTable = [];\n    sp.factory = dsp_instance.exports;\n    sp.HEAP = dsp_instance.exports.memory.buffer;\n    sp.HEAP32 = new Int32Array(sp.HEAP);\n    sp.HEAPF32 = new Float32Array(sp.HEAP);\n    sp.numIn = sp.factory.getNumInputs(sp.dsp);\n    sp.numOut = sp.factory.getNumOutputs(sp.dsp);\n    sp.audio_heap_ptr = parseInt(factory2.json_object.size);\n    sp.audio_heap_ptr_inputs = sp.audio_heap_ptr;\n    sp.audio_heap_ptr_outputs = sp.audio_heap_ptr_inputs + sp.numIn * sp.ptr_size;\n    sp.audio_heap_inputs = sp.audio_heap_ptr_outputs + sp.numOut * sp.ptr_size;\n    sp.audio_heap_outputs = sp.audio_heap_inputs + sp.numIn * buffer_size * sp.sample_size;\n    sp.update_outputs = function() {\n      if (sp.outputs_items.length > 0 && sp.output_handler && sp.outputs_timer-- === 0) {\n        sp.outputs_timer = 5;\n        for (var i2 = 0; i2 < sp.outputs_items.length; i2++) {\n          sp.output_handler(sp.outputs_items[i2], sp.factory.getParamValue(sp.dsp, sp.pathTable[sp.outputs_items[i2]]));\n        }\n      }\n    };\n    sp.compute = function(e) {\n      var i2;\n      for (i2 = 0; i2 < sp.numIn; i2++) {\n        var input = e.inputBuffer.getChannelData(i2);\n        var dspInput = sp.dspInChannnels[i2];\n        dspInput.set(input);\n      }\n      if (sp.compute_handler) {\n        sp.compute_handler(buffer_size);\n      }\n      sp.factory.compute(sp.dsp, buffer_size, sp.ins, sp.outs);\n      sp.update_outputs();\n      for (i2 = 0; i2 < sp.numOut; i2++) {\n        var output = e.outputBuffer.getChannelData(i2);\n        var dspOutput = sp.dspOutChannnels[i2];\n        output.set(dspOutput);\n      }\n    };\n    sp.parse_ui = function(ui) {\n      for (var i2 = 0; i2 < ui.length; i2++) {\n        sp.parse_group(ui[i2]);\n      }\n    };\n    sp.parse_group = function(group) {\n      if (group.items) {\n        sp.parse_items(group.items);\n      }\n    };\n    sp.parse_items = function(items) {\n      for (var i2 = 0; i2 < items.length; i2++) {\n        sp.parse_item(items[i2]);\n      }\n    };\n    sp.parse_item = function(item) {\n      if (item.type === \"vgroup\" || item.type === \"hgroup\" || item.type === \"tgroup\") {\n        sp.parse_items(item.items);\n      } else if (item.type === \"hbargraph\" || item.type === \"vbargraph\") {\n        sp.outputs_items.push(item.address);\n        sp.pathTable[item.address] = parseInt(item.index);\n      } else if (item.type === \"vslider\" || item.type === \"hslider\" || item.type === \"button\" || item.type === \"checkbox\" || item.type === \"nentry\") {\n        sp.inputs_items.push(item.address);\n        sp.pathTable[item.address] = parseInt(item.index);\n        if (item.meta !== void 0) {\n          for (var i2 = 0; i2 < item.meta.length; i2++) {\n            if (item.meta[i2].style !== void 0) {\n              sp.inputs_meta[item.address] = item.meta[i2].style;\n            }\n            if (item.meta[i2].midi !== void 0) {\n              if (item.meta[i2].midi.trim() === \"pitchwheel\") {\n                sp.fPitchwheelLabel.push({\n                  path: item.address,\n                  min: parseFloat(item.min),\n                  max: parseFloat(item.max)\n                });\n              } else if (item.meta[i2].midi.trim().split(\" \")[0] === \"ctrl\") {\n                sp.fCtrlLabel[parseInt(item.meta[i2].midi.trim().split(\" \")[1])].push({\n                  path: item.address,\n                  min: parseFloat(item.min),\n                  max: parseFloat(item.max)\n                });\n              }\n            }\n          }\n        }\n      }\n    };\n    sp.initAux = function() {\n      var i2;\n      sp.onaudioprocess = sp.compute;\n      if (sp.numIn > 0) {\n        sp.ins = sp.audio_heap_ptr_inputs;\n        for (i2 = 0; i2 < sp.numIn; i2++) {\n          sp.HEAP32[(sp.ins >> 2) + i2] = sp.audio_heap_inputs + buffer_size * sp.sample_size * i2;\n        }\n        var dspInChans = sp.HEAP32.subarray(sp.ins >> 2, sp.ins + sp.numIn * sp.ptr_size >> 2);\n        for (i2 = 0; i2 < sp.numIn; i2++) {\n          sp.dspInChannnels[i2] = sp.HEAPF32.subarray(dspInChans[i2] >> 2, dspInChans[i2] + buffer_size * sp.sample_size >> 2);\n        }\n      }\n      if (sp.numOut > 0) {\n        sp.outs = sp.audio_heap_ptr_outputs;\n        for (i2 = 0; i2 < sp.numOut; i2++) {\n          sp.HEAP32[(sp.outs >> 2) + i2] = sp.audio_heap_outputs + buffer_size * sp.sample_size * i2;\n        }\n        var dspOutChans = sp.HEAP32.subarray(sp.outs >> 2, sp.outs + sp.numOut * sp.ptr_size >> 2);\n        for (i2 = 0; i2 < sp.numOut; i2++) {\n          sp.dspOutChannnels[i2] = sp.HEAPF32.subarray(dspOutChans[i2] >> 2, dspOutChans[i2] + buffer_size * sp.sample_size >> 2);\n        }\n      }\n      sp.parse_ui(factory2.json_object.ui);\n      sp.factory.init(sp.dsp, context.sampleRate);\n    };\n    sp.destroy = function() {\n    };\n    sp.getSampleRate = function() {\n      return context.sampleRate;\n    };\n    sp.getNumInputs = function() {\n      return sp.factory.getNumInputs(sp.dsp);\n    };\n    sp.getNumOutputs = function() {\n      return sp.factory.getNumOutputs(sp.dsp);\n    };\n    sp.init = function(sample_rate) {\n      sp.factory.init(sp.dsp, sample_rate);\n    };\n    sp.instanceInit = function(sample_rate) {\n      sp.factory.instanceInit(sp.dsp, sample_rate);\n    };\n    sp.instanceConstants = function(sample_rate) {\n      sp.factory.instanceConstants(sp.dsp, sample_rate);\n    };\n    sp.instanceResetUserInterface = function() {\n      sp.factory.instanceResetUserInterface(sp.dsp);\n    };\n    sp.instanceClear = function() {\n      sp.factory.instanceClear(sp.dsp);\n    };\n    sp.metadata = function(handler) {\n      if (factory2.json_object.meta) {\n        factory2.json_object.meta.forEach(function(meta) {\n          handler.declare(Object.keys(meta)[0], Object.values(meta)[0]);\n        });\n      }\n    };\n    sp.setOutputParamHandler = function(handler) {\n      sp.output_handler = handler;\n    };\n    sp.getOutputParamHandler = function() {\n      return sp.output_handler;\n    };\n    sp.ctrlChange = function(channel, ctrl, value) {\n      for (var i2 = 0; i2 < sp.fCtrlLabel[ctrl].length; i2++) {\n        var path = sp.fCtrlLabel[ctrl][i2].path;\n        sp.setParamValue(path, faust.remap(value, 0, 127, sp.fCtrlLabel[ctrl][i2].min, sp.fCtrlLabel[ctrl][i2].max));\n        if (sp.output_handler) {\n          sp.output_handler(path, sp.getParamValue(path));\n        }\n      }\n    };\n    sp.pitchWheel = function(channel, wheel) {\n      for (var i2 = 0; i2 < sp.fPitchwheelLabel.length; i2++) {\n        var pw = sp.fPitchwheelLabel[i2];\n        sp.setParamValue(pw.path, faust.remap(wheel, 0, 16383, pw.min, pw.max));\n        if (sp.output_handler) {\n          sp.output_handler(pw.path, sp.getParamValue(pw.path));\n        }\n      }\n    };\n    sp.setParamValue = function(path, val) {\n      return sp.factory.setParamValue(sp.dsp, sp.pathTable[path], val);\n    };\n    sp.getParamValue = function(path) {\n      return sp.factory.getParamValue(sp.dsp, sp.pathTable[path]);\n    };\n    sp.getParams = function() {\n      return sp.inputs_items;\n    };\n    sp.getJSON = function() {\n      return factory2.getJSON();\n    };\n    sp.initAux();\n    callback2(sp);\n  }).catch(function(error) {\n    faust.error_msg = \"Faust DSP cannot be instantiated\";\n    callback2(null);\n  });\n};\nfaust.deleteDSPInstance = function(dsp) {\n};\nvar mydspProcessorString = `\n\n    'use strict';\n\n    function getJSONmydsp() { return \\`GETJSON\\`; }\n    function getBase64Codemydsp() { return \\`GETBASE64CODE\\`; }\n\n    // Monophonic Faust DSP\n    class mydspProcessor extends AudioWorkletProcessor {\n\n        // JSON parsing functions\n        static parse_ui(ui, obj, callback)\n        {\n            for (var i = 0; i < ui.length; i++) {\n                mydspProcessor.parse_group(ui[i], obj, callback);\n            }\n        }\n\n        static parse_group(group, obj, callback)\n        {\n            if (group.items) {\n                mydspProcessor.parse_items(group.items, obj, callback);\n            }\n        }\n\n        static parse_items(items, obj, callback)\n        {\n            for (var i = 0; i < items.length; i++) {\n                callback(items[i], obj, callback);\n            }\n        }\n\n        static parse_item1(item, obj, callback)\n        {\n            if (item.type === \"vgroup\"\n                || item.type === \"hgroup\"\n                || item.type === \"tgroup\") {\n                mydspProcessor.parse_items(item.items, obj, callback);\n            } else if (item.type === \"hbargraph\"\n                       || item.type === \"vbargraph\") {\n            // Nothing\n            } else if (item.type === \"vslider\"\n                       || item.type === \"hslider\"\n                       || item.type === \"button\"\n                       || item.type === \"checkbox\"\n                       || item.type === \"nentry\") {\n                obj.push({ name: item.address,\n                         defaultValue: item.init,\n                         minValue: item.min,\n                         maxValue: item.max });\n            }\n        }\n\n        static parse_item2(item, obj, callback)\n        {\n            if (item.type === \"vgroup\"\n                || item.type === \"hgroup\"\n                || item.type === \"tgroup\") {\n                mydspProcessor.parse_items(item.items, obj, callback);\n            } else if (item.type === \"hbargraph\"\n                       || item.type === \"vbargraph\") {\n                // Keep bargraph adresses\n                obj.outputs_items.push(item.address);\n                obj.pathTable[item.address] = parseInt(item.index);\n            } else if (item.type === \"vslider\"\n                       || item.type === \"hslider\"\n                       || item.type === \"button\"\n                       || item.type === \"checkbox\"\n                       || item.type === \"nentry\") {\n                // Keep inputs adresses\n                obj.inputs_items.push(item.address);\n                obj.pathTable[item.address] = parseInt(item.index);\n            }\n        }\n\n        static b64ToUint6(nChr)\n        {\n            return nChr > 64 && nChr < 91 ?\n            nChr - 65\n            : nChr > 96 && nChr < 123 ?\n            nChr - 71\n            : nChr > 47 && nChr < 58 ?\n            nChr + 4\n            : nChr === 43 ?\n            62\n            : nChr === 47 ?\n            63\n            :\n            0;\n        }\n\n        static atob(sBase64, nBlocksSize)\n        {\n            if (typeof atob === 'function') {\n                return atob(sBase64);\n            } else {\n\n                var sB64Enc = sBase64.replace(/[^A-Za-z0-9+/]/g, \"\");\n                var nInLen = sB64Enc.length;\n                var nOutLen = nBlocksSize ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize : nInLen * 3 + 1 >> 2;\n                var taBytes = new Uint8Array(nOutLen);\n\n                for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {\n                    nMod4 = nInIdx & 3;\n                    nUint24 |= mydspProcessor.b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4;\n                    if (nMod4 === 3 || nInLen - nInIdx === 1) {\n                        for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {\n                            taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;\n                        }\n                        nUint24 = 0;\n                    }\n                }\n                return taBytes.buffer;\n            }\n        }\n\n        static remap(v, mn0, mx0, mn1, mx1)\n        {\n            return (1.0 * (v - mn0) / (mx0 - mn0)) * (mx1 - mn1) + mn1;\n        }\n\n        static get parameterDescriptors ()\n        {\n            // Analyse JSON to generate AudioParam parameters\n            var params = [];\n            mydspProcessor.parse_ui(JSON.parse(getJSONmydsp()).ui, params, mydspProcessor.parse_item1);\n            return params;\n        }\n\n        constructor(options)\n        {\n            super(options);\n            this.running = true;\n\n            this.json_object = JSON.parse(getJSONmydsp());\n\n            this.output_handler = function(path, value) { this.port.postMessage({ path: path, value: value }); };\n\n            this.ins = null;\n            this.outs = null;\n\n            this.dspInChannnels = [];\n            this.dspOutChannnels = [];\n\n            this.numIn = parseInt(this.json_object.inputs);\n            this.numOut = parseInt(this.json_object.outputs);\n\n            // Memory allocator\n            this.ptr_size = 4;\n            this.sample_size = 4;\n\n            // Create the WASM instance\n            var wasm_instance = new WebAssembly.Instance(mydspProcessor.wasm_module, mydspProcessor.importObject);\n            this.factory = wasm_instance.exports;\n            this.HEAP = wasm_instance.exports.memory.buffer;\n            this.HEAP32 = new Int32Array(this.HEAP);\n            this.HEAPF32 = new Float32Array(this.HEAP);\n\n            //console.log(this.HEAP);\n            //console.log(this.HEAP32);\n            //console.log(this.HEAPF32);\n\n            // bargraph\n            this.outputs_timer = 5;\n            this.outputs_items = [];\n\n            // input items\n            this.inputs_items = [];\n\n            // Start of HEAP index\n\n            // DSP is placed first with index 0. Audio buffer start at the end of DSP.\n            this.audio_heap_ptr = parseInt(this.json_object.size);\n\n            // Setup pointers offset\n            this.audio_heap_ptr_inputs = this.audio_heap_ptr;\n            this.audio_heap_ptr_outputs = this.audio_heap_ptr_inputs + (this.numIn * this.ptr_size);\n\n            // Setup buffer offset\n            this.audio_heap_inputs = this.audio_heap_ptr_outputs + (this.numOut * this.ptr_size);\n            this.audio_heap_outputs = this.audio_heap_inputs + (this.numIn * mydspProcessor.buffer_size * this.sample_size);\n\n            // Start of DSP memory : DSP is placed first with index 0\n            this.dsp = 0;\n\n            this.pathTable = [];\n\n            // Send output values to the AudioNode\n            this.update_outputs = function ()\n            {\n                if (this.outputs_items.length > 0 && this.output_handler && this.outputs_timer-- === 0) {\n                    this.outputs_timer = 5;\n                    for (var i = 0; i < this.outputs_items.length; i++) {\n                        this.output_handler(this.outputs_items[i], this.HEAPF32[this.pathTable[this.outputs_items[i]] >> 2]);\n                    }\n                }\n            }\n\n            this.initAux = function ()\n            {\n                var i;\n\n                if (this.numIn > 0) {\n                    this.ins = this.audio_heap_ptr_inputs;\n                    for (i = 0; i < this.numIn; i++) {\n                        this.HEAP32[(this.ins >> 2) + i] = this.audio_heap_inputs + ((mydspProcessor.buffer_size * this.sample_size) * i);\n                    }\n\n                    // Prepare Ins buffer tables\n                    var dspInChans = this.HEAP32.subarray(this.ins >> 2, (this.ins + this.numIn * this.ptr_size) >> 2);\n                    for (i = 0; i < this.numIn; i++) {\n                        this.dspInChannnels[i] = this.HEAPF32.subarray(dspInChans[i] >> 2, (dspInChans[i] + mydspProcessor.buffer_size * this.sample_size) >> 2);\n                    }\n                }\n\n                if (this.numOut > 0) {\n                    this.outs = this.audio_heap_ptr_outputs;\n                    for (i = 0; i < this.numOut; i++) {\n                        this.HEAP32[(this.outs >> 2) + i] = this.audio_heap_outputs + ((mydspProcessor.buffer_size * this.sample_size) * i);\n                    }\n\n                    // Prepare Out buffer tables\n                    var dspOutChans = this.HEAP32.subarray(this.outs >> 2, (this.outs + this.numOut * this.ptr_size) >> 2);\n                    for (i = 0; i < this.numOut; i++) {\n                        this.dspOutChannnels[i] = this.HEAPF32.subarray(dspOutChans[i] >> 2, (dspOutChans[i] + mydspProcessor.buffer_size * this.sample_size) >> 2);\n                    }\n                }\n\n                // Parse UI\n                mydspProcessor.parse_ui(this.json_object.ui, this, mydspProcessor.parse_item2);\n\n                // Init DSP\n                this.factory.init(this.dsp, sampleRate); // 'sampleRate' is defined in AudioWorkletGlobalScope\n            }\n\n            this.setParamValue = function (path, val)\n            {\n                this.HEAPF32[this.pathTable[path] >> 2] = val;\n            }\n\n            this.getParamValue = function (path)\n            {\n                return this.HEAPF32[this.pathTable[path] >> 2];\n            }\n\n            // Init resulting DSP\n            this.initAux();\n        }\n\n        process(inputs, outputs, parameters)\n        {\n            var input = inputs[0];\n            var output = outputs[0];\n\n            // Check inputs\n            if (this.numIn > 0 && (!input || !input[0] || input[0].length === 0)) {\n                //console.log(\"Process input error\");\n                return true;\n            }\n            // Check outputs\n            if (this.numOut > 0 && (!output || !output[0] || output[0].length === 0)) {\n                //console.log(\"Process output error\");\n                return true;\n            }\n\n            // Copy inputs\n            if (input !== undefined) {\n                for (var chan = 0; chan < Math.min(this.numIn, input.length) ; ++chan) {\n                    var dspInput = this.dspInChannnels[chan];\n                    dspInput.set(input[chan]);\n                }\n            }\n            \n            /*\n            TODO: sample accurate control change is not yet handled\n            When no automation occurs, params[i][1] has a length of 1,\n            otherwise params[i][1] has a length of NUM_FRAMES with possible control change each sample\n            */\n\n            // Update controls (possibly needed for sample accurate control)\n            for (const path in parameters) {\n            \tconst paramArray = parameters[path];\n            \tthis.setParamValue(path, paramArray[0]);\n            }\n\n           // Compute\n            try {\n                this.factory.compute(this.dsp, mydspProcessor.buffer_size, this.ins, this.outs);\n            } catch(e) {\n                console.log(\"ERROR in compute (\" + e + \")\");\n            }\n            \n            // Update bargraph\n            this.update_outputs();\n\n            // Copy outputs\n            if (output !== undefined) {\n                for (var chan = 0; chan < Math.min(this.numOut, output.length); ++chan) {\n                    var dspOutput = this.dspOutChannnels[chan];\n                    output[chan].set(dspOutput);\n                }\n            }\n\n            return this.running;\n        }\n        \n        handleMessage(event)\n        {\n            var msg = event.data;\n            switch (msg.type) {\n                case \"destroy\": this.running = false; break;\n            }\n        }\n    }\n\n    // Globals\n\n    mydspProcessor.buffer_size = 128;\n\n    mydspProcessor.importObject = {\n        env: {\n            memoryBase: 0,\n            tableBase: 0,\n\n            // Integer version\n            _abs: Math.abs,\n\n            // Float version\n            _acosf: Math.acos,\n            _asinf: Math.asin,\n            _atanf: Math.atan,\n            _atan2f: Math.atan2,\n            _ceilf: Math.ceil,\n            _cosf: Math.cos,\n            _expf: Math.exp,\n            _floorf: Math.floor,\n            _fmodf: function(x, y) { return x % y; },\n            _logf: Math.log,\n            _log10f: Math.log10,\n            _max_f: Math.max,\n            _min_f: Math.min,\n            _remainderf: function(x, y) { return x - Math.round(x/y) * y; },\n            _powf: Math.pow,\n            _roundf: Math.fround,\n            _sinf: Math.sin,\n            _sqrtf: Math.sqrt,\n            _tanf: Math.tan,\n            _acoshf: Math.acosh,\n            _asinhf: Math.asinh,\n            _atanhf: Math.atanh,\n            _coshf: Math.cosh,\n            _sinhf: Math.sinh,\n            _tanhf: Math.tanh,\n            _isnanf: Number.isNaN,\n            _isinff: function (x) { return !isFinite(x); },\n            _copysignf: function (x, y) { return Math.sign(x) === Math.sign(y) ? x : -x; },    \n\n            // Double version\n            _acos: Math.acos,\n            _asin: Math.asin,\n            _atan: Math.atan,\n            _atan2: Math.atan2,\n            _ceil: Math.ceil,\n            _cos: Math.cos,\n            _exp: Math.exp,\n            _floor: Math.floor,\n            _fmod: function(x, y) { return x % y; },\n            _log: Math.log,\n            _log10: Math.log10,\n            _max_: Math.max,\n            _min_: Math.min,\n            _remainder:function(x, y) { return x - Math.round(x/y) * y; },\n            _pow: Math.pow,\n            _round: Math.fround,\n            _sin: Math.sin,\n            _sqrt: Math.sqrt,\n            _tan: Math.tan,\n            _acosh: Math.acosh,\n            _asinh: Math.asinh,\n            _atanh: Math.atanh,\n            _cosh: Math.cosh,\n            _sinh: Math.sinh,\n            _tanh: Math.tanh,\n            _isnan: Number.isNaN,\n            _isinf: function (x) { return !isFinite(x); },\n            _copysign: function (x, y) { return Math.sign(x) === Math.sign(y) ? x : -x; },    \n\n            table: new WebAssembly.Table({ initial: 0, element: 'anyfunc' })\n        }\n    };\n\n    // Synchronously compile and instantiate the WASM module\n    try {\n        mydspProcessor.wasm_module = new WebAssembly.Module(mydspProcessor.atob(getBase64Codemydsp()));\n        registerProcessor('mydsp', mydspProcessor);\n    } catch (e) {\n        // REMOVED: console log noise that doesnt affect output\n        // I assume if it were serious this error would not be caught and not rethrown\n        // console.log(e); console.log(\"Faust mydsp cannot be loaded or compiled\");\n    }\n`;\nfaust.createDSPWorkletInstanceAux = function(factory2, context, callback2) {\n  context.resume().catch(() => {\n  });\n  var audio_node = new AudioWorkletNode(context, factory2.name, {\n    numberOfInputs: parseInt(factory2.json_object.inputs) > 0 ? 1 : 0,\n    numberOfOutputs: parseInt(factory2.json_object.outputs) > 0 ? 1 : 0,\n    channelCount: Math.max(1, parseInt(factory2.json_object.inputs)),\n    outputChannelCount: [parseInt(factory2.json_object.outputs)],\n    channelCountMode: \"explicit\",\n    channelInterpretation: \"speakers\"\n  });\n  audio_node.onprocessorerror = () => {\n    console.log(\"An error from mydspProcessor was detected.\");\n  };\n  audio_node.handleMessage = function(event) {\n    var msg = event.data;\n    if (this.output_handler) {\n      this.output_handler(msg.path, msg.value);\n    }\n  };\n  audio_node.init = function() {\n    this.parse_ui = function(ui, obj) {\n      for (var i2 = 0; i2 < ui.length; i2++) {\n        this.parse_group(ui[i2], obj);\n      }\n    };\n    this.parse_group = function(group, obj) {\n      if (group.items) {\n        this.parse_items(group.items, obj);\n      }\n    };\n    this.parse_items = function(items, obj) {\n      for (var i2 = 0; i2 < items.length; i2++) {\n        this.parse_item(items[i2], obj);\n      }\n    };\n    this.parse_item = function(item, obj) {\n      if (item.type === \"vgroup\" || item.type === \"hgroup\" || item.type === \"tgroup\") {\n        this.parse_items(item.items, obj);\n      } else if (item.type === \"hbargraph\" || item.type === \"vbargraph\") {\n        obj.outputs_items.push(item.address);\n      } else if (item.type === \"vslider\" || item.type === \"hslider\" || item.type === \"button\" || item.type === \"checkbox\" || item.type === \"nentry\") {\n        obj.inputs_items.push(item.address);\n        if (item.meta !== void 0) {\n          for (var i2 = 0; i2 < item.meta.length; i2++) {\n            if (item.meta[i2].style !== void 0) {\n              obj.inputs_meta[item.address] = item.meta[i2].style;\n            }\n            if (item.meta[i2].midi !== void 0) {\n              if (item.meta[i2].midi.trim() === \"pitchwheel\") {\n                obj.fPitchwheelLabel.push({\n                  path: item.address,\n                  min: parseFloat(item.min),\n                  max: parseFloat(item.max)\n                });\n              } else if (item.meta[i2].midi.trim().split(\" \")[0] === \"ctrl\") {\n                obj.fCtrlLabel[parseInt(item.meta[i2].midi.trim().split(\" \")[1])].push({\n                  path: item.address,\n                  min: parseFloat(item.min),\n                  max: parseFloat(item.max)\n                });\n              }\n            }\n          }\n        }\n      }\n    };\n    this.output_handler = null;\n    this.json_object = factory2.json_object;\n    this.inputs_items = [];\n    this.outputs_items = [];\n    this.inputs_meta = {};\n    this.fPitchwheelLabel = [];\n    this.fCtrlLabel = new Array(128);\n    for (var i = 0; i < this.fCtrlLabel.length; i++) {\n      this.fCtrlLabel[i] = [];\n    }\n    this.parse_ui(this.json_object.ui, this);\n    this.port.onmessage = this.handleMessage.bind(this);\n  };\n  audio_node.init();\n  audio_node.destroy = function() {\n    this.port.postMessage({ type: \"destroy\" });\n    this.port.close();\n  };\n  audio_node.getJSON = function() {\n    return factory2.getJSON();\n  };\n  audio_node.setParamValue = function(path, val) {\n    this.parameters.get(path).setValueAtTime(val, 0);\n  };\n  audio_node.setParamValueAtTime = function(path, val, time) {\n    this.parameters.get(path).setValueAtTime(val, time);\n  };\n  audio_node.getParamValue = function(path) {\n    return this.parameters.get(path).value;\n  };\n  audio_node.getRawParam = function(path) {\n    return this.parameters.get(path);\n  };\n  audio_node.getMeta = function() {\n    return this.inputs_meta;\n  };\n  audio_node.setOutputParamHandler = function(handler) {\n    this.output_handler = handler;\n  };\n  audio_node.getOutputParamHandler = function() {\n    return this.output_handler;\n  };\n  audio_node.getNumInputs = function() {\n    return parseInt(factory2.json_object.inputs);\n  };\n  audio_node.getNumOutputs = function() {\n    return parseInt(factory2.json_object.outputs);\n  };\n  audio_node.inputChannelCount = function() {\n    return parseInt(factory2.json_object.inputs);\n  };\n  audio_node.outputChannelCount = function() {\n    return parseInt(factory2.json_object.outputs);\n  };\n  audio_node.getParams = function() {\n    return this.inputs_items;\n  };\n  audio_node.getDescriptor = function() {\n    return this.inputs_items;\n  };\n  audio_node.ctrlChange = function(channel, ctrl, value) {\n    for (var i = 0; i < this.fCtrlLabel[ctrl].length; i++) {\n      var path = this.fCtrlLabel[ctrl][i].path;\n      this.setParamValue(path, audio_node.remap(value, 0, 127, this.fCtrlLabel[ctrl][i].min, this.fCtrlLabel[ctrl][i].max));\n      if (this.output_handler) {\n        this.output_handler(path, this.getParamValue(path));\n      }\n    }\n  };\n  audio_node.pitchWheel = function(channel, wheel) {\n    for (var i = 0; i < this.fPitchwheelLabel.length; i++) {\n      var pw = this.fPitchwheelLabel[i];\n      this.setParamValue(pw.path, audio_node.remap(wheel, 0, 16383, pw.min, pw.max));\n      if (this.output_handler) {\n        this.output_handler(pw.path, this.getParamValue(pw.path));\n      }\n    }\n  };\n  audio_node.midiMessage = function(data) {\n    var cmd = data[0] >> 4;\n    var channel = data[0] & 15;\n    var data1 = data[1];\n    var data2 = data[2];\n    if (channel === 9) {\n      return;\n    } else if (cmd === 11) {\n      this.ctrlChange(channel, data1, data2);\n    } else if (cmd === 14) {\n      this.pitchWheel(channel, data2 * 128 + data1);\n    }\n  };\n  audio_node.onMidi = function(data) {\n    this.midiMessage(data);\n  };\n  audio_node.getState = async function() {\n    var params = new Object();\n    for (let i = 0; i < this.getDescriptor().length; i++) {\n      Object.assign(params, {\n        [this.getDescriptor()[i]]: `${this.getParam(this.getDescriptor()[i])}`\n      });\n    }\n    return new Promise((resolve) => {\n      resolve(params);\n    });\n  };\n  audio_node.setState = async function(state) {\n    return new Promise((resolve) => {\n      for (const param in state) {\n        if (state.hasOwnProperty(param))\n          this.setParam(param, state[param]);\n      }\n      try {\n        this.gui.setAttribute(\"state\", JSON.stringify(state));\n      } catch (error) {\n        console.warn(\"Plugin without gui or GUI not defined\", error);\n      }\n      resolve(state);\n    });\n  };\n  audio_node.setPatch = function(patch) {\n    this.setState(this.presets[patch]);\n  };\n  audio_node.metadata = function(handler) {\n  };\n  audio_node.remap = function(v, mn0, mx0, mn1, mx1) {\n    return 1 * (v - mn0) / (mx0 - mn0) * (mx1 - mn1) + mn1;\n  };\n  callback2(audio_node);\n};\nfaust.createDSPWorkletInstance = function(factory2, context, callback2) {\n  var re1 = /mydsp/g;\n  var re2 = /GETJSON/g;\n  var re3 = /GETBASE64CODE/g;\n  var mydspProcessorString1 = mydspProcessorString.replace(re1, factory2.name);\n  var mydspProcessorString2 = mydspProcessorString1.replace(re2, factory2.getJSON());\n  var mydspProcessorString3 = mydspProcessorString2.replace(re3, factory2.getBase64Code());\n  var url = window.URL.createObjectURL(new Blob([mydspProcessorString3], { type: \"text/javascript\" }));\n  context.audioWorklet.addModule(url).then(function() {\n    faust.createDSPWorkletInstanceAux(factory2, context, callback2);\n  }).catch(function(error) {\n    alert(error);\n  });\n};\nfaust.deleteDSPWorkletInstance = function(dsp) {\n};\nfaust.ready;\nconst factoryCache = /* @__PURE__ */ new Map();\nasync function compile(audioContext, dsp) {\n  const argv = [\"-ftz\", \"2\", \"-I\", \"http://127.0.0.1:8000/../../libraries/\"];\n  let factoryPromise = factoryCache.get(dsp);\n  if (!factoryPromise) {\n    factoryPromise = new Promise((resolve) => faust.createDSPFactory(dsp, argv, resolve));\n    factoryCache.set(dsp, factoryPromise);\n  }\n  const factory2 = await factoryPromise;\n  if (!factory2) {\n    throw new Error(faust.error_msg);\n  }\n  const node = await new Promise((resolve) => faust.createDSPWorkletInstance(factory2, audioContext, resolve));\n  if (!node) {\n    throw new Error(faust.error_msg);\n  }\n  node.ui = JSON.parse(node.getJSON()).ui;\n  const outputValues = /* @__PURE__ */ new Map();\n  node.setOutputParamHandler((path, value) => {\n    outputValues.set(path, value);\n  });\n  node.getOutputValue = (path) => {\n    return outputValues.get(path) ?? 0;\n  };\n  return node;\n}\nasync function offlineRenderDspInner(offlineCtx, source, props) {\n  const node = await compile(offlineCtx, props.dsp);\n  source?.connect(node);\n  node.connect(offlineCtx.destination);\n}\nexports.offlineRenderDspInner = offlineRenderDspInner;\n";

var offlineRenderInnerStringified = "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction audioBufferToWav(buffer, opt) {\n  opt = opt || {};\n  var numChannels = buffer.numberOfChannels;\n  var sampleRate = buffer.sampleRate;\n  var format = opt.float32 ? 3 : 1;\n  var bitDepth = format === 3 ? 32 : 16;\n  var result;\n  if (numChannels === 2) {\n    result = interleave(buffer.getChannelData(0), buffer.getChannelData(1));\n  } else {\n    result = buffer.getChannelData(0);\n  }\n  return encodeWAV(result, format, sampleRate, numChannels, bitDepth);\n}\nfunction encodeWAV(samples, format, sampleRate, numChannels, bitDepth) {\n  var bytesPerSample = bitDepth / 8;\n  var blockAlign = numChannels * bytesPerSample;\n  var buffer = new ArrayBuffer(44 + samples.length * bytesPerSample);\n  var view = new DataView(buffer);\n  writeString(view, 0, \"RIFF\");\n  view.setUint32(4, 36 + samples.length * bytesPerSample, true);\n  writeString(view, 8, \"WAVE\");\n  writeString(view, 12, \"fmt \");\n  view.setUint32(16, 16, true);\n  view.setUint16(20, format, true);\n  view.setUint16(22, numChannels, true);\n  view.setUint32(24, sampleRate, true);\n  view.setUint32(28, sampleRate * blockAlign, true);\n  view.setUint16(32, blockAlign, true);\n  view.setUint16(34, bitDepth, true);\n  writeString(view, 36, \"data\");\n  view.setUint32(40, samples.length * bytesPerSample, true);\n  if (format === 1) {\n    floatTo16BitPCM(view, 44, samples);\n  } else {\n    writeFloat32(view, 44, samples);\n  }\n  return buffer;\n}\nfunction interleave(inputL, inputR) {\n  var length = inputL.length + inputR.length;\n  var result = new Float32Array(length);\n  var index = 0;\n  var inputIndex = 0;\n  while (index < length) {\n    result[index++] = inputL[inputIndex];\n    result[index++] = inputR[inputIndex];\n    inputIndex++;\n  }\n  return result;\n}\nfunction writeFloat32(output, offset, input) {\n  for (var i = 0; i < input.length; i++, offset += 4) {\n    output.setFloat32(offset, input[i], true);\n  }\n}\nfunction floatTo16BitPCM(output, offset, input) {\n  for (var i = 0; i < input.length; i++, offset += 2) {\n    var s = Math.max(-1, Math.min(1, input[i]));\n    output.setInt16(offset, s < 0 ? s * 32768 : s * 32767, true);\n  }\n}\nfunction writeString(view, offset, string) {\n  for (var i = 0; i < string.length; i++) {\n    view.setUint8(offset + i, string.charCodeAt(i));\n  }\n}\nfunction createAudioCtx(audioCtxOrSampleRate) {\n  if (typeof audioCtxOrSampleRate === \"number\") {\n    return new AudioContext({ sampleRate: audioCtxOrSampleRate });\n  }\n  return audioCtxOrSampleRate;\n}\nfunction isObjectType(type, value) {\n  return Object.prototype.toString.call(value) === `[object ${type}]`;\n}\nfunction isAudioArray(value) {\n  return Array.isArray(value) && value.length > 0 && Array.isArray(value[0]);\n}\nfunction isFloat32AudioArray(value) {\n  return Array.isArray(value) && value.length > 0 && isObjectType(\"Float32Array\", value[0]);\n}\nfunction isAudioBuffer(value) {\n  return isObjectType(\"AudioBuffer\", value);\n}\nfunction isArrayBuffer(value) {\n  return isObjectType(\"ArrayBuffer\", value);\n}\nfunction audioArrayToAudioBuffer(channels, audioCtx) {\n  const buffer = audioCtx.createBuffer(channels.length, channels[0].length, audioCtx.sampleRate);\n  for (let channel = 0; channel < buffer.numberOfChannels; channel++) {\n    const nowBuffering = buffer.getChannelData(channel);\n    for (let i = 0; i < buffer.length; i++) {\n      nowBuffering[i] = channels[channel][i];\n    }\n  }\n  return buffer;\n}\nasync function arrayBufferToAudioBuffer(arrayBuffer, audioCtx) {\n  return await new Promise((resolve) => audioCtx.decodeAudioData(arrayBuffer, resolve));\n}\nasync function toAudioBuffer(input, audioCtxOrSampleRate) {\n  if (isAudioBuffer(input)) {\n    return input;\n  }\n  const audioCtx = createAudioCtx(audioCtxOrSampleRate);\n  if (isArrayBuffer(input)) {\n    return arrayBufferToAudioBuffer(input, audioCtx);\n  }\n  if (isAudioArray(input) || isFloat32AudioArray(input)) {\n    return audioArrayToAudioBuffer(input, audioCtx);\n  }\n  throw new Error(`toAudioBuffer: unconvertible input type: ${input}`);\n}\nasync function toArrayBuffer(input, audioCtxOrSampleRate) {\n  if (isArrayBuffer(input)) {\n    return input;\n  }\n  const audioCtx = createAudioCtx(audioCtxOrSampleRate);\n  const buffer = await toAudioBuffer(input, audioCtx);\n  return audioBufferToWav(buffer, { float32: true });\n}\nfunction offlineRenderInner(callback) {\n  return async (params) => {\n    const { channels, length, sampleRate, inputArrayBuffer, props } = params;\n    const offlineContext = new OfflineAudioContext(channels, length, sampleRate);\n    let source;\n    if (inputArrayBuffer) {\n      source = offlineContext.createBufferSource();\n      source.buffer = await toAudioBuffer(inputArrayBuffer, sampleRate);\n    }\n    if (typeof callback !== \"function\") {\n      throw new Error(`functionString must set exports.buildContext`);\n    }\n    await callback(offlineContext, source, props);\n    source?.start();\n    const audioBuffer = await offlineContext.startRendering();\n    const arrayBuffer = await toArrayBuffer(audioBuffer, sampleRate);\n    return [arrayBuffer, [arrayBuffer]];\n  };\n}\nexports.offlineRenderInner = offlineRenderInner;\n";

function audioBufferToWav(buffer, opt) {
  opt = opt || {};
  var numChannels = buffer.numberOfChannels;
  var sampleRate = buffer.sampleRate;
  var format = opt.float32 ? 3 : 1;
  var bitDepth = format === 3 ? 32 : 16;
  var result;
  if (numChannels === 2) {
    result = interleave(buffer.getChannelData(0), buffer.getChannelData(1));
  } else {
    result = buffer.getChannelData(0);
  }
  return encodeWAV(result, format, sampleRate, numChannels, bitDepth);
}
function encodeWAV(samples, format, sampleRate, numChannels, bitDepth) {
  var bytesPerSample = bitDepth / 8;
  var blockAlign = numChannels * bytesPerSample;
  var buffer = new ArrayBuffer(44 + samples.length * bytesPerSample);
  var view = new DataView(buffer);
  writeString(view, 0, "RIFF");
  view.setUint32(4, 36 + samples.length * bytesPerSample, true);
  writeString(view, 8, "WAVE");
  writeString(view, 12, "fmt ");
  view.setUint32(16, 16, true);
  view.setUint16(20, format, true);
  view.setUint16(22, numChannels, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * blockAlign, true);
  view.setUint16(32, blockAlign, true);
  view.setUint16(34, bitDepth, true);
  writeString(view, 36, "data");
  view.setUint32(40, samples.length * bytesPerSample, true);
  if (format === 1) {
    floatTo16BitPCM(view, 44, samples);
  } else {
    writeFloat32(view, 44, samples);
  }
  return buffer;
}
function interleave(inputL, inputR) {
  var length = inputL.length + inputR.length;
  var result = new Float32Array(length);
  var index = 0;
  var inputIndex = 0;
  while (index < length) {
    result[index++] = inputL[inputIndex];
    result[index++] = inputR[inputIndex];
    inputIndex++;
  }
  return result;
}
function writeFloat32(output, offset, input) {
  for (var i = 0; i < input.length; i++, offset += 4) {
    output.setFloat32(offset, input[i], true);
  }
}
function floatTo16BitPCM(output, offset, input) {
  for (var i = 0; i < input.length; i++, offset += 2) {
    var s = Math.max(-1, Math.min(1, input[i]));
    output.setInt16(offset, s < 0 ? s * 32768 : s * 32767, true);
  }
}
function writeString(view, offset, string) {
  for (var i = 0; i < string.length; i++) {
    view.setUint8(offset + i, string.charCodeAt(i));
  }
}

function createAudioCtx(audioCtxOrSampleRate) {
  if (typeof audioCtxOrSampleRate === "number") {
    return new AudioContext({ sampleRate: audioCtxOrSampleRate });
  }
  return audioCtxOrSampleRate;
}
function isObjectType(type, value) {
  return Object.prototype.toString.call(value) === `[object ${type}]`;
}
function isAudioArray(value) {
  return Array.isArray(value) && value.length > 0 && Array.isArray(value[0]);
}
function isFloat32AudioArray(value) {
  return Array.isArray(value) && value.length > 0 && isObjectType("Float32Array", value[0]);
}
function isAudioBuffer(value) {
  return isObjectType("AudioBuffer", value);
}
function isArrayBuffer(value) {
  return isObjectType("ArrayBuffer", value);
}
function audioArrayToAudioBuffer(channels, audioCtx) {
  const buffer = audioCtx.createBuffer(channels.length, channels[0].length, audioCtx.sampleRate);
  for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
    const nowBuffering = buffer.getChannelData(channel);
    for (let i = 0; i < buffer.length; i++) {
      nowBuffering[i] = channels[channel][i];
    }
  }
  return buffer;
}
function audioBufferToFloat32AudioArray(audioBuffer) {
  const channels = [];
  for (let i = 0; i < audioBuffer.numberOfChannels; i++) {
    channels.push(audioBuffer.getChannelData(i));
  }
  return channels;
}
function arrayToFloat32AudioArray(arr) {
  return arr.map((arr2) => new Float32Array(arr2));
}
async function arrayBufferToAudioBuffer(arrayBuffer, audioCtx) {
  return await new Promise((resolve) => audioCtx.decodeAudioData(arrayBuffer, resolve));
}
function toFloat32AudioArray(input) {
  if (isFloat32AudioArray(input)) {
    return input;
  }
  if (isAudioArray(input)) {
    return arrayToFloat32AudioArray(input);
  }
  if (isAudioBuffer(input)) {
    return audioBufferToFloat32AudioArray(input);
  }
  throw new Error(`toFloat32AudioArray: unconvertible input type: ${input}`);
}
async function toAudioBuffer(input, audioCtxOrSampleRate) {
  if (isAudioBuffer(input)) {
    return input;
  }
  const audioCtx = createAudioCtx(audioCtxOrSampleRate);
  if (isArrayBuffer(input)) {
    return arrayBufferToAudioBuffer(input, audioCtx);
  }
  if (isAudioArray(input) || isFloat32AudioArray(input)) {
    return audioArrayToAudioBuffer(input, audioCtx);
  }
  throw new Error(`toAudioBuffer: unconvertible input type: ${input}`);
}
async function toArrayBuffer(input, audioCtxOrSampleRate) {
  if (isArrayBuffer(input)) {
    return input;
  }
  const audioCtx = createAudioCtx(audioCtxOrSampleRate);
  const buffer = await toAudioBuffer(input, audioCtx);
  return audioBufferToWav(buffer, { float32: true });
}

var runInIframeInnerStringified = "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function receiveParams() {\n  return new Promise((resolve) => {\n    const messageListener = (message) => {\n      if (message.source !== window.parent || message.origin !== window.location.origin) {\n        return;\n      }\n      window.removeEventListener(\"message\", messageListener);\n      resolve(message.data);\n    };\n    window.addEventListener(\"message\", messageListener);\n  });\n}\nasync function sendResult(result, transferrables) {\n  window.parent.postMessage(result, window.location.origin, transferrables);\n}\nasync function runInIframeInner(callback) {\n  const params = await receiveParams();\n  const [result, transferrables = []] = await callback(params);\n  sendResult(result, transferrables);\n}\nexports.runInIframeInner = runInIframeInner;\n";

async function runInIframe(options) {
  const { functionString, params, transferrables = [] } = options;
  const iframe = document.createElement("iframe");
  iframe.style.display = "none";
  document.body.append(iframe);
  const { contentWindow } = iframe;
  if (!contentWindow)
    throw new Error(`contentWindow not available on iframe`);
  contentWindow.document.write(`<script>
      var exports = {};
      ${functionString}
      ${runInIframeInnerStringified}
      exports.runInIframeInner(exports.run);
    <\/script>`);
  return new Promise((resolve) => {
    const messageListener = (message) => {
      if (message.source !== contentWindow)
        return;
      window.removeEventListener("message", messageListener);
      iframe.remove();
      resolve(message.data);
    };
    window.addEventListener("message", messageListener);
    contentWindow.postMessage(params, window.location.origin, transferrables);
  });
}

async function offlineRender(params) {
  const { functionString = "", channels, sampleRate, input, props } = params;
  let { length } = params;
  let inputArrayBuffer;
  let transferrables = [];
  if (input) {
    inputArrayBuffer = await toArrayBuffer(input, sampleRate);
    transferrables = [inputArrayBuffer];
    if (length === void 0) {
      length = toFloat32AudioArray(input)[0]?.length ?? 0;
    }
  }
  const result = await runInIframe({
    functionString: `
      ${offlineRenderInnerStringified}
      ${functionString}
      exports.run = exports.offlineRenderInner(exports.buildContext);
    `,
    params: {
      channels,
      sampleRate,
      inputArrayBuffer,
      length: length ?? 0,
      props
    },
    transferrables
  });
  const audioBuffer = await toAudioBuffer(result, sampleRate);
  return toFloat32AudioArray(audioBuffer);
}

async function offlineRenderDsp(params) {
  const { dsp, ...rest } = params;
  return offlineRender({
    functionString: `
      ${offlineRenderDspInnerStringified}
      exports.buildContext = exports.offlineRenderDspInner;
    `,
    props: {
      dsp
    },
    ...rest
  });
}

exports.offlineRenderDsp = offlineRenderDsp;
//# sourceMappingURL=offline-render-dsp.js.map
